# John Whitton

> John Whitton's personal website

![John Whitton Work History](/images/JohnWhittonWorkHistory.png "John Whitton Work History")

Hello, I'm John, and I'm a Research/engineer, technical leader, and entrepreneur working at the intersection of blockchain infrastructure (Solving, Market Making, Arbitrage) and Decentralized protocols (Intents, Liquidity Management, Settlement). I have a track record of driving projects from conception to completion, identifying research gaps, and providing solutions. Finally, I love leading engineering teams and have the ability to drive collaboration across the organization and the entire ecosystem.

I use [jincubator](https://github.com/jincubator) for research and development of prototypes. [Here](/research/solving/intro) you'll find an overview of my work in 2025 on Solving, Arbitrage and Indexing, an opinionated architecture is [here](/research/solving/architecture). It uses [Tycho](https://docs.propellerheads.xyz/tycho/overview), Intents using [ERC-7683](https://www.erc7683.org/spec), [EIP-712](https://eips.ethereum.org/EIPS/eip-712), [Compactx](https://github.com/uniswap/compactx) and [Uniswap V4 Hooks](https://docs.uniswap.org/contracts/v4/overview).

As of July 2025 I'm currently wanting to collaborate with thought leaders in this space. Specifically I'm interested in

* Grants and Bounties: Including Deliverable based grants around solving, routing, liquidity management
* Consulting Work: I'm interested in work primarily Smart Contract work and RUST Development in the Solving and Intent based space
* Full Time Roles: I'd enjoy working with a team in this space. TBD whether that will be launching the protocol I've been working with as part of a founding team or with a more established organization building out innovative frameworks in the space. I'm happy working as an individual contributor or leading engineering teams, as have done so for a large part of my career. Historically I've worked with Early Stage Startups 10-30 team members but am comfortable with both smaller and larger teams.

Below is a quick professional summary, more detail can be found on [the resume page](https://johnwhitton.com/resume/intro)

I worked as a Senior Protocol Engineer, previously Engineering Manager at [Eco](https://eco.com) building a payment focused intent protocol on a dedicated L3 rollup. Read the docs [here](https://docs.eco.com/) and the code [here](https://github.com/eco/eco-routes).

I have researched zero knowledge proofs, cryptographic primitives and consensus protocols.

I consulted as a research engineer providing strategy, research, design and building out DeFi infrastructure including trustless bridging, web3 identity and wallets. Deployments have been on EVM compatible chains including [Ethereum](https://ethereum.org/en/) and [Harmony](https://www.harmony.one/).

I prototyped the DEX [Kanga Finance](https://github.com/kangafinance) (inspired by [Sushi](https://github.com/sushiswap)) and a DeFi parachain [eave.network](https://github.com/eavenetwork) (inspired by [Acala](https://github.com/acalanetwork)). Deployments on [Harmony](https://www.harmony.one/) and [Polkadot](https://polkadot.network/). As founder for these projects, I was responsible for writing whitepapers, reviewing legal infrastructure, and fundraising. Although projects had investor interest and were awarded [hackathon prizes](https://docs.google.com/presentation/d/1ZGrbKSaAdtzvMzVh0EVFBfUvA4SqiAeYVXGhJN7Orbs/edit#slide=id.g48989ac23a_0_0) the projects did not move forward due to a combination of team commitment, market fit and crypto market conditions.

Previously I was as an Ecosystem Architect at Harmony. Where I helped launch the Harmony Mainnet, grew the ecosystem and was also intimately involved with hiring decisions and business strategy. Prior to this I was CTO for Loyyal (BaaS company) where we built private permissioned blockchains on Ethereum and Hypersphere Fabric and I managed a team of seven engineers.

I have worked extensively with decentralized financial protocols, bringing a unique perspective by combining my extensive corporate experience with IBM, SAP, Deloitte and KPMG with the disruptive financial models being developed on blockchain.

My earlier career focused on enterprise applications, service oriented architectures and cross application business processes. Where I founded a consultancy firm which grew to $800k in revenues and ran from 2000-2009. One of my former clients, EFI ($1.6 billion market cap) brought me on as a Manager in Enterprise Systems Architecture where I remained for 6 years.

I have been passionate about software and technology since high school. I graduated from the University of Queensland with a Bachelor of Science majoring in Computer Science before travelling globally leading the design and development of many Service Oriented Architectures and Blockchain implementations.

### Further Reading

* [The State of InterOp 2025](https://blog.li.fi/the-state-of-interop-2025-4a75d82a9bb9)
* [Intent Collective: a list of working projects in the Intents ecosystem](https://github.com/EnsoFinance/IntentCollective)
* [Illuminating Ethereum's Order Flow Landscape](https://writings.flashbots.net/illuminate-the-order-flow)


## Example

This is an example page.


## Get started

Hello world!


**One-page resume can be downloaded [here](https://johnwhitton.com/images/john.pdf) and viewed at the bottom of this page**

### Professional Summary

* Research/engineer, technical leader, and entrepreneur working at the intersection of blockchain infrastructure (Solving, Market Making, Arbitrage) and Decentralized protocols (Intents, Liquidity Management, Settlement).
* Track record of driving projects from conception to completion, identifying research gaps, and providing solutions.
* Proven leader of engineering teams with the ability to drive collaboration across the organization and the entire ecosystem.

### Achievements

##### Research and Engineering

* Designing and Building an Intent Based, Liquidity Management and Settlement Platform [jincubator](https://github.com/jincubator)
* Researching, designing and building a protocol for stablecoins on a dedicated L3 roll-up at [eco](https://eco.com) ([docs](https://docs.eco.com/), [eco-routes codebase](https://github.com/eco/eco-routes))
* Wrote multiple DeFi whitepapers (see [here](https://johnwhitton.com/writing/intro))
* Researched consensus, bridging, cryptographic primitives and zero knowledge proofs.
* Built Layer 1 platforms, DeFi protocols, non-custodial wallets, web3 identity, wallet infrastructure and NFT contracts for gaming character token sales.

##### Building Great Technical Teams

* Lead a team of 8 Engineers at ECO
* Grew Harmony from 6 to 20 Engineers
* Managed 7 engineers at LOYYAL
* Founded an enterprise consulting startup onboarding a team of 5.

##### Successful Product Launches

* 6 launches and multiple ecosystem releases including
  * [eco](https://eco.com)
  * [Gama Space Station NFT Launch](https://opensea.io/collection/gamaspacestation-genesis)
  * [1ns: harmony web3 identity](https://github.com/harmony-one/1ns-docs)
  * [Harmony Mainnet](https://medium.com/harmony-one/harmony-day-one-mainnet-b31ac0d80233)
  * [Dubai Points](https://medium.com/@Loyyal/dubai-points-looking-to-the-future-of-loyalty-250e12c3a2e5)
  * [Loyyal Mainnet (Hyperledger)](https://medium.com/@IBMBlockchain/loyyal-transforms-loyalty-with-hyperledger-fabric-638e1b2e86cd).

##### Founder

* Founded an enterprise consultancy firm which I grew to $800k in annual revenue and ran from 2000-2009.
* Lead research, legal framework for incorporation, compliance and fundraising efforts for multiple blockchain protocols.

### Projects / Work History

Below are links to projects I have designed and built or contributed to.

#### Founder / Research Engineer

##### [johnwhitton](https://johnwhitton.com): July 2018 - Present, Silicon Valley

* [jincubator.com](https://github.com/jincubator): Solving, Arbitrage and Indexing ([Tycho](https://docs.propellerheads.xyz/tycho/overview)), Intents ([ERC-7683](https://www.erc7683.org/spec),[EIP-712](https://eips.ethereum.org/EIPS/eip-712)), DEX([Uniswap V4 Hooks](https://docs.uniswap.org/contracts/v4/overview)), [UHI5 Atrium Academy](https://atrium.academy/uniswap).
* [isolab.gg](https://github.com/isolab-gg/isolab.gg): Trustless Bridge Research using Zero Knowledge Proofs including cryptographic primitives, consensus layer and zero knowledge implementations. See the
* [hiddenstate.xyz](https://hiddenstate.xyz/): [1.country](https://github.com/harmony-one/1ns-docs) implementation inspired by [ENS](https://ens.domains/) and enhanced to integrate web2 DNS server and SMTP routing.
* [modulo](https://modulo.so/): [1-wallet](https://github.com/polymorpher/one-wallet) and [sms-wallet](https://github.com/polymorpher/sms-wallet): non-custodial crypto wallet and lightweight crypto sms wallet.
* [kanga.finance](https://kanga.finance/): Dex implementation inspired by Sushi and proof of concept integration with one-wallet. ([github](https://github.com/kangafinance)). [Winner](https://docs.google.com/presentation/d/1ZGrbKSaAdtzvMzVh0EVFBfUvA4SqiAeYVXGhJN7Orbs/edit#slide=id.g48989ac23a_0_0) of $30,000 in prizes from [Harmony Hackathon](https://bounties.gitcoin.co/hackathon/harmony-defi/onboard).
* [eave.network](https://eave.network/): Polkadot DeFi Parachain ([github](https://github.com/EaveNetwork)) inspired by Acala and launched on the Rococo Network.
* em∆sset ([github](https://github.com/emasset)):
  * Designed StableCoin Payment Platform integrating with banking systems
  * Defi Research: Uniswap, Polkadot, Curve, Balancer, Coinbase Rosettanet
  * Built gRPC API Layer: proto, golang, grpc-gateway, openapi, MongoDB
  * Mobile App: Flutter, Dart integrating with gRPC Services
* WASDEX: designed a decentralized regulated platform for digital securities
* [Shell protocol](https://shellprotocol.io/): developed initial prototype of the COWRI protocol, a stable coin, meta layer which leveraged the 0x Protocol and became [Shell Protocol](https://shellprotocol.io/).
* Project X: wrote white paper for a layer 1 blockchain platform
* Pocketh - wrote design document for a mobile payment platform for restaurants using stable coins and collateralization.
* Jincubator: researched layer 1 platforms including polkadot, cosmos, stellar and ethereum

### Work History

Below are the organizations I have been fortunate enough to work for.

#### Engineering Manager - Senior Protocol Engineer

##### [Eco](https://eco.com): Aug 2023 - Jan 2025, Silicon Valley

A protocol for stablecoins on a dedicated roll-up using intents and account abstraction

* Lead a team of 8 engineers up until August 2024
* Senior Protocol Engineer from April 2024 to present
* L3 roll-up design and implementation of the ECO chain, read the [docs](https://docs.eco.com/)
* Developing Intent Protocol and cross-chain proving mechanisms, see the open sourced version of the code at [Cross-L2-Actions](https://github.com/ecoinc/Cross-L2-Actions)
* Manage development of [bend.eco](https://bend.eco) - fast cheap stable coin payments
* Lead the [Eco Association](https://github.com/eco-association) - [Currency 1.5 upgrade](https://github.com/eco-association/currency-1.5)

#### Ecosystem Architect

##### [Harmony](https://www.harmony.one/): August 2019 - May 2020, Silicon Valley

Layer 1 Proof of Stake, Sharded Blockchain Protocol

* Hired and Mentored over 10 Engineers growing the team from 6 to 20
* Launched Mainnet ONE, Token Swap and Open Staking
* Owned Developer Tooling including API, SDK, HRC and IDEs
* Deployed Network Upgrades including over 50 rollouts of complete Harmony Protocol and Network
* Presented Internationally at Technical Conferences
* Responsible for Partner Success and Developer Advocacy

#### Chief Technology Officer

##### [loyyal](https://loyyal.com/): July 2016 - Jun 2018, New York

Loyalty Platform leveraging tokenization of points using blockchain

* Hired and mentored a team of 7 engineers
* Launched LOYYAL program management suite on HYPERLEDGER
* Built Dubai Points the first loyalty mobile application built on blockchain
* Deployed and maintained a private ethereum network
* Owned partner success with IBM, Deloitte, Emirates Airlines, CIBC Bank

#### Founder, Engineering Manager, Architect, Developer

##### Enterprise Software and Consulting: July 1986 - Jun 2016, Global

Enterprise Software and Integration Platforms

* Managed over 100 initiatives and 50 staff at EFI
* Built EFI Business Integration Services an SOA platform integrating SAP, Salesforce, FLEXERA and external partners including CANON and Fedex
* Founded Global Enterprise Solutions a niche SAP technical consultancy and hired and mentored a team of 5
* Lead Autodesk Subscription Program integration - integrating SAP, TIBCO, SEEBEYOND, registration systems and CRM systems
* Developed Enterprise Software for the Mining Industry

### Whitepapers and Design Documents

* [1ns (dot-country)](https://github.com/harmony-one/1ns-docs): dot-country design and deployment overview.
* [Draft EAVE Whitepaper (2021)](https://johnwhitton.com/images/DraftEAVEWhitepaper.pdf): a multi-chain web3 engine (Trading, DeFi, Liquidity and NFTs)
* [EAVE Parachain Design (2021)](https://johnwhitton.com/images/EAVEParachainDesign.pdf): A Dedicated DeFi Polkadot Parachain
* [KANGA Whitepaper(2021)](https://johnwhitton.com/images/KANGAWhitepaper.pdf): a DeFi Trading and Yield Engine]
* [projectX (2018)](https://johnwhitton.com/images/projectX.pdf): layer one blockchain protocol

### Codebases

* [jincubator](https://github.com/jincubator): Solving, Arbitrage and Indexing ([Tycho](https://docs.propellerheads.xyz/tycho/overview)), Intents ([ERC-7683](https://www.erc7683.org/spec),[EIP-712](https://eips.ethereum.org/EIPS/eip-712)), DEX([Uniswap V4 Hooks](https://docs.uniswap.org/contracts/v4/overview)),
* [uhi5-exercises](https://github.com/johnwhitton/uhi5-exercises): Uniswap V4 Hook examples built as part of [UHI5 Atrium Academy](https://atrium.academy/uniswap)
* [eco-routes](https://github.com/eco/eco-routes/tree/ED-4357): Intent Driven Stable Coin Platform (this branch is where I worked on [proving](https://github.com/eco/eco-routes/blob/ED-4357/contracts/Prover.sol)) and designing [cross-chain batch settlement](https://github.com/eco/eco-routes/blob/ED-4357/scripts/testnet/batchSettleGeneral.ts)
* [dot-country](https://github.com/jw-1ns): implementation inspired by [ENS](https://ens.domains/) and enhanced to integrate web2 DNS server and SMTP routing.
* [1wallet](https://github.com/polymorpher/one-wallet/tree/master/code/test): non-custodial crypto wallet
* [NFT Contracts](https://github.com/gamaspacestation/contracts): Smart Contracts for [Gama Space Station](https://opensea.io/collection/gamaspacestation)
* [Cross chain bridge](https://github.com/johnwhitton/horizon/tree/refactorV2/docs): Horizon trustless Bridge (not the one that got hacked)
* [Core Protocol](https://github.com/EaveNetwork): EAVE Network (a polkadot parachain) Rust, Substrate, ORML, TypeScript,Flutter
* [Decentralized Finance](https://github.com/kangafinance): Kanga Finance: Solidity, Javascript, React
* [Solidity Development](https://github.com/johnwhitton/bc_template): Smart Contract Development Framework using hardhat and typescript.
* [API Framework](https://github.com/emasset): emasset: golang, dart, protobuf
* [Layer One Protocol Research](https://github.com/johnwhitton/blockchain-eval/blob/master/substrate.mdx): jincubator: layer one portocol comparison

### Websites and Applications

* [1.country](https://1.country/): Web3 Identity integrated with web 2 DNS services
* [1wallet.crazy.one](https://1wallet.crazy.one/create): Non custodial crypto wallet
* [Decentralized Finance](https://demo.kanga.finance): KANGA App on Harmony Testnet
* [Website](https://kanga.finance): KANGA website
* [Website](https://eave.network): EAVE website

### Presentations and Videos

* [Demo Video](https://demo.jincubator.com): Jincuator: Intent Based Liquidity Management and Settlement Platform
* [Technical Walk Through Video](https://runthrough.jincubator.com): Jincubator: Intent Based Liquidity Management and Settlement Platform
* [Overview Deck](https://deck.jincubator.com): Jincubator: Intent Based Liquidity Management and Settlement Platform
* [Defi Presentation](https://deck.kanga.finance): KANGA Web3 Engine: [Defi Video](https://www.youtube.com/3wxAbe0GzA0): Kanga Demo for Harmony Hackathon
* [Core Protocol Presentation](https://johnwhitton.com/images/EAVEOverview.pdf): EAVE DeFi Polkadot Parachain
* [Defi Presentation](https://johnwhitton.com/images/WASDEXOverview.pd): WASDEX: Digital Exchange
* [Defi Investor Fact Sheet](https://johnwhitton.com/images/wasdex.pdf): WASDEX: Investor Fact Sheet
* [Ecosystem article](https://medium.com/harmony-one/devcon-4ee34426530c): Devcon5 lessons learned
* [Defi Demo Video](https://youtube.kanga.finance): KANGA Demo
* [Defi Demo Vido](https://youtu.be/vk0e6s_2H0w): EAVE Mobile Demo
* [Core Protocol Video](https://youtu.be/HFo6c32qoyI): EAVE Overview
* [Leadership Video](https://youtu.be/easABjC4gIY): Harmony Engineers on fire
* [Defi Investor Video](https://youtu.be/iB1wWl5vWTk): WASDEX: World Asset and Securities Digital Exchange

### Education

Bachelor of Science, The University of Queensland (1984-1987)

### Additional Information

* [Gitcoin](https://gitcoin.co/johnwhitton): John on Gitcoin
* [Hackathons](https://gitcoin.co/johnwhitton/hackathons): Kanga Harmony Hackathon Proposals
  * [Awards](https://docs.google.com/presentation/d/1ZGrbKSaAdtzvMzVh0EVFBfUvA4SqiAeYVXGhJN7Orbs/edit?usp=sharing): Kanga winning multiple awards in Harmony Hackathon
* [Proposal](https://talk.harmony.one/t/kanga-launch-proposal/8283): Kanga Launch Proposal

<object data="/images/john.pdf" width="1000" height="1000" type="application/pdf" />


## Project-X Technical White Paper

Blockchain ledger platform with a focus on interoperability, speed and privacy

* date: 2018-07-17
* author: John Whitton

<object data="/posts/2018-07-17-projectx/projectX.pdf" width="1000" height="1000" type="application/pdf" />


## Lessons Learned from Devcon5

Devcon5 key take aways on emerging blockchain technologies, new initatives and what the community is looking for.

* date: 2019-10-16
* author: John Whitton

### Introduction

Having just returned from Devcon5 I’d like to take a moment to thank Tokyo and Osaka specifically for the warmth and hospitality shown. Secondly I’d like to congratulate the Ethereum community for its vibrant and inclusive culture. The community continues to get stronger every year and the level of research and innovation is amazing.

So with that being said, I thought I’d also share some of the lessons that the Harmony team learned and also some focus areas for us as we move forward. In the form of a few slides.

<span class="image main">
  <img src="/posts/2019-10-16-devcon5/1_meet.webp" alt="" />
</span>

The highlight as you can see below is engaging and learning from the quality researchers and partners at the conference.

<span class="image main">
  <img src="/posts/2019-10-16-devcon5/2_highlight.webp" alt="" />
</span>

The following 5 areas we found of most interest to help us better serve our developer and user community.

<span class="image main">
  <img src="/posts/2019-10-16-devcon5/3_lessons.webp" alt="" />
</span>

1. As a layer one solution scaling is of keen interest to us and it was exciting to see the amount of work done on Layer II solutions.

<span class="image main">
  <img src="/posts/2019-10-16-devcon5/4_layer2.webp" alt="" />
</span>

2. The overwhelming message from the community is that wallets need to be simplified to drive Main stream adoption.

<span class="image main">
  <img src="/posts/2019-10-16-devcon5/5_wallets.webp" alt="" />
</span>

3. Bridging decentralized finance and traditional finance continues to be sought after.

<span class="image main">
  <img src="/posts/2019-10-16-devcon5/6_tokens.webp" alt="" />
</span>

4. Currently blockchains are still limited by scalability and settlement time issues.

<span class="image main">
  <img src="/posts/2019-10-16-devcon5/7_settlement.webp" alt="" />
</span>

5. Sharding is one of the key approaches for scalability. It was refreshing to see some of the innovative methods people are using for this.

<span class="image main">
  <img src="/posts/2019-10-16-devcon5/8_sharding.webp" alt="" />
</span>

I hope you found this helpful and if you’d like to find out more about Harmony please use the following links to [Join our community](https://open.harmony.one/) , [read our docs](https://docs.harmony.one/home/) and [contribute to our protocol](https://github.com/harmony-one).

**Thanks for your interest in Harmony.**

<span class="image main">
  <img src="/posts/2019-10-16-devcon5/9_harmony.webp" alt="" />
</span>


## EAVE Parachain Design

Emerging Asset Value Engine (EAVE) Polkadot Parachain

* date: 2021-04-01
* author: John Whitton

<object data="/posts/2021-04-01-eave-parachain/EaveParachainDesign.pdf" width="1000" height="1000" type="application/pdf" />


## Kanga Protocol Whitepaper

Kernel Agnositic Next Generation Assets (KANGA): A Decentralized Finance Protocol

* date: 2021-05-01
* author: John Whitton

<object data="/posts/2021-05-01-kanga/KANGAWhitepaper.pdf" width="1000" height="1000" type="application/pdf" />


## Draft EAVE Whitepaper

EAVE: a multi-chain web3 engine to support the growing adoption of emerging assets on blockchain

* date: 2021-12-01
* author: John Whitton

<object data="/posts/2021-12-01-eave-defi/DraftEAVEWhitepaper.pdf" width="1000" height="1000" type="application/pdf" />


## Ethereum Bridging using Light Clients - Rainbow Costing

A review of how Bridging costs can be reduced using light clients. Taking the near Rainbow Bridge as an example.

* date: 2022-02-23
* author: John Whitton
* contributors: Thanks to Aaron Li for their helpful suggestions.

## Ethereum Bridging using Light Clients - Rainbow Costing

A review of how Bridging costs can be reduced using light clients. Taking the near Rainbow Bridge as an example

* date: 2022-02-23
* author: John Whitton
* contributors: Thanks to Aaron Li for their helpful suggestions.

### Table of Contents

* [Ethereum Bridging using Light Clients - Rainbow Costing](#ethereum-bridging-using-light-clients---rainbow-costing)
* [Ethereum Bridging using Light Clients - Rainbow Costing](#ethereum-bridging-using-light-clients---rainbow-costing-1)
  * [Table of Contents](#table-of-contents)
  * [Introduction](#introduction)
  * [Bridge Transaction Walk Through](#bridge-transaction-walk-through)
    * [Actors](#actors)
    * [Sample TransactionFlow](#sample-transactionflow)
  * [Bridging Resources Required](#bridging-resources-required)
    * [References](#references)

### Introduction

In this article we review the use of light clients and how they can improve trust and costing for bridges.

### Bridge Transaction Walk Through

Following is a walkthough of a funds transfer from Ethereum to a target chain (In this example Near), complete with light client updates, block propogation and proofs to ensure the transaction validity.

![Ethereum to Near Funds Transfer](/posts/2023-03-23-rainbow-costs/eth2NearFundsTransfer.jpg "Ethereum to NEAR Funds Transfer")

#### Actors

From the diagram above you'll notice that there are many actors involved, below is an overview of the actors and the operations they perform.

* Accounts
  * [User Account](https://etherscan.io/address/0x29da2ef94deeaf2d2f9003e9354abfcb1ff04b32) : The user is the owner of the funds being transferred and is responsible for signing the transactions to authorize bridging them accross chains. In this example they have accounts on [Ethereum](https://etherscan.io/address/0x29da2ef94deeaf2d2f9003e9354abfcb1ff04b32) and [NEAR](https://nearblocks.io/address/johnrubini.near#tokentxns)
  * [Target Chain Relayer Acccount](https://nearblocks.io/address/relayer.bridge.near): The relayer account is responsible for relaying messages from Ethereum to the target chain. \*Note this is connected to a relayer which is responsible for tasks such as querying latest block headers and getting light client status updates. Source code is [here](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/eth2near-block-relay-rs).
  * [Target Chain Bridge Validator Accounts](https://nearblocks.io/address/bridge-validator1.near): are responsible for validating light client update proposals and sending approval votes to [DAO Eth Client Contract](https://nearblocks.io/address/bridge-validator.sputnik-dao.near).
* Ethereum Components
  * [ERC20 Token Contract](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code): this is the token contract securing the funds in this examle USDT (Tether). Source code is [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.8/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol)
  * [Bridge Contract](https://etherscan.io/address/0x23ddd3e3692d1861ed57ede224608875809e127f#code): Responsible for deposits and withdrawals of tokens on Ethereum as well as various proving and propogation mechanisms such as checking of Signatures and adding Light Client Blocks. Source code is [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/NearBridge.sol)
* Target Chain (NEAR) Components
  * [Validator DAO Contract](https://nearblocks.io/address/bridge-validator.sputnik-dao.near): Responsible for receivng light client update proposals from the relayer and gathering approval votes for these propoals from Validators and submitting light client updates once the proposal is approved by the Validators. Source code is [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/contract_wrapper/src/dao_eth_client_contract.rs)
  * [Etherum 2 Client](https://nearblocks.io/address/client-eth2.bridge.near): The Ethereum 2 client is responsbile for processing light client updates and receiving execution header blocks from Ethereum via the relayer. Source code is [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs). *Note: this replaced the [Ethereum 1 client](https://nearblocks.io/address/client.bridge.near) source code [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth-client/src/lib.rs)*
  * [Ethereum Prover](https://nearblocks.io/address/prover.bridge.near) : The Ethereum Prover is used to prove transactions are included in a valid block Header. Source code is [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth-prover/src/lib.rs)
  * [Bridge Contract](https://nearblocks.io/address/factory.bridge.near#contract): The Bridge contract is responsible for managing tokens including creating new tokens, setting metadata and depositing and withdrawal of tokens. Source code is [here](https://github.com/aurora-is-near/rainbow-token-connector/blob/master/bridge-token-factory/src/lib.rs).
    * [NEAR Token Contract](https://nearblocks.io/token/dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near?a=dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near): The target chain representation of the token (USDT) managed by the target chain bridge contract.

#### Sample TransactionFlow

1. Block Propogation
   1. Get the Latest Slot: The relayer loops polling Ethereum every 12 seconds to get the latest slot. It then checks if it is for a new epoch and if so (every 6 minutes) submits an execution header (with 32 blocks in it) and a light client update with the latest approved epochs and updated sync\_comittee. Relayer source code for the loop is [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L258) for retrieving the latest slot is [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L163), for submitting execution blocks is [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L399) and for sending light client updates is [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L489).
      1. [Send Block Headers (submit\_execution\_header)](https://nearblocks.io/txns/HaXUxCvA1D87QXJzPzSYXmFYNuSLbTmyuxShzWgSLvPM): Batch transaction which submits 32 block headers to [client-eth2.bridge.near](https://nearblocks.io/address/client-eth2.bridge.near) for Ethereum Blocks 16493592 to 16493623. (The second slot in epoch [176,936](https://beaconcha.in/epoch/176936) to the first slot in epoch [176,937](https://beaconcha.in/epoch/176937)). **Executed every 6 minutes when the first slot of a new epoch is found.**
      2. [Create Light Client update proposal(add\_proposal)](https://nearblocks.io/txns/J1tQ465Dxt4UhWy9Msn2pZCbdkWatSepqsx9sDZaX35z#): calls [bridge-validator.sputnik-dao.near](https://nearblocks.io/address/bridge-validator.sputnik-dao.near) to add proposal 17410 for [slot 5,661,984](https://beaconcha.in/slot/5661984) in epoch [176,937](https://beaconcha.in/epoch/176937).
   2. [Approve Proposal (act\_proposal)](https://nearblocks.io/txns/D5uP4BbRSUX4ZGijRfWGkR5KbFb2Kb9q1gSsFVQbYSLt): sends a VoteApprove action for proposal 17410 from a [bridge validator](https://nearblocks.io/address/bridge-validator1.near) to the [Validator DAO Contract](https://nearblocks.io/address/bridge-validator.sputnik-dao.near).
      1. act\_proposal in contract [bridge-validator.sputnik-dao.near](https://nearblocks.io/address/bridge-validator.sputnik-dao.near)
      2. submit\_beacon\_chain\_light\_client\_update in [client-eth2.bridge.near](https://nearblocks.io/address/client-eth2.bridge.near)
      3. on\_proposal\_callback in contract [bridge-validator.sputnik-dao.near](https://nearblocks.io/address/bridge-validator.sputnik-dao.near)
2. Funds Transfer Transaction Flow
   1. [Lock Funds On Ethereum](https://etherscan.io/tx/0xa685c59a24cc2056e10e660ce8a8bff7bbc335433698e138c77aaadf20ecb614): Locking 10,000 USDT to send to user on NEAR.
   2. [Deposit Funds on Target Chain Bridge Contract (deposit)](https://nearblocks.io/txns/vniyRR67ndrtvpoQ9c5ACoT4e9c283VSQsrZcN6GGto#execution)
      1. deposit in contract factory.bridge.near
      2. verify\_log\_entry in contract prover.bridge.near
      3. block\_hash\_safe in contract client-eth2.bridge.near
      4. finish\_deposit in contract factory.bridge.near : mint of 10,000 USDT.

**TODO**

* Find and review the source code for the [validator light client approval update](https://nearblocks.io/txns/HnzBR7x5Sxnmcm4MfRt1ghhMjJNspDaygUUKeM9T27Li#execution). *Note: the eth2\_client has a [validate\_light\_client\_update](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs#L311) which is [configurable](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs#L42) and is used for debugging purposes.*

### Bridging Resources Required

Here is the storage and compuational costs per component.

| Component                                                                                                                   | Data           | Storage | Notes |
| --------------------------------------------------------------------------------------------------------------------------- | -------------- | ------- | ----- |
| [Ethereum 2 Client](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs#L35) | ---            | ---     | ---   |
| [Prover](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth-prover/src/lib.rs)                 | not applicable | 0 bytes |       |
| [DAO Contract](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/contract_wrapper/src/dao_contract.rs)  |                |         |       |

**TODO**
Review the following data structure and elements and move into the table above commenting on any mandatory requirements and structures that can be improved.

```go
pub struct Eth2Client {
    /// If set, only light client updates by the trusted signer will be accepted
    trusted_signer: Option<AccountId>,
    /// Mask determining all paused functions
    paused: Mask,
    /// Whether the client validates the updates.
    /// Should only be set to `false` for debugging, testing, and diagnostic purposes
    validate_updates: bool,
    /// Whether the client verifies BLS signatures.
    verify_bls_signatures: bool,
    /// We store the hashes of the blocks for the past `hashes_gc_threshold` headers.
    /// Events that happen past this threshold cannot be verified by the client.
    /// It is desirable that this number is larger than 7 days' worth of headers, which is roughly
    /// 51k Ethereum blocks. So this number should be 51k in production.
    hashes_gc_threshold: u64,
    /// Network. e.g. mainnet, kiln
    network: Network,
    /// Hashes of the finalized execution blocks mapped to their numbers. Stores up to `hashes_gc_threshold` entries.
    /// Execution block number -> execution block hash
    finalized_execution_blocks: LookupMap<u64, H256>,
    /// All unfinalized execution blocks' headers hashes mapped to their `HeaderInfo`.
    /// Execution block hash -> ExecutionHeaderInfo object
    unfinalized_headers: UnorderedMap<H256, ExecutionHeaderInfo>,
    /// `AccountId`s mapped to their number of submitted headers.
    /// Submitter account -> Num of submitted headers
    submitters: LookupMap<AccountId, u32>,
    /// Max number of unfinalized blocks allowed to be stored by one submitter account
    /// This value should be at least 32 blocks (1 epoch), but the recommended value is 1024 (32 epochs)
    max_submitted_blocks_by_account: u32,
    // The minimum balance that should be attached to register a new submitter account
    min_storage_balance_for_submitter: Balance,
    /// Light client state
    finalized_beacon_header: ExtendedBeaconBlockHeader,
    finalized_execution_header: LazyOption<ExecutionHeaderInfo>,
    current_sync_committee: LazyOption<SyncCommittee>,
    next_sync_committee: LazyOption<SyncCommittee>,
}
```

#### References

**Explorer and Interactive Links**

* Near

  * eth-prover
    * [https://nearblocks.io/address/relayer.bridge.near](https://nearblocks.io/address/relayer.bridge.near)
    * [https://nearblocks.io/address/client-eth2.bridge.near](https://nearblocks.io/address/client-eth2.bridge.near)
    * [https://nearblocks.io/address/client.bridge.near](https://nearblocks.io/address/client.bridge.near)
  * eth-client
    * [https://nearblocks.io/address/prover.bridge.near](https://nearblocks.io/address/prover.bridge.near)
    * [https://nearblocks.io/address/client.bridge.near](https://nearblocks.io/address/client.bridge.near)
  * factory (manages tokens)
    * [https://nearblocks.io/address/factory.bridge.near](https://nearblocks.io/address/factory.bridge.near)
  * dao
    * [https://nearblocks.io/address/bridge-validator.sputnik-dao.near](https://nearblocks.io/address/bridge-validator.sputnik-dao.near)
  * aurora
    * [https://nearblocks.io/address/aurora](https://nearblocks.io/address/aurora)
    * [https://nearblocks.io/address/relay.aurora](https://nearblocks.io/address/relay.aurora)

* Ethereum
  * [beaconcha.in](https://beaconcha.in/)
    * [validators](https://beaconcha.in/validators)
    * [epochs](https://beaconcha.in/epochs)
    * [slots](https://beaconcha.in/slots)
    * [blocks](https://beaconcha.in/blocks)
    * [transactions](https://beaconcha.in/transactions)
  * Near Bridge
    * [NearBridge](https://etherscan.io/address/0x3fefc5a4b1c02f21cbc8d3613643ba0635b9a873)
    * [ERC20Locker](https://etherscan.io/tx/0xa685c59a24cc2056e10e660ce8a8bff7bbc335433698e138c77aaadf20ecb614)


<div align="center">
  <h1 align="center">John Whitton Writing</h1>

  <p align="center">
    Papers and articles on Layer 1 Protocols, Bridging, Decentralized Finance,
    Ecosystem Growth
  </p>
</div>

The articles on this site, relates to the research I have done previously in designing Layer 1 platforms and Defi Protocols. For recent research on bridging, zero knowledge and chain consensus and signing see [research](/research/intro.mdx).


<div align="center">
  <h1 align="center">John Whitton Research</h1>

  <p align="center">
    Research on Proving Mechanisms, Dedicated Rollups, Bridging, Zero Knowledge,
    Consensus, DeFi and NFT's
  </p>
</div>

This knowledge base and learning center is based upon research I have done around bridging, zero knowledge and chain consensus and signing up until 2023.

For more recent work I have been doing please see

* [jincubator](https://github.com/jincubator) for my work on Solving, Arbitrage and Indexing using [Tycho](https://docs.propellerheads.xyz/tycho/overview), Intents using [ERC-7683](https://www.erc7683.org/spec), [EIP-712](https://eips.ethereum.org/EIPS/eip-712), [Compactx](https://github.com/uniswap/compactx) and [Uniswap V4 Hooks](https://docs.uniswap.org/contracts/v4/overview).
* [uhi5-exercises](https://github.com/johnwhitton/uhi5-exercises) for Uniswap V4 Hook examples built as part of [UHI5 Atrium Academy](https://atrium.academy/uniswap).
* [eco-routes](https://github.com/eco/eco-routes/tree/ED-4357) for earlier work on cross-chain intents done at [ECO](https://eco.com/docs/what-is-eco) including [eco-routes](https://github.com/eco/eco-routes/tree/ED-4357) and this branch is where I worked on [proving](https://github.com/eco/eco-routes/blob/ED-4357/contracts/Prover.sol) and designing [cross-chain batch settlement](https://github.com/eco/eco-routes/blob/ED-4357/scripts/testnet/batchSettleGeneral.ts)

**Specifically I'd like to thank**

* [Propellor Heads](https://www.propellerheads.xyz/): For their outstanding work on indexing, simulation and execution for Solvers as part of [Tycho](https://docs.propellerheads.xyz/tycho/overview) which lays the foundation for the jincubator platform.
* [Uniswap](https://docs.uniswap.org/contracts/v4/overview): For their leading work on [Uniswap V4 Hook Architecture](https://docs.uniswap.org/contracts/v4/concepts/hooks) and their inspirational design of [CompactX](https://github.com/uniswap/compactx) including resource locking via [the-compact](https://github.com/uniswap/the-compact) and attestations via [EIP-712](https://eips.ethereum.org/EIPS/eip-712) signing implemented in [Tribunal](https://github.com/uniswap/tribunal).
* [Atrium Academy](https://atrium.academy/uniswap): For their Uniswap V4 Hook Incubator and the mentors Haardik and Saucepoint.
* [eco](https://eco.com): Where I was fortunate enough to lead the engineering team and work on hard problems around Cross L2 Transactions and designing and bulding a dedicated rollup.
* [Aaron Li](https://www.linkedin.com/in/aaronqli/): who has mentored and driven much of the research around cryptographic primitives, wallets, gaming and trustless bridging.
* [The Delendum Team](https://delendum.xyz/team): who are leading many zero knowledge research initiatives.
* [Ganesha Upadhyaya](https://www.linkedin.com/in/gupadhyaya/): For his leading work on the horizon bridge and other trustless bridging research.
* [Rongjian Lan](https://www.linkedin.com/in/rongjianlan/): For his work on core protocol, specifically Harmony and the knowledge which he generously shared.

*Please note: Research is ongoing and as such some items are placeholders or work in progress*


#### [Andy](https://www.linkedin.com/in/andy-wu-4329664/)

John is one of the most professional engineers I’ve ever worked with. He takes the ownership of many OPS works,
and documents them down with meticulous details. Also, he is a fast learner, and eager to pick up new skills. He also has very good project management skills, and I believe he could be a very good leader either in biz or eng departments.


#### [Ganesha](https://www.linkedin.com/in/gupadhyaya/)

John is dedicated, hard-working, great work ethics, and brings lot of positive energy. no doubt that he is a great manager with good people skills. john led the whole hiring process and single handedly managed it well, without much chaos. no joke how much time and energy it takes. great job. while i believe it was not the best use of john's time, he embraced whatever this staking launch demanded from him. great work towards managing the release (deployment, documentation, etc) and taking some load of andy and daniel. after the staking release, john could refocus and quickly get back to speed on the ecosystem/tooling/partner tasks/goals for q4 and expedite some of the deliverables.


## John's Colleagues

<span class="image main">
  <img src="/images/pic03.jpg" alt="" />
</span>

I have been fortunate over my long career to have the opportunity to work with some of the most talented individuals and teams not only in Silicon Valley, but globally.

In my role as a founder, cto, ecoystem architect and engineer. I have learned from great leaders,
researchers, business strategists and engineers. I have built great teams and mentored many talented junior engineers. I have watched my teams apply their solid technical foundation to become invaluable contributors to the team and the organization. Watching individuals grow both personally and professionally is the most rewarding work I have done.

Here is a video highlighting the strengths of the Harmony Team that I was fortunate enough to work with.

{" "}

<div className="video-responsive">
  <iframe width="560" height="315" src="https://www.youtube.com/embed/easABjC4gIY" frameBorder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowFullScreen />
</div>

<a href="/images/johnImpact.png" target="_blank" rel="noopener noreferrer" style={{ color: "blue", textDecoration: "underline" }}>
  Here are some quotes from some of the greatest people you'll ever get to work
  with
</a>


#### [Janet](https://www.linkedin.com/in/janet-liang-754090135/)

John is always willing to work on whatever the team needs even though you don't necessarily want to.
thank you for listening and being a great mentor.


#### [Li](https://www.linkedin.com/in/lijiang2087/)

I want to thank John for having a detailed process and documentation of the OSTN network upgrades and resets and communicating to me and community.


#### [Matt](https://www.linkedin.com/in/mattlockyer/)

John is amazing at explaining and delegating. I’m always impressed with his knowledge base. I think more efforts could be made to capture his knowledge in “explainers”, that would go a long way to supporting the community. John can also run anything, like up and running in a matter of minutes. This means he can troubleshoot tons of deployment issues from the core protocol all the way up to the application layer


#### [Nick](https://www.linkedin.com/in/nickwh8te/)

John is always willing to jump on whatever needs to get done. he jumped SDK to hiring and then back into network ops. I think that John does a good job of recruiting and onboarding new interns and giving them appropriate difficulty tasks as they ramp up. I'm grateful that he stepped in to cover miami devcon for me at the last minute. team player


#### [Olivier](https://www.linkedin.com/in/olivierveyrac/)

John and I worked together at Autodesk during the implementation of the subscription program, John was a lead SAP developer working on the program. I frequently interacted with him as we rolled out the program. John has the rare gift of being able to understand complex business problems and map them to a technical solution. His drive and passion for the project, combined with his excellent communication skills and deep technical knowledge, were key factors in the successful rollout of the program. We've since become close friends. I'd recommend anyone looking for a technical lead with business acumen to consider John.


#### [Yishuang](https://www.linkedin.com/in/chenyishuang/)

John is a really good team player, among his good qualities, I admire three most.

1. Helpful and warm-hearted whenever you ask for help, John will give you the best help.
2. Avid learner, John likes to learn new things and will actively take new tasks. I see John actively in ops recently.
3. Responsible, longer view, John focused a lot on knowledge transfer. He wants to make sure the knowledge can be shared with the whole team and future new employees, so he contributed a lot on internal wiki gitbooks, which I think it’s a good point.


## Cosmos IBC

* date: 2023-02-24
* last updated: 2023-04-04

### Overview

Cosmos is a network of the many blockchains built on IBC protocol. The IBC protocol is a universal interoperability protocol that allows two different blockchains to communicate with one another. IBC guarantees reliable, ordered, and authenticated communication. See [Cosmos Network Whitepaper](https://v1.cosmos.network/resources/whitepaper)

Blockchains based on IBC protocol may use validity based proofs for interchain communication. See [IBC Protocol ELI5: What is IBC?](https://medium.com/the-interchain-foundation/eli5-what-is-ibc-def44d7b5b4c)

#### Protocol

* [Design](https://github.com/cosmos/ibc): the primary repository for development and documentation
* [Docs](https://tutorials.cosmos.network/academy/3-ibc/): a quick introduction. See also [ibc-go documentation](https://ibc.cosmos.network/)
* [Implementation](https://github.com/cosmos/ibc-go): Implementation in Golang, built as a Cosmos SDK module.
* [Roadmap](https://ibc.cosmos.network/main/roadmap/roadmap.html)

#### Bridging

* [Relayer](https://github.com/cosmos/relayer): "...blockchains do not directly pass messages to each other over the network. This is where relayer comes in. A relayer process monitors for updates on opens paths between sets of IBC enabled chains..."
* [Light Clients](https://ibc.cosmos.network/main/ibc/light-clients/overview.html): "...Light clients operate under a strict set of rules which provide security guarantees for state updates and facilitate the ability to verify the state of a remote blockchain using merkle proofs"

#### Utilities

* [Explorer](https://hub.mintscan.io/chains/ibc-network): Monitoring interchain activities and messaging in 3D
* [Keplr](https://www.keplr.app/): Wallet designed to work across blockchains on IBC (see [Getting Started with Cosmos IBC Transfers](https://catdotfish.medium.com/getting-started-with-ibc-transfers-276e9ce91e17))

(to be continued)

\*============ Content below requires significant revision ==========

### Code Review

Following is a review of [ibc-go](https://github.com/cosmos/ibc-go)

#### Signing Mechanisms from [cosmos-sdk](https://github.com/cosmos/cosmos-sdk)

* [bcrypt](https://www.usenix.org/legacy/event/usenix99/provos/provos.pdf)
  * [cosmos-sdk bcrypt](https://github.com/cosmos/cosmos-sdk/tree/main/crypto/keys/bcrypt)

* [ed25519](https://ed25519.cr.yp.to/ed25519-20110926.pdf)
  * [cosmos-sdk ed25519](https://github.com/cosmos/cosmos-sdk/tree/main/crypto/keys/ed25519)

* [ecdsa](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)
  * [cosmos-sdk ecdsa](https://github.com/cosmos/cosmos-sdk/tree/main/crypto/keys/internal/ecdsa)

* [secp256k1](https://www.secg.org/sec2-v2.pdf)
  * [cosmos-sdk secp256k1](https://github.com/cosmos/cosmos-sdk/tree/main/crypto/keys/secp256k1)
  * [secp256r1](https://www.secg.org/sec2-v2.pdf)
    * [cosmos-sdk secp256r1](https://github.com/cosmos/cosmos-sdk/tree/main/crypto/keys/secp256r1)

* [merkle.go](https://github.com/cosmos/ibc-go/blob/main/modules/core/23-commitment/types/merkle.go)

#### Proving Mechanisms

#### Relayer Mechanisms

* [e2e relayer.go](https://github.com/cosmos/ibc-go/blob/main/e2e/relayer/relayer.go) uses [strangelove-ventures interchaintest relayer](https://github.com/strangelove-ventures/interchaintest/tree/main/relayer)
  * [cosmos-relayer.go](https://github.com/strangelove-ventures/interchaintest/blob/main/relayer/rly/cosmos_relayer.go)

#### Light Client Functionality

* [light-clients](https://github.com/cosmos/ibc-go/tree/main/modules/light-clients)

#### Token Lockers

### References

### Appendices


## Harmony Horizon

* date: 2023-02-24
* last updated: 2023-02-24

### Overview

This document reviews the [horizon](https://github.com/johnwhitton/horizon/tree/refactorV2) current implementation, development tasks that need to be done to support POW and offers some thoughts on next steps to support Ethereum 2.0 and other chains.

Further thoughs on ETH 2.0 support, removing the ETHHASH logic and SPV client and potentially replacing with MMR trees per epoch and checkpoints similar to Harmony Light Client on Ethereum, can find inspiration in [near-rainbow](./near-rainbow.mdx).

### Approach

Horizon 2.0 approach is to use validity proofs implemented by on-chain smart contracts.

### Proving Mechanisms

#### Ethereum Light Client

1. ETH 2.0 support see [here](/research/chains/ethereum.mdx)
2. Queuing mechanism should be implemented to queue bridge transactions. The queue can be polled as part of the block relay functionality to process bridge transactions once the blocks have been relayed.
3. Consider whether we can use p2p messaging to receive published blocks rather than looping and polling via an RPC.

#### Harmony Light Client

1. Needs to implement a process to `submitCheckpoint`.
2. `eprove` logic needs to be reviewed
3. Queuing mechanism should be implemented to queue bridge transactions. The queue can be polled as part of the `submitCheckpoint` functionality to process bridge transactions once the blocks have been relayed.
4. Need to facilitate the core protocol [MMR enhancements PR](https://github.com/harmony-one/harmony/pull/4198/files)

### Relayer Mechanisms

Sequencing of Transactions: Needs to be implemented and `TokenMap` in `bridge.js` needs to be refactored. Below is the current sequence flow and areas for improvements.

1. Ethereum Mapping Request
2. Relay of Block to EthereumLightClient.sol on Harmony
   * The block has to be relayed before we can process the Harmony Mapping request, as we have just executed the transaction the relayer usually has not relayed the block so this will fail.
   * There must be an additional 25 blocks on Ethereum before this block can be considered part of the canonical chain.
   * This logic needs to be rewritten to break down execution for 1. the ethereum mapping request 2. After a 25 block delay the Harmony Proof validation and executing the Harmony Mapping Request\*\*
3. Harmony Mapping Request
4. Relay of Checkpoint to HarmonyLightClient.sol on Ethereum
   * A `submitCheckpoint` in `HarmonyLightClient.sol` needs to have called either for the next epoch or for a checkpoint, after the block the harmony mapping transaction was in.\*\*
   * Automatic submission of checkpoints to the Harmony Light Client has not been developed as yet. (It is not part of the `ethRelay.js`). And so the checkpoint would need to be manually submitted before the Ethereum Mapping could take place.
5. Etherem Process Harmony Mapping Acknowledgement

### Light Client Functionality

#### Ethereum Light Client

1. ETH 2.0 support see [here](/research/chains/ethereum.mdx)
2. Queuing mechanism should be implemented to queue bridge transactions. The queue can be polled as part of the block relay functionality to process bridge transactions once the blocks have been relayed.
3. Consider whether we can use p2p messaging to receive published blocks rather than looping and polling via an RPC.

#### Harmony Light Client

1. Needs to implement a process to `submitCheckpoint`.
2. `eprove` logic needs to be reviewed
3. Queuing mechanism should be implemented to queue bridge transactions. The queue can be polled as part of the `submitCheckpoint` functionality to process bridge transactions once the blocks have been relayed.
4. Need to facilitate the core protocol [MMR enhancements PR](https://github.com/harmony-one/harmony/pull/4198/files)

### Token Lockers

*Note: The key difference between `TokenLockerOnEthereum.sol` and `TokenLockerOnHarmony.sol` is the proof validation. `TokenLockerOnEthereum.sol` uses `./lib/MMRVerifier.sol` to validate the [Mountain Merkle Ranges](https://github.com/opentimestamps/opentimestamps-server/blob/master/doc/merkle-mountain-range.mdx) on Harmony and `HarmonyProver.sol`. `TokenLockerOnHarmony.sol` imports `./lib/MPTValidatorV2.sol` to validate [Merkle Patrica Trie](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/#merkle-patricia-trees) and `./EthereumLightClient.sol`.*

#### MultiChain Support

1. Need to support other chains
   * EVM: BSC, Polygon, Avalanche, Arbitrum, Optimism
   * Bitcoin
   * NEAR
   * Solana
   * Polkadot

### Code Review

The code reviewed is from a fork of [harmony-one/horizon](https://github.com/harmony-one/horizon). The fork is [johnwhitton/horizon branch refactorV2](https://github.com/johnwhitton/horizon/tree/refactorV2). This is part of the horizon v2 initiative to bride a trustless bridge after the initial horizon hack. The code is incomplete and the original codebase did not support ethereum 2.0 (only ethereum 1.0). Nevertheless there are a number of useful components developed which can be leveraged in building a trustless bridge.

### On-chain (Solidity) Code Review

*Note: here we document functionality developed in solidity. We recommend reading the [Open Zeppelin Contract Documentation](https://docs.openzeppelin.com/contracts/4.x/) specifically the [utilities](https://docs.openzeppelin.com/contracts/4.x/utilities) have a number of utitlies we leverage around signing and proving. We tend to utilize the [openzeppelin-contracts-upgradeabe repository](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable) when building over the documented [openzeppelin-contracts repository](https://github.com/OpenZeppelin/openzeppelin-contracts) as we are often working with contracts which we wish to upgrade, there should be equivalent contracts in both repositories.*

#### OpenZeppelin Utilities

* [Utilities](https://docs.openzeppelin.com/contracts/4.x/api/utils): Miscellaneous contracts and libraries containing utility functions you can use to improve security, work with new data types, or safely use low-level primitives.
  * [Math](https://docs.openzeppelin.com/contracts/4.x/api/utils#math): Standard math utilities missing in the Solidity language.
  * [Cryptography](https://docs.openzeppelin.com/contracts/4.x/api/utils#cryptography)
    * [ECDSA](https://docs.openzeppelin.com/contracts/4.x/api/utils#ECDSA): Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
    * [SignatureChecker](https://docs.openzeppelin.com/contracts/4.x/api/utils#SignatureChecker): Signature verification helper that can be used instead of ECDSA.recover to seamlessly support both ECDSA signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like Argent and Gnosis Safe.
    * [MerkleProof](https://docs.openzeppelin.com/contracts/4.x/api/utils#MerkleProof): These functions deal with verification of Merkle Tree proofs.
    * [EIP712](https://docs.openzeppelin.com/contracts/4.x/api/utils#EIP712): [EIP 712](https://eips.ethereum.org/EIPS/eip-712) is a standard for hashing and signing of typed structured data.
  * [Escrow](https://docs.openzeppelin.com/contracts/4.x/api/utils#escrow): Base escrow contract, holds funds designated for a payee until they withdraw them.
  * [Introspection](https://docs.openzeppelin.com/contracts/4.x/api/utils#introspection): This set of interfaces and contracts deal with [type introspection](https://en.wikipedia.org/wiki/Type_introspection) of contracts, that is, examining which functions can be called on them. This is usually referred to as a contract’s *interface*.
  * [Data Structures](https://docs.openzeppelin.com/contracts/4.x/api/utils#data_structures)
    * [BitMaps](https://docs.openzeppelin.com/contracts/4.x/api/utils#BitMaps): Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential. Largely inspired by Uniswap’s [merkle-distributor](https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol).
    * [EnumerableMap](https://docs.openzeppelin.com/contracts/4.x/api/utils#EnumerableMap): Library for managing an enumerable variant of Solidity’s [mapping](https://solidity.readthedocs.io/en/latest/types.html#mapping-types) type.
    * [EnumerableSet](https://docs.openzeppelin.com/contracts/4.x/api/utils#EnumerableSet): Library for managing [sets](https://en.wikipedia.org/wiki/Set_\(abstract_data_type\)) of primitive types.
    * [DoubleEndedQueue](https://docs.openzeppelin.com/contracts/4.x/api/utils#DoubleEndedQueue): A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of the sequence (called front and back).
    * [Checkpoints](https://docs.openzeppelin.com/contracts/4.x/api/utils#Checkpoints): This library defines the `History` struct, for checkpointing values as they change at different points in time, and later looking up past values by block number. See [Votes](https://docs.openzeppelin.com/contracts/4.x/api/governance#Votes) as an example.
  * [Libraries](https://docs.openzeppelin.com/contracts/4.x/api/governance#Votes)
    * [Create2](https://docs.openzeppelin.com/contracts/4.x/api/utils#Create2): Helper to make usage of the `CREATE2` EVM opcode easier and safer.
    * [Address](https://docs.openzeppelin.com/contracts/4.x/api/utils#Address): Collection of functions related to the address type
    * [Arrays](https://docs.openzeppelin.com/contracts/4.x/api/utils#Arrays): Collection of functions related to array types.
    * [Base64](https://docs.openzeppelin.com/contracts/4.x/api/utils#Base64): Provides a set of functions to operate with Base64 strings.
    * [Counters](https://docs.openzeppelin.com/contracts/4.x/api/utils#Counters): Provides counters that can only be incremented, decremented or reset.
    * [Strings](https://docs.openzeppelin.com/contracts/4.x/api/utils#Strings): String operations.
    * [StorageSlot](https://docs.openzeppelin.com/contracts/4.x/api/utils#StorageSlot): Library for reading and writing primitive types to specific storage slots. Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.
    * [Multicall](https://docs.openzeppelin.com/contracts/4.x/api/utils#Multicall): Provides a function to batch together multiple calls in a single external call.

#### Cryptographic Primitives

* [ethash](https://github.com/johnwhitton/horizon/tree/refactorV2/contracts/ethash): used in proving ethereum 1.0 [ethash](https://github.com/johnwhitton/horizon/tree/refactorV2/contracts/ethash) proof of work.
  * [MerkleRoot.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/ethash/MerkelRoot.sol): provides the ability to getRootHash for a given epoch. Needs to be initialized with a start and end epoch and an initial merkle root.
  * [Prime.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/ethash/Prime.sol): Determins if a number is likely to be prime, based on the [Miller-Rabin primality test](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test)
  * [binary.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/ethash/binary.sol): Binary number manipulation.
  * [ethash.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/ethash/ethash.sol): Provides the ability to verifyHash using a [hashimto function](https://ethereum.org/en/developers/docs/consensus-mechanisms/pow/mining-algorithms/dagger-hashimoto/) and [fnv hashing](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function).
  * [kecakk512.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/ethash/keccak512.sol): Keccak512 hash function supporting [SHA-3](https://en.wikipedia.org/wiki/SHA-3).
* [lib](https://github.com/johnwhitton/horizon/tree/refactorV2/contracts/lib): utility library
  * [ECVerify.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/lib/ECVerify.sol): Verify's a signature and returns the signer address.
  * [EthUtils](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/lib/EthUtils.sol): hexString and byte manipulation
  * [MMR.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/lib/MMR.sol): Merkle Mountain Range solidity library
  * [MMRWrapper.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/lib/MMRWrapper.sol): Merkle Mountain Range wrapper functions.
  * [MPT.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/lib/MPT.sol): Merkle Patricie Tries validation tools (uses RLPReader.sol)
  * [MPTValidatorV2.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/lib/MPTValidatorV2.sol): Merkle Particia Tries validation tools improved by LayerZero
  * [RLPEncode.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/lib/RLPEncode.sol): A simple RLP encoding library.
  * [RLPReader.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/lib/RLPReader.sol): RLP Reader
  * [Safecast.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/lib/SafeCast.sol): Safe casting function for Uints.

#### Proving Mechanisms

**Ethereum 1.0 contracts deployed to Harmony**

* [EthereumLightClient.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/EthereumLightClient.sol): Light Client for Ethereum 1.0, stores a mapping of blocks existing in the Canonical Chain verified using EthHash.
* [EthereumParser.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/EthereumParser.sol): Parse RLP-encoded block header into BlockHeader data structure and transactions with data fields order as defined in the Tx struct.
* [EthereumProver.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/EthereumProver.sol): Computes the hash of the Merkle-Patricia-Trie hash of the input and Validates a Merkle-Patricia-Trie proof. If the proof proves the inclusion of some key-value pair in the trie, the value is returned.

**Harmony contracts deployed to Ethereum 1.0**

*Note these contracts were planned to be implemented with Harmony Light Client support which includes Merkle Mountain Ranges (see this [PR](https://github.com/harmony-one/harmony/pull/3872) and this [review](../chains/harmony#light-client-support)). The planned timeline for implementing this had not been finalized as of Feb 2023.*

* [HarmonyLightClient.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/HarmonyLightClient.sol): Allows submission of checkpoints and manages mappings for `checkPointBlocks` (holding blockHeader information including the Merkle Mountain Range Root field `mmrRoot`).
* [HarmonyParser.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/HarmonyParser.sol): Parse RLP-encoded block header into BlockHeader data structure and transactions with data fields order as defined in the Transaction struct.
* [HarmonyProver.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/HarmonyProver.sol): Verification functions for Blocks, Transaction, Receipts etc. Verification is done by verifying MerkleProofs via `MPTValidator2.sol`.

#### Token Lockers

* [BridgeToken.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/BridgedToken.sol): ERC20 contract used for managing bridged tokens.
* [FaucetToken.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/FaucetToken.sol): ERC20 Token Faucet used for testing on testnets.
* [TokenLocker.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/TokenLocker.sol): Locks Bridged Tokens
* [TokenLockerOnEthereum.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/TokenLockerOnEthereum.sol): Ethereum TokenLocker
* [TokenLockerOnHarmony.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/TokenLockerOnHarmony.sol): Harmony TokenLocker
* [TokenRegistry.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/TokenRegistry.sol): Responsible for mapping tokens between chains and minting new bridged tokens.

### Off-chain (Javascript) Code Review

#### On-chain interaction

* [bridge](https://github.com/johnwhitton/horizon/tree/refactorV2/src/bridge)
  * [bridge.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/bridge/bridge.js): Interacts with provers and tokenLockers on the respective chains to perform the bridging of tokens across chains.
  * [contract.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/bridge/contract.js): Responsible for deploying contracts, mapping tokens between chains and checking token status.
  * [ethBridge.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/bridge/ethBridge.js): extends bridge.js with a constructor for Ethereum
  * [hmyBridge.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/bridge/hmyBridge.js): extens bridge.js with a constructor for Harmony
  * [token.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/bridge/token.js): interacts with ERC20 and FaucetToken (for testing).
  * [index.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/cli/index.js): Command Line Interface commands.

#### Command Line Interface

* [cli](https://github.com/johnwhitton/horizon/tree/refactorV2/src/cli): CLI is a utility that provides a command-line interface to all the components to the Horizon bridge and allow performing end-to-end bridge functionalities.
  * [elsc.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/cli/elc.js): Ethereum Light Client deployed on Harmony. Supports deployment, status checks and querying block information.
  * [ethRelay.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/cli/ethRelay.js): Block Relayer from Ethereum to Harmony
  * [everifier.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/cli/everifier.js): Ethereum Verifier for Harmony. Supports the deployment of the verifier and validating Merkle Patricia Trie proofs from Harmony.
  * [index.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/cli/index.js): Commands for the CLI.

#### Ethereum Light Client

* [elc](https://github.com/johnwhitton/horizon/blob/refactorV2/src/elc/README.mdx): Ethereum Light Client (ELC) is a SPV-based light client implemented as a smart contract that receives and stores Ethereum block header information.
  * [MerkleRoot.json](https://github.com/johnwhitton/horizon/blob/refactorV2/src/elc/MerkelRoot.json): Holds starting epoch and Merkle root information.
  * [MerkleRootSol.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/elc/MerkelRootSol.js): Deploys a MerkleRoot.sol contract on Harmony for the given Ethereum epoch and merkle root information.
  * [client.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/elc/client.js): Interaction with the Client.sol (the Ethereum Light Client deployed on Harmony).
  * [eth2one.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/elc/eth2one-relay.js): Relays blocks from ethereum to Harmony.
  * [proofDump](https://github.com/johnwhitton/horizon/blob/refactorV2/src/elc/proofDump.js): Allows logging of dagProofs for blocks and epochs and writing them to files.

#### Proving Mechanisms

**Ethereum Prover**

* [eprover](https://github.com/johnwhitton/horizon/tree/refactorV2/src/eprover): EProver is a utility that provides verifiable proof about user’s Ethereum tx, e.g., lock tx.
  * [Receipt.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/eprover/Receipt.js): Allows retreival of a receipt from Rpc, buffer or hex and serailiation of receipt.
  * [index.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/eprover/index.js): exports Eprover
  * [txProof.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/eprover/txProof.js): Takes a transaction hash and gets a receipt proof (sha3 hash, recieptRoor, proof and an encoded txIndex).

#### Relayer Mechanisms

**Ethereum to Harmony Relayer**

* [eth2hmy-relay](https://github.com/johnwhitton/horizon/tree/refactorV2/src/eth2hmy-relay): Eth2Hmy relay downloads the Ethereum block headers, extract information and relay it to ELC smart contract on Harmony.
  * [index.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/eth2hmy-relay/index.js): exports `DagProof` and `getBlockByNumber`.
  * [ethash](https://github.com/johnwhitton/horizon/tree/refactorV2/src/eth2hmy-relay/ethash)
    * [index.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/eth2hmy-relay/ethash/dist/index.js): Loads the epoch seed and cache given a block number and uses this to verify Proof of Work for headers and blocks.
    * [util.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/eth2hmy-relay/ethash/dist/util.js): Utilities for epochs including caching, hashing and retreival of seeds and buffers.

#### Cryptographic Primitives

* [eth2hmy-relay/lib](https://github.com/johnwhitton/horizon/tree/refactorV2/src/eth2hmy-relay/lib): Library of functions used by the Ethereum to Harmony Relay
  * [DagPropf.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/eth2hmy-relay/lib/DagProof.js): Checks if a dag exists for an epoch, loads DAG for an epoch and verify header and getProof using the epoch's DAG.
  * [MmapDB.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/eth2hmy-relay/lib/MmapDB.js): Merkle database functionality by extending Memory Map.
  * [getBlockHeader.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/eth2hmy-relay/lib/getBlockHeader.js): Get Block information.
  * [merkel.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/eth2hmy-relay/lib/merkel.js): MerkleTree functionality including construction of MerkleTrees and getting proofs, hex proofs, combined hashes, get Paired Elements and layers.
* [ethashProof](https://github.com/johnwhitton/horizon/tree/refactorV2/src/ethashProof): ethash proving mechanisms
  * [BlockProof.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/ethashProof/BlockProof.js): Exports getHeaderProof, parseRlpHeader, getBlockByNumber
  * [DagMTreeEpoch.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/ethashProof/DagMtreeEpoch.js): Exports generateDagMTree, genearateDagMTreeRange
  * [MerkelRootSol.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/ethashProof/MerkelRootSol.js): Creates a MerkleRoot.sol contract for an inputted merkleInfo.
* [lib](https://github.com/johnwhitton/horizon/tree/refactorV2/src/lib)
  * [configure.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/lib/configure.js): Configure TokenLocker and Faucet contracts.
  * [ethEthers.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/lib/ethEthers.js): Shim over [ethers](https://www.npmjs.com/package/ethers) allowing the instantiation of connections using a configured private key.
  * [logger.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/lib/logger.js): Logging Functions
  * [utils.ts](https://github.com/johnwhitton/horizon/blob/refactorV2/src/lib/utils.ts): Utility functions including (buffer2hex, rpcWrapper, toRLPHeader, getReceiptLight, getReceipt, getReceiptRlp, getReceiptTrie,hex2key,index2key, expandkey, getReceiptProof, getTransactionProof, getAccountProof, getStorageProof, getKeyFromProof, fullToMin)

**npm packages**

* [@ethereumjs/block](https://www.npmjs.com/package/@ethereumjs/block): Implements schema and functions related to Ethereum's block. (Ethereum 1.0 or Execution Chain for Ethereum 2.0)
* [ethereumjs-util](https://www.npmjs.com/package/ethereumjs-util): A collection of utility functions for Ethereum. It can be used in Node.js and in the browser with browserify.
* [ethers](https://www.npmjs.com/package/ethers): A complete, compact and simple library for Ethereum and ilk, written in TypeScript.
*
* [miller-rabin](https://www.npmjs.com/package/miller-rabin): implements [Miller Rabin primality test](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test)
* [mmap-io](https://www.npmjs.com/package/mmap-io): Memory Map for node.js
* [sha3](https://www.npmjs.com/package/sha3): A pure JavaScript implementation of the Keccak family of cryptographic hashing algorithms, most notably including Keccak and SHA3.
*

#### Light Client Functionality

#### Token Lockers

### References

### Appendices

#### Appendix A: Current Implementation Walkthough

Following is a detailed walk though of the current implementation of the Ethereum Light Client and the flow for mapping tokens from Ethereum to Harmony.

##### Ethereum Light Client (on Harmony)

**Design**
Existing Design

1. DAG is generated for each Ethereum EPOCH: This takes a couple of hours and has a size of approx 1GB.
2. Relayer is run to replicate each block header to the SPV Client on Harmony.
3. EthereumLightClient.sol addBlockHeader: Adds each block header to the Ethereum Light Client.
4. Transactions are Verified

**Running the Relayer**

```
# Start the relayer (note: replace the etherum light client address below)
# relay [options] <ethUrl> <hmyUrl> <elcAddress>   relay eth block header to elc on hmy
 yarn cli ethRelay relay http://localhost:8645 http://localhost:9500 0x3Ceb74A902dc5fc11cF6337F68d04cB834AE6A22
```

**Implementation**

1. DAG Generation can be done explicity by calling `dagProve` from the CLI or it is done automatically by `getHeaderProof` in `ethHashProof/BlockProof.js` which is called from `blockRelay` in `cli/ethRelay.js`.
2. Relaying of Block Headers is done by `blockRelayLoop` in `cli/ethRelay.js` which
   * Reads the last block header from EthereumLightClient.sol
   * Loops through calling an Ethereum RPC per block to retrieve the blockHeader using `return eth.getBlock(blockNo).then(fromRPC)` in function `getBlockByNumber` in `eth2hmy-relay/getBlockHeader.js`
3. Adding BlockHeaders is done by `await elc.addBlockHeader(rlpHeader, proofs.dagData, proofs.proofs)` which is called from `cli/ethRelay.js`. `addBlockHeader` in `EthereumLightClient.sol`
   * calculates the blockHeader Hash
   * and checks that it
     * hasn't already been relayed,
     * is the next block to be added,
     * has a valid timestamp
     * has a valid difficulty
     * has a valid Proof of Work (POW)
   * Check if the canonical chain needs to be replaced by another fork

#### Mapping Tokens (Ethereum to Harmony)

**Design**

1. If the Token Has not already been mapped on Harmony
   * Harmony: Create an ERC20 Token
   * Harmony: Map the Ethereum Token to the new ERC20 Contract
   * Ethereum: Validate the Harmony Mapping Transaction
   * Ethereum: Map the Harmony ERC20 token to the existing Ethereum Token
   * Harmony: Validate the Ethereum mapping Transaction

*Note: The key difference between `TokenLockerOnEthereum.sol` and `TokenLockerOnHarmony.sol` is the proof validation. `TokenLockerOnEthereum.sol` uses `./lib/MMRVerifier.sol` to validate the [Mountain Merkle Ranges](https://github.com/opentimestamps/opentimestamps-server/blob/master/doc/merkle-mountain-range.mdx) on Harmony and `HarmonyProver.sol`. `TokenLockerOnHarmony.sol` imports `./lib/MPTValidatorV2.sol` to validate [Merkle Patrica Trie](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/#merkle-patricia-trees) and `./EthereumLightClient.sol`.*

*Note: `validateAndExecuteProof` is responsible for creation of the BridgeTokens on the destination chain it does this by calling `execute` call in `TokenLockerLocker.sol` which then calls the function `onTokenMapReqEvent` in `TokenRegistry.sol` which creates a new Bridge Token `BridgedToken mintAddress = new BridgedToken{salt: salt}();` and then initializes it. This uses [(RLP) Serialization](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/)*

*Note: The shims in `ethWeb3.js` provide simplified functions for `ContractAt`, `ContractDeploy`, `sendTx` and `addPrivateKey` and have a constructor which uses `process.env.PRIVATE_KEY`.*

**Mapping the Tokens**

```
# Map the Tokens
# map <ethUrl> <ethBridge> <hmyUrl> <hmyBridge> <token>
yarn cli Bridge map http://localhost:8645 0x017f8C7d1Cb04dE974B8aC1a6B8d3d74bC74E7E1 http://localhost:9500 0x017f8C7d1Cb04dE974B8aC1a6B8d3d74bC74E7E1 0x4e59AeD3aCbb0cb66AF94E893BEE7df8B414dAB1
```

**Implementation**

* The CLI calls `tokenMap` in `src/bridge/contract.js` to
  * Instantiate the Ethereum Bridge and Harmony Bridge Contracts
  * Calls `TokenMap` in `scr/bridge/bridge.js` to
    * Issue a token Map request on Ethereum `const mapReq = await src.IssueTokenMapReq(token)`
    * Acknowledge the Map Request on Harmony `const mapAck = await Bridge.CrossRelayEthHmy(src, dest, mapReq)`
    * Issue a token Map request on Harmony `return Bridge.CrossRelayHmyEth(dest, src, mapAck.transactionHash)`

**Here is the Logic (call execution overview) when Mapping Tokens across Chains. *NOTE: Currently mapping has only been developed from Ethereum to Harmony (not bi-directional)*.**

1. Bridge Map is called in src.cli.index.js and it calls `tokenMap` in `bridge/contract.js` which
   * Get srcBridge Contract on Ethereum `TokenLockerOnEthereum.sol` from `ethBridge.js` it also instantiates an `eprover` using `tools/eprover/index.js` which calls `txProof.js` which uses [eth-proof npm package](https://www.npmjs.com/package/eth-proof). *Note: this is marked with a //TODO need to test and develop proving logic on Harmony.*
   * Get destBridge Contract on Hamony `TokenLockerOnHarmony.sol` from `hmyBridge.js` it also instantiates an `hprove` using `tools/eprover/index.js` which calls `txProof.js` which uses [eth-proof npm package](https://www.npmjs.com/package/eth-proof).
   * calls `TokenMap` in `bridge.js`
2. `TokenMap` Calls IssueTokenMapReq (on the Ethreum Locker) returning the `mapReq.transactionHash`
   * `IssueTokenMapReq(token)` is held in `bridge.js` as part of the bridge class
   * It calls `issueTokenMapReq` on `TokenLockerOnEthereum.sol` which is implemented by `TokenRegistry.sol`
   * `issueTokenMapReq` checks if the token has already been mapped if not it was emitting a `TokenMapReq` with the details of the token to be mapped. However this was commented out as it was felt that, if it has not been mapped, we use the `transactionHash` of the mapping request\` to drive the logic below (not the event).
3. `TokenMap` calls `Bridge.CrossRelay` with the IssueTokenMapReq.hash to
   * gets the proof of the transaction on Ethereum via `getProof` calling `prover.ReceiptProof` which calls the eprover and returns `proof` with
     * `hash: sha3(resp.header.serialize()),`
     * `root: resp.header.receiptRoot,`
     * `proof: encode(resp.receiptProof),`
     * `key: encode(Number(resp.txIndex)) // '0x12' => Nunmber`
   * We then call `dest.ExecProof(proof)` to execute the proof on Harmony
     * This calls `validateAndExecuteProof` on `TokenLockerOnHarmony.sol` with the `proofData` from above, which
       * requires `lightclient.VerifyReceiptsHash(blockHash, rootHash),` implemented by `./EthereumLightClient.sol`
         * This returns `return bytes32(blocks[uint256(blockHash)].receiptsRoot) == receiptsHash;`
         * **Which means the block has to be relayed first, as we have just executed the transaction the relayer usually has not relayed the block so this will fail**
       * requires `lightclient.isVerified(uint256(blockHash)` implemented by `./EthereumLightClient.sol`
         * This returns `return canonicalBlocks[blockHash] && blocks[blockHash].number + 25 < blocks[canonicalHead].number;`
         * **Which means there must be an additional 25 blocks on Ethereum before this can be processed. This logic needs to be rewritten to break down execution for 1. the ethereum mapping request 2. After a 25 block delay the Harmony Proof validation and executing the Harmony Mapping Request**
       * `require(spentReceipt[receiptHash] == false, "double spent!");` to ensure that we haven't already executed this proof
       * gets the `rlpdata` using `EthereumProver.validateMPTProof` implemented by `EthereumProver.sol` which
         * Validates a Merkle-Patricia-Trie proof.
         * Returns a value whose inclusion is proved or an empty byte array for a proof of exclusion
       * marks `spentReceipt[receiptHash] = true;`
       * `execute(rlpdata)` implemented by `TokenLocker.sol` which calls `onTokenMapReqEvent(topics, Data)` implemented by `TokenRegistry.sol`
         * `address tokenReq = address(uint160(uint256(topics[1])));` gets the address of the token to be mapped.
         * require `address(RxMapped[tokenReq]) == address(0)` that the token has not already been mapped.
         * `address(RxMapped[tokenReq]) == address(0)` creates a new BridgedToken implemented by `BridgedToken.sol`
           * `contract BridgedToken is ERC20Upgradeable, ERC20BurnableUpgradeable, OwnableUpgradeable` it is a standard openzepplin ERC20 Burnable, Ownable, Upgradeable token
         * `mintAddress.initialize` initialize the token with the same `name`, `symbol` and `decimals` as the ethereum bridged token
         * `RxMappedInv[address(mintAddress)] = tokenReq;` updates the inverse Key Value Mapping
         * `RxMapped[tokenReq] = mintAddress;` updates the Ethereum mapped tokens
         * `RxTokens.push(mintAddress);` add the newly created token to a list of bridged tokens
         * `emit TokenMapAck(tokenReq, address(mintAddress));`
       * `require(executedEvents > 0, "no valid event")` to check if it executed the mapping correctly.
4. We then take the Harmony Mapping `transactionHash` and repeat the above process to prove the Harmony mapping acknowledgment on Ethereum (Cross Relay second call) `return Bridge.CrossRelay(dest, src, mapAck.transactionHash);`

* gets the proof of the transaction on Harmony via `getProof` calling `prover.ReceiptProof` which calls the eprover and returns `proof` with
  \_`hash: sha3(resp.header.serialize()),`
  \_ `root: resp.header.receiptRoot,`
  \_`proof: encode(resp.receiptProof),`
  \_ `key: encode(Number(resp.txIndex)) // '0x12' => Nunmber`
  * We then call `dest.ExecProof(proof)` to execute the proof on Ethereum
    * This calls `validateAndExecuteProof` on `TokenLokerOnEthereum.sol` with the `proofData` from above, which
      * `require(lightclient.isValidCheckPoint(header.epoch, mmrProof.root),` implemented by `HarmonyLightClient.sol`
        * `return epochMmrRoots[epoch][mmrRoot]` which means that the epoch has to have had a checkpoint submitted via `submitCheckpoint`
      * `bytes32 blockHash = HarmonyParser.getBlockHash(header);` gets the blockHash implemented by `HarmonyParser.sol`
        * This returns `return keccak256(getBlockRlpData(header));`
        * `getBlockRlpData` creates a list `bytes[] memory list = new bytes[](15);` and uses statements like `list[0] = RLPEncode.encodeBytes(abi.encodePacked(header.parentHash));` to perform [Recursive-Length Prefix (RLP) Serialization](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/) implemented by `RLPEncode.sol`
      * `HarmonyProver.verifyHeader(header, mmrProof);` verifys the header implemented by `HarmonyProver.sol`
        * `bytes32 blockHash = HarmonyParser.getBlockHash(header);` gets the blockHash implemented by `HarmonyParser.sol` as above
        * `valid = MMRVerifier.inclusionProof(proof.root, proof.width, proof.index, blockHash, proof.peaks, proof.siblings);` verifys the proff using the [Merkle Mountain Range Proof](https://github.com/opentimestamps/opentimestamps-server/blob/master/doc/merkle-mountain-range.mdx) passed `MMRVerifier.MMRProof memory proof` and the `blockHash`.
        * **NOTE: This means that a `submitCheckpoint` in `HarmonyLightClient.sol` needs to have called either for the next epoch or for a checkpoint, after the block the harmony mapping transaction was in.**
        * **NOTE: Automatic submission of checkpoints to the Harmony Light Client has not been developed as yet. (It is not part of the `ethRelay.js`). And so the checkpoint would need to be manually submitted before the Ethereum Mapping could take place.**
      * `require(spentReceipt[receiptHash] == false, "double spent!");` ensure that we haven't already processed this mapping request\`
      * `HarmonyProver.verifyReceipt(header, receiptdata)` ensure the receiptdata is valid
      * `spentReceipt[receiptHash] = true;` marks the receipt as having been processed
      * `execute(receiptdata.expectedValue);` implemented by `TokenLocker.sol` which calls `onTokenMapAckEvent(topics)` implemented by `TokenRegistry.sol`
        * `address tokenReq = address(uint160(uint256(topics[1])));`
        * `address tokenAck = address(uint160(uint256(topics[2])));`
        * `require(TxMapped[tokenReq] == address(0), "missing mapping to acknowledge");`
        * `TxMapped[tokenReq] = tokenAck;`
        * `TxMappedInv[tokenAck] = IERC20Upgradeable(tokenReq);`
        * `TxTokens.push(IERC20Upgradeable(tokenReq));`

5. Upon completion of tokenMap control is passed back to Bridge Map which
6. Calls TokenPair on Ethereum
7. Calls ethTokenInfo to get the status of the ERC20
8. Calls hmyTokenInfo to get the tokenStatus on Harmony


## Crosschain Bridge Analysis - An Introduction

* date: 2023-02-04
* last updated: 2023-02-04

Here we present a survey of existing bridge designs, historical security incidents, and a brief discussion of common components and where ZKP may be used.

### Bridge Taxonomy

Bridge designs evolved as DeFi and multi-chain paradigm gained popularity. Our summary is inspired by prior taxonomy work by [Ganesha Upadhyaya](https://twitter.com/gupadhyaya) in [A Classification of Various Bridging Technologies](https://medium.com/harmony-one/harmonys-cross-chain-future-41d02d53b10), [Dmitriy Berenzon](https://twitter.com/dberenzon) in [Blockchain Bridges: Building Networks of Cryptonetworks](https://medium.com/1kxnetwork/blockchain-bridges-5db6afac44f8), and by multiple researchers from Jump Crypto in [Security Stack-Up: How Bridges Compare](https://jumpcrypto.com/security-stack-up-how-bridges-compare/)

> At a very high level, there are two types of bridging solutions: 1) proof-based and 2) committee-based. The proof-based solutions entail cryptographic proving of the validity of any transaction of one chain in the other, whereas the committee-based solution relies on the social consensus of the bridge validators to attest for the transaction validity, which often involves no cryptographic proving.
>
> * Ganesha Upadhyaya in "A Classification of Various Bridging Technologies"

#### Proof Based

##### Validity Proofs

Validity-proof based bridges prioritize security, trustlessness, permissionlessness, and delay minimization

| Type   | Design                                                                                                                                                                                             | Code                                                                                                                       | UI                                                               | Note                                                                  |
| ------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------- | --------------------------------------------------------------------- |
| ZKP    | [zkBridge](https://rdi.berkeley.edu/zkp/zkBridge/uploads/paper.pdf)                                                                                                                                | TBD                                                                                                                        | TBD                                                              | By Berkeley researcehrs ([Twitter](https://twitter.com/zkcollective)) |
| ZKP    | [Telepathy](https://docs.telepathy.xyz/protocol/overview)                                                                                                                                          | [Telepathy](https://github.com/succinctlabs?q=telepathy\&type=all\&language=\&sort=)                                       | [Demo](https://demo.telepathy.xyz/)                              | By [Succint Labs](https://succinct.xyz)                               |
| Native | [Horizon](https://arxiv.org/pdf/2101.06000.pdf)                                                                                                                                                    | [Horizon](https://github.com/harmony-one/horizon)                                                                          | TBD                                                              | Inactive. By Harmony                                                  |
| Native | [IBC](https://github.com/cosmos/ibc) ([Intro](https://tutorials.cosmos.network/academy/3-ibc/1-what-is-ibc.html))                                                                                  | [ibc-go](https://github.com/cosmos/ibc-go)                                                                                 | Various / [Explorer](https://hub.mintscan.io/chains/ibc-network) | Within Cosmos Network                                                 |
| Native | [Gravity](https://github.com/Gravity-Bridge/Gravity-Bridge/blob/main/docs/design/overview.mdx)                                                                                                     | [Gravity](https://github.com/Gravity-Bridge/Gravity-Bridge)                                                                | [Gravity](https://bridge.blockscape.network/)                    | Ethereum and Cosmos                                                   |
| Native | [AWM](https://github.com/ava-labs/xsvm) ([Intro](https://medium.com/avalancheavax/avalanche-warp-messaging-awm-launches-with-the-first-native-subnet-to-subnet-message-on-avalanche-c0ceec32144a)) | [Wrap](https://github.com/ava-labs/avalanchego/tree/master/vms/platformvm/warp) / [XSVM](https://github.com/ava-labs/xsvm) | TBD / [Explorer](https://subnets.avax.network/subnets)           | Within Avalanche Subnets                                              |
| Native | [Snowbridge](https://docs.snowbridge.network/architecture/overview)                                                                                                                                | [snowbridge](https://github.com/Snowfork/snowbridge)                                                                       | TBD                                                              |                                                                       |
| LCP    | [Datachain LCP](https://medium.com/lcp-network/lcp-a-proxy-for-light-client-verification-to-realize-trust-minimized-and-gas-efficient-f7d5868e4b0)                                                 | [LCP](https://github.com/datachainlab/lcp) / [Demo](https://github.com/datachainlab/harmony-cosmos-bridge-demo)            | TBD                                                              | Relies on TEE enclave                                                 |
| LCP    | [Avalanche](https://medium.com/avalancheavax/avalanche-bridge-secure-cross-chain-asset-transfers-using-intel-sgx-b04f5a4c7ad1)                                                                     | TBD / [Audit](https://github.com/ava-labs/audits/blob/main/bridge/Avalanche_Bridge_Security_Audit_Report_Halborn_v1_1.pdf) | [core.app](https://core.app/bridge/)                             | Relies on TEE enclave (Intel SGX)                                     |

##### Fraud Proofs

Fraud-proof based bridges assume all participants are truthful unless someone presents a proof showing otherwise. As a result, they must leave a wide fraud-proof time window and carefully design economic incentives for such. This limitation inevitably incurs much higher delay, but makes implementation substantially easier and costs significantly less to operate and maintain. Fraud-proof based bridges face more security risks due to reliance on fraud-prover and economic incentives, but still far less risky than committee-based bridges.

| Design                                                                                                                                               | Code                                                               | UI                                                      | Note                            |
| ---------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ | ------------------------------------------------------- | ------------------------------- |
| [Rainbow](https://near.org/blog/eth-near-rainbow-bridge/)                                                                                            | [rainbow-bridge](https://github.com/aurora-is-near/rainbow-bridge) | [rainbowbridge.app](https://rainbowbridge.app/transfer) | By NEAR                         |
| [Nomad](https://docs.nomad.xyz/governance-bridge/architecture) ([Intro](https://medium.com/nomad-xyz-blog/the-nomad-design-philosophy-6fc0eacf3263)) | [monorepo](https://github.com/nomad-xyz/monorepo)                  | [app.nomad.xyz](https://app.nomad.xyz/)                 | Hacked $200M (engineering flaw) |
| [Darwinia](https://docs.darwinia.network/) ([Paper](https://darwinia.network/itering_io_optimistic_bridge_technical_paper_en.pdf))                   | [darwinia](https://github.com/darwinia-network/darwinia)           | TBD / [Explorer](https://darwinia.subscan.io/)          |                                 |

#### Committee Based

| Sub Category         | Type                               | Design/Docs                                                                                                                                                                                                                                                                   | Implementation                                                                                                                                                                                        | Frontend                                                                                                                                                                                                             |
| -------------------- | ---------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Protocol Validators  |                                    | [Cosmos Gravity Bridge](https://www.gravitybridge.net/faq)                                                                                                                                                                                                                    | [gravity-bridge](https://github.com/cosmos/gravity-bridge)                                                                                                                                            | [https://bridge.blockscape.network/](https://bridge.blockscape.network/) [https://emeris.com/ (ON HOLD)](https://emeris.com/)                                                                                        |
| Proof of Stake Chain |                                    | [Axelar](https://axelar.network/axelar_whitepaper.pdf) [docs](https://docs.axelar.dev/)                                                                                                                                                                                       | [axelar-core](https://github.com/axelarnetwork/axelar-core)                                                                                                                                           | TBD                                                                                                                                                                                                                  |
| Proof of Stake Chain |                                    | [Celer cBridge](https://cbridge-docs.celer.network/) [Celer Network Whitepaper](https://celer.network/doc/CelerNetwork-Whitepaper.pdf)                                                                                                                                        | [cBridge-node](https://github.com/celer-network/cBridge-node), [cBridge-contracts](https://github.com/celer-network/cBridge-contracts), [cBridge-cowa](https://github.com/celer-network/cbridge-cowa) | [https://cbridge.celer.network/](https://cbridge.celer.network/)                                                                                                                                                     |
| External Networks    | Multisig                           | [Horizon 1.0](https://medium.com/harmony-one/introducing-horizon-an-ethereum-harmony-cross-chain-bridge-2f56ed7214b3)                                                                                                                                                         | [github](https://github.com/harmony-one/horizon)                                                                                                                                                      | OBSOLETE                                                                                                                                                                                                             |
| External Networks    | Multisig                           | [Wormhole](https://book.wormhole.com/wormhole/2_architectureOverview.html)                                                                                                                                                                                                    | [wormhole](https://github.com/wormhole-foundation/wormhole)                                                                                                                                           | [network](https://wormhole.com/network/) [ecosystem](https://wormhole.com/ecosystem/)                                                                                                                                |
| External Networks    | Decentralized Oracle Network (DON) | [Chainlink (CCIP)](https://blog.chain.link/introducing-the-cross-chain-interoperability-protocol-ccip/), [web](https://chain.link/cross-chain) [Chainlink Whitepaper](https://research.chain.link/whitepaper-v2.pdf?_ga=2.40239147.884807142.1677705772-204109244.1677705772) | [ccip-read](https://github.com/smartcontractkit/ccip-read)                                                                                                                                            | N/A                                                                                                                                                                                                                  |
| External Networks    | Decentralized Oracle Network (DON) | [LayerZero](https://layerzero.network/pdf/LayerZero_Whitepaper_Release.pdf), [docs](https://layerzero.gitbook.io/docs/)                                                                                                                                                       | [LayerZero](https://github.com/LayerZero-Labs/LayerZero)                                                                                                                                              | [https://theaptosbridge.com/bridge](https://theaptosbridge.com/bridge) [https://bitcoinbridge.network/bridge](https://bitcoinbridge.network/bridge) [https://bridge.harmony.one/one](https://bridge.harmony.one/one) |
| External Networks    | Multi-Party Communication (MPC)    | [Multichain bridge](https://docs.multichain.org/getting-started/introduction)                                                                                                                                                                                                 | [Cross-Chain-Bridge](https://github.com/anyswap/CrossChain-Bridge)                                                                                                                                    | [https://bsc.anyswap.exchange/](https://bsc.anyswap.exchange/bridge#/router)                                                                                                                                         |
| External Networks    | Multi-Party Communication (MPC)    | [Synapse Protocol](https://medium.com/synapse-protocol/introducing-synapse-protocol-2af926143deb), [docs](https://docs.synapseprotocol.com/)                                                                                                                                  | [synapsecns](https://github.com/orgs/synapsecns/repositories)                                                                                                                                         | [https://synapseprotocol.com/](https://synapseprotocol.com/)                                                                                                                                                         |

#### Others

| Sub Category      | Type | Design/Docs                                                                                                                                     | Implementation                                                               | Frontend                                                         |
| ----------------- | ---- | ----------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- | ---------------------------------------------------------------- |
| rollup-to-rollup  |      | [Hop Protocol](https://hop.exchange/whitepaper.pdf), [docs](https://docs.hop.exchange/basics/a-short-explainer)                                 | [contracts](https://github.com/hop-protocol/contracts)                       | [https://app.hop.exchange/](https://app.hop.exchange/)           |
| mesh-network      |      | [Router Protocol](https://docs.routerprotocol.com/whitepaper/introducing-router-protocol/architecture), [docs](https://dev.routerprotocol.com/) | [Router Protocol](https://github.com/orgs/router-protocol/repositories)      | [https://app.thevoyager.io/swap](https://app.thevoyager.io/swap) |
| Bridge Components |      | [Parity Bridges Common](https://github.com/paritytech/parity-bridges-common#high-level-architecture)                                            | [parity-bridges-common](https://github.com/paritytech/parity-bridges-common) | TBD                                                              |

#### Miscellaneous

* TVL of bridges can be found on [DeFi Llama](https://defillama.com/protocols/Bridge)
* Some tools and queries are already prepared on Dune Analytics for analysis of bridge volume. See for example: [https://dune.com/queries/511393](https://dune.com/queries/511393).

### Bridging Components

Following are the main components for Cross-Chain Bridges we review

* Approach : The design approach for the bridge
* Proving Mechanisms: How do we ensure transactions are valid
  * Transaction Proofs: How do we ensure a transacion was included in a valid block
  * Block Proofs: How do we ensure a block was included in the canonical chain
* Relayer Mechanisms
  * Relaying: How do we relay messages (blocks and transactions) between chains
* Light Clients: What Light client approaches can we leverage
* Token Lockers: How do we safely store bridged assets in a trustless cost effective way
* Multi-chain support: What chains are supported and what is the proces to add additional chains.
* Economics: What are the costs for bridging between chains and how do we secure and incentivize validators and relayers.

### Cross Chain Communication Protocols

* [INTER‑BLOCKCHAINCOMMUNICATION PROTOCOL](https://ibcprotocol.org/)
* [Cosmos IBC: Interchain Standards](https://github.com/cosmos/ibc)
* [IBC Update— The Internet of Blockchains Is Growing Fast](https://blog.cosmos.network/ibc-update-the-internet-of-blockchains-is-growing-fast-dae883228ebf)
* [Polkadot Cross-Consensus Message (XCM) Format](https://github.com/paritytech/xcm-format/blob/master/README.mdx)
* [XCMP Design](https://research.web3.foundation/en/latest/polkadot/XCMP/index.html)
* [HRMP Channels](https://research.web3.foundation/en/latest/polkadot/XCMP/HRMP%20channels.html)
* [The Path of a Parachain Block](https://polkadot.network/blog/the-path-of-a-parachain-block/)
* [Parity Bridges Common](https://github.com/paritytech/parity-bridges-common/blob/master/README.mdx)

### Bridge Attack Vectors and Hacks

Following is an overview of some common bridge attack vectors.

* [Vitalik; security limits of bridges](https://old.reddit.com/r/ethereum/comments/rwojtk/ama_we_are_the_efs_research_team_pt_7_07_january/hrngyk8/)

> Now, imagine what happens if you move 100 ETH onto a bridge on Solana to get 100 Solana-WETH, and then Ethereum gets 51% attacked. The attacker deposited a bunch of their own ETH into Solana-WETH and then reverted that transaction on the Ethereum side as soon as the Solana side confirmed it. The Solana-WETH contract is now no longer fully backed, and perhaps your 100 Solana-WETH is now only worth 60 ETH. Even if there's a perfect ZK-SNARK-based bridge that fully validates consensus, it's still vulnerable to theft through 51% attacks like this.
>
> It's always safer to hold Ethereum-native assets on Ethereum or Solana-native assets on Solana than it is to hold Ethereum-native assets on Solana or Solana-native assets on Ethereum. And in this context, "Ethereum" refers not just to the base chain, but also any proper L2 that is built on it. If Ethereum gets 51% attacked and reverts, Arbitrum and Optimism revert too, and so "cross-rollup" applications that hold state on Arbitrum and Optimism are guaranteed to remain consistent even if Ethereum gets 51% attacked. And if Ethereum does not get 51% attacked, there's no way to 51% attack Arbitrum and Optimism separately. Hence, holding assets issued on Optimism wrapped on Arbitrum is still perfectly safe.
>
> Why a rollup can't just "go use another data layer". If a rollup stores its data on Celestia or BCH or whatever else but deals with assets on Ethereum, if that layer gets 51% attacked you're screwed. The DAS on Celestia providing 51% attack resistance doesn't actually help you because the Ethereum network isn't reading that DAS; it would be reading a bridge, which would be vulnerable to 51% attacks. To be a rollup that provides security to applications using Ethereum-native assets, you have to use the Ethereum data layer (and likewise for any other ecosystem).

Here are some sample hacks

* [Vulnerabilities in Cross-chain Bridge Protocols Emerge as Top Security Risk](https://blog.chainalysis.com/reports/cross-chain-bridge-hacks-2022/)

> Following last night’s exploit of the Nomad Bridge, Chainalysis estimates that $2 billion in cryptocurrency has been stolen across 13 separate cross-chain bridge hacks, the majority of which was stolen this year. Attacks on bridges account for 69% of total funds stolen in 2022 so far.

* [EXPLAINED: THE QUBIT HACK (JANUARY 2022)](https://halborn.com/explained-the-qubit-hack-january-2022/)

> The exploited contract used a modified safeTransferFrom() function which instead of making use of functionCall() to verify that the target address contained contract code, used the call() function directly. As the 0 address has no code at all, no code is run, and the call is completed successfully without reverting. As a result, the deposit function executed successfully but no real tokens were deposited.
>
> The Ethereum QBridge caught the Deposit event and interpreted it as a valid deposit of ETH. As a result, qXETH tokens were minted for the attacker on BSC.

* [EXPLAINED: THE WORMHOLE HACK (FEBRUARY 2022)](https://halborn.com/explained-the-wormhole-hack-february-2022/)

> The actual extraction of 120k ETH from the Wormhole bridge came at the end of a series of events. The actual flow of the attack was:
>
> 1. The attacker creates a validator action approval (VAA) with a call to post\_vaa
> 2. This VAA was used in a call to complete\_wrapped to mint the 120,000 ETH extracted in the attack
> 3. The attacker “legitimately” extracted the minted tokens from the bridge
>
> The vulnerability that made the attack possible was a failure to perform proper signature verification in the VAA creation process. The role of signature verification is delegated several times from post\_vaa to verify\_signatures to Secp256k1.

* [EXPLAINED: THE RONIN HACK (MARCH 2022)](https://halborn.com/explained-the-ronin-hack-march-2022/)

> The Ronin Network attack was extremely stealthy. In fact, the hack wasn’t noticed until six days after it occurred when the project team was notified by a user that they couldn’t withdraw about 5k ETH from the project’s bridge. Further investigation discovered the largest hack in DeFi history to date.
>
> The Ronin Network hack was made possible by compromised private keys. The Ronin Network uses a set of nine validator nodes to approve transactions on the bridge, and a deposit or withdrawal requires approval by a majority of five of these nodes. The attacker gained control of four validators controlled by Sky Mavis and a third-party Axie DAO validator that signed their malicious transactions.

* [EXPLAINED: THE HARMONY HORIZON BRIDGE HACK](https://halborn.com/explained-the-harmony-horizon-bridge-hack/)

> Like most cross-chain bridges, the Harmony Horizon Bridge has a validation process for approving transactions being transferred over the bridge. In this case, the approvals process uses a multi-signature scheme with five validators.
>
> However, the bridge only used a 2 of 5 validation scheme. This means that only two blockchain accounts needed to be compromised for an attacker to approve any malicious transaction that they wished.
>
> The Harmony Horizon bridge was exploited via the theft of two private keys. These private keys were encrypted with both a passphrase and a key management service, and no system had access to multiple plaintext keys. However, the attacker managed to access and decrypt multiple keys.
>
> With access to two of the bridge’s private keys, the attacker could create a transaction extracting $100 million from the bridge and confirm it using two accounts under their control.

* [THE NOMAD BRIDGE HACK: A DEEPER DIVE](https://halborn.com/the-nomad-bridge-hack-a-deeper-dive/)

> On August 1, DeFi bridge Nomad was hacked for over $190M.
>
> After a frenzied hack from hundreds of wallets, the bridge’s TVL dropped from $190,740,000 to $1,794 in mere hours. The hack involved a total of 960 transactions with 1,175 individual withdrawals from the bridge.
> According to Nomad’s post-mortem, an implementation bug in a June 21 smart contract upgrade caused the Replica contract to fail to authenticate messages properly. This issue meant that any message could be forged as long as it had not already been processed.
>
> As a result, contracts relying on the Replica for authentication of inbound messages suffered security failures. From there, this authentication failure resulted in fraudulent messages being passed to the Nomad BridgeRouter contract.

### References

Background and Overview

* [Harmony’s Cross-Chain Future](https://medium.com/harmony-one/harmonys-cross-chain-future-41d02d53b10)
* [Awesome Interoperability](https://github.com/nomad-xyz/awesome-interop): A curated list of awesome interoperability resources, libraries, tools and more.
* [Vitalik: why the future will be *multi-chain*, but it will not be *cross-chain*](https://twitter.com/vitalikbuterin/status/1479501366192132099?lang=en)
* [Vitalik’s Annotated Ethereum 2.0 Spec](https://notes.ethereum.org/@vbuterin/SkeyEI3xv)

Background and Overview (Zero Knowledge Related)

* [Bridging the Multichain Universe with Zero Knowledge Proofs](https://medium.com/@ingonyama/bridging-the-multichain-universe-with-zero-knowledge-proofs-6157464fbc86)
* [awesome-zkml](https://github.com/worldcoin/awesome-zkml)

Mathematical Theory

* [Elliptic Curve Cryptography: a gentle introduction](https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/)
* [Exploring Elliptic Curve Pairings](https://vitalik.ca/general/2017/01/14/exploring_ecp.html)

Mathematical Theory (Zero Knowledge Related)

* [KZG polynomial commitments](https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html)

Research Papers

* [Fraud and Data Availability Proofs](https://arxiv.org/pdf/1809.09044.pdf): Maximising Light Client Security and Scaling Blockchains with Dishonest Majorities. *Light clients, also known as Simple Payment Verification (SPV) clients, are nodes which only download a small portion of the data in a blockchain, and use indirect means to verify that a given chain is valid.*

Research Articles

* [Paths toward single-slot finality](https://notes.ethereum.org/@vbuterin/single_slot_finality): A look at how to improve Ethereum’s LMD GHOST + Casper FFG consensus.

Research Papers (Zero Knowledge Related)

* [zkBridge: Trustless Cross-chain Bridges Made Practical](https://rdi.berkeley.edu/zkp/zkBridge/uploads/paper.pdf)
* [zkPoS: End-to-End Trustless](https://hyperoracle.medium.com/zkpos-end-to-end-trustless-65edccd87c5a): HyperOracle article on how zkPoS provides the ability of proving the consensus with ZK.
* [Caulk: Lookup Arguments in Sublinear Time](https://eprint.iacr.org/2022/621.pdf)
* [HyperPlonk: Plonk with Linear-Time Prover and High-Degree Custom Gates](https://eprint.iacr.org/2022/1355.pdf)

Research Articles (Zero Knowledge Related)

* [SLONK—a simple universal SNARK](https://ethresear.ch/t/slonk-a-simple-universal-snark/6420): a simplification to PLONK called SLONK. We replace the permutation argument (the “P” in PLONK) in favour of a shift argument (the “S” in SLONK). We get a universal SNARK with the smallest known proof size and verification time.
* [Kate commitments from the Lagrange basis without FFTs](https://notes.ethereum.org/T0ZVaaywQAqP4jegqO3asg?view): how to commit, evaluate and open polynomials in the Lagrange basis without FFTs. This is the first part in a series (see part 1, part 2, part 3) showing how to do PLONK-style universal SNARKs without FFTs
* [Hadamard checks from the Lagrange basis without FFTs](https://notes.ethereum.org/Il4z42lmQtaUYFigsjsk2Q?view): how to prove Hadamard relations between polynomials in the Lagrange basis without FFTs. This is the second part (see part 1, part 2, part 3) in a series showing how to do PLONK-style universal SNARKs without FFTs.
* [PLONK-style SNARKs without FFTs](https://notes.ethereum.org/DLRqK9V7RIOsTZkab8Hm_Q?view): how to do PLONK-style universal SNARKs without FFTs. This is part 3 in a series (part 1, part 2, part 3).

Implementation Articles

* [zkBridge: Trustless Cross-chain Bridges Made Practical](https://rdi.berkeley.edu/zkp/zkBridge/zkBridge.html)
* [Succinct Towards the endgame of blockchain interoperability with proof of consensus](https://blog.succinct.xyz/post/2022/09/20/proof-of-consensus)

Implementations

* [Wormhole ethereum contracts Implementaion.sol](https://github.com/wormhole-foundation/wormhole/blob/dev.v2/ethereum/contracts/Implementation.sol)
* [bls verification contract](https://github.com/semaraugusto/bls-verification-contract/blob/master/contracts/verifier.sol)

Documentation

* [ETHEREUM DEVELOPMENT DOCUMENTATION](https://ethereum.org/en/developers/docs/)
* [MINA docs](https://docs.minaprotocol.com/)

Additional References

* [nil-Foundation ETH-Mina bridge live on Ethereum testnet Ropsten](https://minacrypto.com/2022/04/27/nil-foundation/)

### Bridge Implementation References

* [Harmony Horizon Bridge](./harmony-horizon): Detailed code review
  * [Horizon](https://github.com/johnwhitton/horizon/tree/refactorV2): javascript, solidity
* Near Rainbow Bridge: Codebases
  * [Near Rainbow Bridge](https://github.com/aurora-is-near/rainbow-bridge): rust, go, solidity, javascript
  * [Near Rainbow Token Connector](https://github.com/aurora-is-near/rainbow-token-connector): soldity
  * SDK
    * [Near Rainbow Bridge Client](https://github.com/aurora-is-near/rainbow-bridge-client/tree/main/packages/client): typescript
  * Frontend
    * [NEAR Rainbow Bridge Frontend](https://github.com/aurora-is-near/rainbow-bridge-frontend)
* [Nomad monprepo](https://github.com/nomad-xyz/monorepo): Nomad is a cross-chain communication protocol. This repo contains the following: Smart contracts for the core Nomad protocol, Smart contracts for the Nomad token bridge SDKs for Nomad's core protocol, bridge, and governance systems, Tooling for local environment simulation and Smart contract deployment tooling.
  * [Nomad rust](https://github.com/nomad-xyz/rust): Nomad is a cross-chain communication standard that supports passing messages between blockchains easily and inexpensively. Like IBC light clients and similar systems, Nomad establishes message-passing channels between chains. Once a channel is established, any application on that chain can use it to send messages to others chains.
  * [Nomad gelato-sdk](https://github.com/nomad-xyz/gelato-sdk): This crate reimplements Gelato's Relay SDK in Rust. It simply wraps Gelato Relay requests and responses to/from Gelato endpoints with Rust types and methods.
* [Succinct labs](../bridge/succinct): Deep dive on Succinct labs Proof of Consensus for Ethreum.
  * [Proof of Consensus for Ethereum](https://github.com/succinctlabs/eth-proof-of-consensus): contains both the zkSNARK circuits as well as the smart contracts needed for our succinct light client implementation, as well as prototype message passing contracts and bridge contracts.
* [Datachain lcp](https://github.com/datachainlab/harmony-cosmos-bridge-demo)A proxy for light client verification executed in TEE.
* [Cosmos ibc-go](https://github.com/cosmos/ibc-go): allows blockchains to talk to each other. This end-to-end, connection-oriented, stateful protocol provides reliable, ordered, and authenticated communication between heterogeneous blockchains.
  * [Cosmos ibc](https://github.com/cosmos/ibc): ibc specification
* [Cosmos gravity bridge](https://github.com/cosmos/gravity-bridge): Cosmos and Ethereum bridge designed to run on the Cosmos Hub focused on maximum design simplicity and efficiency.
* [Axelar](https://github.com/axelarnetwork/axelar-core): based on the Cosmos SDK is the main application of the axelar network. [whitepaper](https://axelar.network/axelar_whitepaper.pdf) [docs](https://docs.axelar.dev/)
* [Celer cBridge-node](https://github.com/celer-network/cBridge-node): Celer cBridge relay node implementation in Golang. ([docs](https://cbridge-docs.celer.network/))
  * [Celer cBridge-contracts](https://github.com/celer-network/cBridge-contracts): Contracts for cBridge, cross-chain liquidity solution powered by Hashed-Timelock Transfers
  * [Celer cBridge-cowa](https://github.com/celer-network/cbridge-cowa): CosmWasm Rust smart contracts for cbridge
* [Wormhole](https://github.com/wormhole-foundation/wormhole): the reference implementation of the Wormhole protocol. ([docs](https://book.wormhole.com/introduction/introduction.html))
* [LayerZero Labs LayerZero](https://github.com/LayerZero-Labs/LayerZero): contains the smart contracts for LayerZero Endpoints. ([docs](https://layerzero.gitbook.io/docs/))
* [Multichain CrossChain-Bridge](https://github.com/anyswap/CrossChain-Bridge): Cross-Chain bridge based on Anyswap MPC network. ([docs](https://docs.multichain.org/getting-started/introduction))
* [Synapse Protocol](https://github.com/synapsecns): a universal interoperability protocol that enables secure cross-chain communication.( [docs](https://docs.synapseprotocol.com/))
  * [synapse-contracts](https://github.com/synapsecns/synapse-contracts): smart contracts for Synapse Protocol.
* [Hop Protocol contracts](https://github.com/hop-protocol/contracts): Hop is a scalable rollup-to-rollup general token bridge. Heare are the smart contracts that power the Hop Exchange. ([whitepaper](https://hop.exchange/whitepaper.pdf), [docs](https://docs.hop.exchange/basics/a-short-explainer)).
* [Router Protocol](https://github.com/orgs/router-protocol/repositories): ([whitepaper](https://docs.routerprotocol.com/whitepaper/introducing-router-protocol), [docs](https://dev.routerprotocol.com/))
* [Parity Bridges Common](https://github.com/paritytech/parity-bridges-common): a collection of components for building bridges.
* [Snowfork snowbridge](https://github.com/Snowfork/snowbridge): A trustless bridge between Polkadot and Ethereum. ([docs](https://docs.snowbridge.network/))


## Isomorph

* date: 2023-02-24
* last updated: 2023-02-24

### Overview

Isomorph is a Zero Knowledge trustless multichain bridge.

### Approach

### Sample Process Flow

At a high level when an event happens on chain 1 we want to trigger a corresponding action on chain 2.

For a simple bridging of funds this looks as follows

1. Alice deposits 100 TokenX into TokenLocker on Chain 1 (which are locked) \*\*a1
2. A transaction t1 is triggered in Block b1 and an event e1 is sent
3. The relayer listens to event e1 and relays the transaction receipt information to Chain 2.
4. Verifier verifies that t1 is in block b1
5. Verifier verifies that block b1 is a valid block
6. Verifier verifies that b1 is in Chain1 canoninical chain
7. Executor1 triggers a minting of corresponding 100 TokenX∆ on TokenLocker∆ on Chain 2
8. A transaction t2 is triggered in Block b2 and an event e2 is sent
9. The relayer listens to event e2 and relays the transaction receipt information to Chain 1.
10. Verifier verifies that t2 is in block b2
11. Verifier verifies that block b2 is a valid block
12. Verifier verifies that b2 is in Chain2 canoninical chain
13. Executor2 marks the bridge transaction as complete

### Proof Components

* Valid Signers : Who are eligible to sign
* Valid Signature:
* Valid Block : (Epoch)

### Technology

* TokenLocker: [horizon txProof.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/eprover/txProof.js) [npm EthProof](https://www.npmjs.com/package/eth-proof)
* TransactionVerify: Proves a [Merkle Patricia Trie](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/) using [merkle Proof](https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.mdx) which verifies the [Transaction.Hash](https://github.com/ethereum/go-ethereum/blob/release/1.9/core/types/transaction.go#L44) against [Header.txHash](https://github.com/ethereum/go-ethereum/blob/release/1.9/core/types/block.go#L77). Here is an example from horizon using [horizon txProof.js](https://github.com/johnwhitton/horizon/blob/refactorV2/src/eprover/txProof.js) which calls [npm EthProof](https://www.npmjs.com/package/eth-proof).
* BlockSignatureVerification
  * On Chain Verification : example is Near Rainbow Bridge Fraud Proof
  * Optimistic
  * Secure Enclave
  * Zero Knowledge
    * Prover
    * Verification
* BlockCanonicalVerification
  * Wait Number of Blocks
  * Optimistic
  * Light Client (Finality Gadgets)
  * Finalized Epoch
* EventLister
* Executor

### Proving Mechanisms

#### Avalanche

#### Binance

#### Cosmos

#### Ethereum

#### NEAR

The leading NEAR Ethereum Bridge today Near Rainbow Bridge uses an optimistic approach. Following is an excerpt from NearOnEthClient [^near-1].

> we adopt the optimistic [^near-2] approach where NearOnEthClient verifies everything in the NEAR header except the signatures. Then anyone can challenge a signature in a submitted header within a 4-hour challenge window. The challenge requires verification of a single Ed25519 signature which would cost about 500k Ethereum gas (expensive, but possible).

#### Harmony

#### Polygon

#### Polkadot

Previous proving mechanisms for Polkadot leverage BEEFY (Bridge Effiency Enabling Finality Yielder) [^dot-3] an example is Snowbridge [^dot-1] which developed their own Interactive Update Protocol [^dot-2].

### Verification Mechanism

### Relayer Mechanisms

### Token Lockers

### References

### Appendices

#### Appendix F: Data Structures

* Block Structure from [go-ethereum](https://github.com/ethereum/go-ethereum/blob/release/1.9/core/types/block.go#L72)

```
// SealHash returns the hash of a block prior to it being sealed.
func (ethash *Ethash) SealHash(header *types.Header) (hash common.Hash) {
 hasher := sha3.NewLegacyKeccak256()

 rlp.Encode(hasher, []interface{}{
  header.ParentHash,
  header.UncleHash,
  header.Coinbase,
  header.Root,
  header.TxHash,
  header.ReceiptHash,
  header.Bloom,
  header.Difficulty,
  header.Number,
  header.GasLimit,
  header.GasUsed,
  header.Time,
  header.Extra,
 })
 hasher.Sum(hash[:0])
 return hash
}
```

* Transaction structure from [go-ethereum](https://github.com/ethereum/go-ethereum/blob/release/1.9/core/types/transaction.go#LL39-L64C2)

```
type Transaction struct {
 data txdata    // Consensus contents of a transaction
 time time.Time // Time first seen locally (spam avoidance)

 // caches
 hash atomic.Value
 size atomic.Value
 from atomic.Value
}

type txdata struct {
 AccountNonce uint64          `json:"nonce"    gencodec:"required"`
 Price        *big.Int        `json:"gasPrice" gencodec:"required"`
 GasLimit     uint64          `json:"gas"      gencodec:"required"`
 Recipient    *common.Address `json:"to"       rlp:"nil"` // nil means contract creation
 Amount       *big.Int        `json:"value"    gencodec:"required"`
 Payload      []byte          `json:"input"    gencodec:"required"`

 // Signature values
 V *big.Int `json:"v" gencodec:"required"`
 R *big.Int `json:"r" gencodec:"required"`
 S *big.Int `json:"s" gencodec:"required"`

 // This is only used when marshaling to JSON.
 Hash *common.Hash `json:"hash" rlp:"-"`
}
```

### FootNotes

NEAR

[^near-1]: [NEAR: ETH-NEAR Rainbow Bridge](https://near.org/blog/eth-near-rainbow-bridge/): a bridge, called Rainbow Bridge, to connect the Ethereum and NEAR blockchains.

[^near-2]: [Optimistic Contracts](https://medium.com/@deaneigenmann/optimistic-contracts-fb75efa7ca84): contracts that accept all information as fact until proven to be non-factual. This allows for a reduction in the cost of verifying data, as on-chain verification would only be necessary when one is sure that the data is false.

Polkadot

[^dot-1]: [SnowBridge: Polkadot Verification](https://docs.snowbridge.network/architecture/verification/polkadot): use Polkadot’s BEEFY gadget to implement an efficient light client that only needs to verify a very small subset of relay chain validator signatures.

[^dot-2]: [Snowbridge: Interactive Update Protocol](https://docs.snowbridge.network/architecture/verification/polkadot/interactive-update-protocol): A prover wants to convince a light client that at least $$1/3$$ of validators signed a statement, which they claim that a specific set of at least $$2/3$$ of validators do.

[^dot-3]: [Polkadot: BEEFY](https://spec.polkadot.network/#sect-grandpa-beefy): The BEEFY (Bridge Effiency Enabling Finality Yielder) is a secondary protocol to GRANDPA to support efficient bridging between the Polkadot network (relay chain) and remote, segregated blockchains, such as Ethereum, which were not built with the Polkadot interchain operability in mind.


## Near Rainbow Bridge

* date: 2023-02-24
* last updated: 2023-02-24

### Overview

NEAR Rainbow bridge was enhanced to support Ethereum 2.0 leveraging Ethereum Light Clients. This document is a review of the design.

Key differences in supporting Ethereum 2.0 (Proof of Stake) vs Proof of Work involves removing the ETHHASH logic and SPV client and potentially replacing with MMR trees per epoch and checkpoints similar to Harmony Light Client on Ethereum.

The [NEAR Rainbow bridge](https://near.org/bridge/) is in [this github repository](https://github.com/aurora-is-near/rainbow-bridge) and is supported by [Aurora-labs](https://github.com/aurora-is-near).

It recently provided support for ETH 2.0 in this [Pull Request (762)](https://github.com/aurora-is-near/rainbow-bridge/pull/762).

It interacts [lighthouse](https://github.com/aurora-is-near/lighthouse) for Ethereum 2.0 Consensus and tree\_hash functions as well as bls signatures.

High Level their architecture is similar to the Horizon Bridge but with some key differences, including but not limited to

* interacting with the beacon chain now for finality `is_correct_finality_update` [see finality-update-verify](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/finality-update-verify/src/lib.rs#L36)
* Updated execution block proof to use the BEACONRPCClient and with an updated merkle tree
  * Design can be found in [PR-762](https://github.com/aurora-is-near/rainbow-bridge/pull/762)

### Approach

Near Rainbow bridge uses a fradu proof approach.

### Proving Mechanisms

#### NEAR to Ethereum watchdog

The [watchdog](https://github.com/aurora-is-near/rainbow-bridge/blob/master/near2eth/watchdog/index.js) runs every 10 seconds and validates blocks on `NearBridge.sol` challenging blocks with incorrect signatures. *Note: It uses [heep-prometheus](https://github.com/aurora-is-near/rainbow-bridge/blob/master/utils/http-prometheus.js) for monitoring and storing block and producer information using `gauges` and `counters`.*

* [watchdog is started](https://github.com/aurora-is-near/rainbow-bridge/blob/master/cli/commands/start/watchdog.js) from the CLI
* [watchdog logic](https://github.com/aurora-is-near/rainbow-bridge/blob/master/near2eth/watchdog/index.js)
  * Initializes monitoring information on `Prometheus`
    * `const httpPrometheus = new HttpPrometheus(this.metricsPort, 'near_bridge_watchdog_')`
    * `const lastBlockVerified = httpPrometheus.gauge('last_block_verified', 'last block that was already verified')`
    * `const totBlockProducers = httpPrometheus.gauge('block_producers', 'number of block producers for current block')`
    * `const incorrectBlocks = httpPrometheus.counter('incorrect_blocks', 'number of incorrect blocks found')`
    * `const challengesSubmitted = httpPrometheus.counter('challenges_submitted', 'number of blocks challenged')`
  * Loops `while (true)`
    * Gets the `bridgeState`
    * Loops through all blockProducers checking their signatures
    * `for (let i = 0; i < numBlockProducers; i++)`
      * Check each signature `this.clientContract.methods.checkBlockProducerSignatureInHead(i).call()`
      * If invalid challenge the signature: `this.clientContract.methods.challenge(this.ethMasterAccount, i).encodeABI()` calls [challenge function](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/NearBridge.sol#L93)
        * `function challenge(address payable receiver, uint signatureIndex) external override pausable(PAUSED_CHALLENGE)`
          * checks block.timestamp is less than lastValidAt `block.timestamp < lastValidAt,`
          * Check if the signature is valid `!checkBlockProducerSignatureInHead(signatureIndex)`
          * slashes the last submitter `balanceOf[lastSubmitter] = balanceOf[lastSubmitter] - lockEthAmount;`
          * resets lastValidAt `lastValidAt = 0;`
          * Refunds half of the funds to the watchdog account `receiver.call{value: lockEthAmount / 2}("");`
      * Sleeps for watchdog Delay seconds `await sleep(watchdogDelay * 1000)`

### Relayer Mechanisms

#### Ethereum to NEAR block propagation flow

Following is a walkthough of block propogation from Ethereum to NEAR. For a better understanding of the technical components see [Appendix A](#appendix-a-ethereum-to-near-block-propagation-components).

* [Light Clients are deployed on Near](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/main.rs#L107):
  * [init\_contract](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/main.rs#L107): The eth2near relayer is called with an argument to initialize the [eth2-client contract](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs)
    * [eth\_client\_contract](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/main.rs#L108): is created using a contract\_wrapper
      * `let mut eth_client_contract = EthClientContract::new(get_eth_contract_wrapper(&config));`
    * [EthClientContract Wrapper](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/contract_wrapper/src/eth_client_contract.rs): creates an instance of [eth2-client contract](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs) with the following arguments
      * `network` - the name of Ethereum network such as `mainnet`, `goerli`, `kiln`, etc.
      * `finalized_execution_header` - the finalized execution header to start initialization with.
      * `finalized_beacon_header` - correspondent finalized beacon header.
      * `current_sync_committee` - sync committee correspondent for finalized block.
      * `next_sync_committee` - sync committee for the next period after period for finalized block.
      * `hashes_gs_threshold` - the maximum number of stored finalized blocks.
      * `max_submitted_block_by_account` - the maximum number of unfinalized blocks which one relay can store in the client's storage.
      * `trusted_signer` - the account address of the trusted signer which is allowed to submit light client updates.
* [Relayer is Created](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/main.rs#L111):
  * [eth2near\_relay](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/main.rs#L111) is created using the following arguments
    * `let mut eth2near_relay = Eth2NearRelay::init(&config, get_eth_client_contract(&config), args.enable_binary_search, args.submit_only_finalized_blocks,);`
* [Relayer is Started](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/main.rs):
  * The relayer is started using `eth2near_relay.run(None);`
  * This executes the [eth2near\_relay run function](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L257) `pub fn run(&mut self, max_iterations: Option<u64>)` which runs until terminated doing using the following loop `while !self.terminate`
    * `self.wait_for_synchronization(),`: gets the sync status
    * `sleep(Duration::from_secs(12));`: waits for 12 seconds
    * `self.get_max_slot_for_submission()`: gets the maximum slot for submission from Ethereum
    * `self.get_last_eth2_slot_on_near`: gets the latest slot propogated from Ethereum to NEAR
    * `if last_eth2_slot_on_near < max_slot_for_submission`: If there are slots to process
      * `self.get_execution_blocks_between(last_eth2_slot_on_near + 1, max_slot_for_submission,),`: Get the execution blocks to be processed
      * `self.submit_execution_blocks(headers, current_slot, &mut last_eth2_slot_on_near)`: submit them
      * `were_submission_on_iter = true;`: flags that there were submissions
    * `were_submission_on_iter |= self.send_light_client_updates_with_checks(last_eth2_slot_on_near);`: send light\_client updates with checks and updates the submission flag to true if if passes. Following is some key logic
      * `self.is_enough_blocks_for_light_client_update`: Checks if there are enough blocks for a light client update
        * `self.send_light_client_updates` calls `send_light_client_update` which
          * `if last_finalized_slot_on_eth >= last_finalized_slot_on_near + self.max_blocks_for_finalization`: checks if the gap is too big (i.e. we are at a new slot) between slot of finalized block on NEAR and ETH. If it is it sends a hand made client update (which will loop getting the new slots sync committees) otherwise it sends a regular client update (which propogates the block headers)
            * `self.send_hand_made_light_client_update(last_finalized_slot_on_near);`
              * `let include_next_sync_committee = BeaconRPCClient::get_period_for_slot (last_finalized_slot_on_near) != BeaconRPCClient::get_period_for_slot(attested_slot);`
            * `self.send_regular_light_client_update(last_finalized_slot_on_eth, last_finalized_slot_on_near,);`
          * `self.send_specific_light_client_update(light_client_update)` is called for both regular and hand made updates.
            * `self.eth_client_contract.is_known_block`: Checks if the block is already known on the Etherum Client Contract on NEAR
            * `self.verify_bls_signature_for_finality_update(&light_client_update)`: Verifies the BLS signatures. This calls `is_correct_finality_update` in `eth2near/finality-update-verify/src/lib.rs` \*
            * `self.eth_client_contract.send_light_client_update(light_client_update.clone())`: Updates the light client with the finalized block
            * `self.beacon_rpc_client.get_block_number_for_slot(types::Slot::new(light_client_update.finality_update.header_update.beacon_header.slot.as_u64())),`: Validates Finalized block number is correct on Ethereum usng the `beacon_rpc_client`.
            * `sleep(Duration::from_secs(self.sleep_time_after_submission_secs));`: sleeps for the configured submission sleep time.
    * `if !were_submission_on_iter {thread::sleep(Duration::from_secs(self.sleep_time_on_sync_secs));}`: if there were submissions sleep for however many seconds were configured for sync sleep time.

#### NEAR to Ethereum block propagation flow

[NEAR Light Client Documentation](https://nomicon.io/ChainSpec/LightClient) gives an overview of how light clients work. At a high level the light client needs to fetch at least one block per [epoch](https://docs.near.org/concepts/basics/epoch) i.e. every 42,200 blocks or approxmiately 12 hours. Also Having the LightClientBlockView for block B is sufficient to be able to verify any statement about state or outcomes in any block in the ancestry of B (including B itself).

The current scripts and codebase indicates that a block would be fetched every 30 seconds with a max delay of 10 seconds. It feels that this would be expensive to update Ethereum so frequently. [NEAR's bridge documentation](https://near.org/bridge/) states *Sending assets from NEAR back to Ethereum currently takes a maximum of sixteen hours (due to Ethereum finality times)*. This seems to align with sending light client updates once per NEAR epoch. The block fetch period is configurable in the relayer.

> The RPC returns the LightClientBlock for the block as far into the future from the last known hash as possible for the light client to still accept it. Specifically, it either returns the last final block of the next epoch, or the last final known block. If there's no newer final block than the one the light client knows about, the RPC returns an empty result.
>
> A standalone light client would bootstrap by requesting next blocks until it receives an empty result, and then periodically request the next light client block.
>
> A smart contract-based light client that enables a bridge to NEAR on a different blockchain naturally cannot request blocks itself. Instead external oracles query the next light client block from one of the full nodes, and submit it to the light client smart contract. The smart contract-based light client performs the same checks described above, so the oracle doesn't need to be trusted.

Block Submitters stake ETH to be allowed to submit blocks which get's slashed if the watchdog identifies blocks with invalid signatures.

*Note: Have not identified how the block submitters are rewarded for submitting blocks. Currently have only identified them locking ETH to be able to submit blocks and being slashed if they submit blocks with invalid signatures.*

* [Light Clients are deployed on Ethereum](https://github.com/aurora-is-near/rainbow-bridge/blob/master/cli/index.js#L518) via the CLI using [eth-contracts.js](https://github.com/aurora-is-near/rainbow-bridge/blob/master/cli/init/eth-contracts.js)
  * [init-eth-ed25519](https://github.com/aurora-is-near/rainbow-bridge/blob/master/cli/index.js#L505): Deploys `Ed25519.sol` see more information under [nearbridge Cryptographic Primitives](#nearbridge-cryptographic-primitives)
  * [init-eth-client](https://github.com/aurora-is-near/rainbow-bridge/blob/master/cli/index.js#L520): Deploys `NearBridge.sol` see more information under [NEAR to Ethereum block propagation components](#near-to-ethereum-block-propagation-components). It takes the following arguments
    * `ethEd25519Address`: The address of the ECDSA signature checker using Ed25519 curve (see [here](https://nbeguier.medium.com/a-real-world-comparison-of-the-ssh-key-algorithms-b26b0b31bfd9))
    * `lockEthAmount`: The amount that `BLOCK_PRODUCERS` need to deposit (in wei)to be able to provide blocks. This amount will be slashed if the block is challenged and proven not to have a valid signature. Default value is 100000000000000000000 WEI = 100 ETH.
    * `lockDuration` : 30 seconds
    * `replaceDuration`: 60 seconds it is passed in nanoseconds, because it is a difference between NEAR timestamps.
    * `ethAdminAddress`: Bridge Administrator Address
    * `0` : Indicates nothing is paused `UNPAUSE_ALL`
  * [init-eth-prover](https://github.com/aurora-is-near/rainbow-bridge/blob/master/cli/index.js#L538): Deploys `NearProver.sol` see more information under [NEAR to Ethereum block propagation components](#near-to-ethereum-block-propagation-components). It takes the following arguments
    * `ethClientAddress`: Interface to `NearBridge.sol`
    * `ethAdminAddress`: Administrator address
    * `0`: paused indicator defaults to `UNPAUSE_ALL = 0`

* [Relayer is Started](https://github.com/aurora-is-near/rainbow-bridge/blob/master/cli/commands/start/near2eth-relay.js)
  * Relayer is started using the following command

    ```
    cli/index.js start near2eth-relay \
    --eth-node-url http://127.0.0.1:8545/ \
    --eth-master-sk 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 \
    --near-node-url https://rpc.testnet.near.org/ \
    --near-network-id testnet \
    --eth-client-address 0xe7f1725e7734ce288f8367e1bb143e90bb3f0512 \
    --eth-use-eip-1559 true \
    --near2eth-relay-max-delay 10 \
    --near2eth-relay-block-select-duration 30 \
    --near2eth-relay-after-submit-delay-ms 1000 \
    --log-verbose true \
    --daemon false
    ```

* [Relayer Logic](https://github.com/aurora-is-near/rainbow-bridge/blob/master/near2eth/near2eth-block-relay/index.js)
  * Loops `while (true)`
    * Get the bridge state (including `currentHeight`, `nextTimestamp`, `nextValidAt`, `numBlockProducers` )
    * Get the `currentBlockHash` the hash of the current untrursted block based on `lastValidAt`
    * Gets the `lastBlock` by calling the NEAR rpc `next_light_client_block` using the hash of last untrusted block `bs58.encode(currentBlockHash)`
    * Get's the `replaceDuration` by `clientContract.methods.replaceDuration().call()` this will be 60 seconds if we deployed `NearBridge.sol` with the default values above
    * Sets `nextValidAt` from the bridge state `web3.utils.toBN(bridgeState.nextValidAt)`
    * Sets `replaceDelay` to 0 then updates it to the `nextTimestamp` + `replaceDuration` - `lastBlock.inner_lite.timestamp` i.e. The new block has to be at least 60 seconds after the current block stored on the light client.
    * Checks the height of the `currentHeight` of the bridge is less than the `lastblock` from the near light client `(bridgeState.currentHeight < lastBlock.inner_lite.height)`
    * Serializes the `lastBlock` using Borsh and check that the block is suitable
    * Checks that the `replaceDelay` has been met, if not sleeps until it has
    * Checks that the Master Account (the one submitting the block) has enough locked ETH (if not tries to deposit more). So that it can be slashed if the block proposed is invalid.
    * Adds the light client block `await clientContract.methods.addLightClientBlock(nextBlockSelection.borshBlock).send`
      * Checks `NearBridge.sol` (the light client) has been initialized
      * Checks `balanceOf[msg.sender] >= lockEthAmount` that the sender has locked enough Eth to allow them to submit blocks
      * Decodes the nearBlock using `Borsh.from(data)` and `borsh.decodeLightClientBlock()`
      * Commis the previous block, or make sure that it is OK to replace it using
        * `lastValidAt = 0;`
        * `blockHashes_[curHeight] = untrustedHash;`
        * `blockMerkleRoots_[curHeight] = untrustedMerkleRoot;`
      * Check that the new block's height is greater than the current one's. `nearBlock.inner_lite.height > curHeight`
      * Check that the new block is from the same epoch as the current one, or from the next one.
      * Check that the new block is signed by more than 2/3 of the validators.
      * If the block is from the next epoch, make sure that the Block producers `next_bps` are supplied and have a correct hash.
      * Add the Block to the Light client
        * Updates untrusted information to this block including `untrustedHeight`, `untrustedTimestamp`, `untrustedHash`, `untrustedMerkleRoot`, `untrustedNextHash`, `untrustedSignatureSet`, `untrustedNextEpoch`
        * If `fromNextEpoch` also update the Block Producers
        * Updates the `lastSubmitter` and `lastValidAt`
    * Cleans up the selected block to prevent submitting the same block again `await sleep(afterSubmitDelayMs)`
    * Sets the HeightGauuges to the correct block height
      * `clientHeightGauge.set(Number(BigInt(bridgeState.currentHeight))`
      * `chainHeightGauge.set(Number(BigInt(lastBlock.inner_lite.height)))`
    * Sleeps for delay calculated from the maximum of the relayer days (10 seconds) and differnce between the current and next block time stamps and `await sleep(1000 * delay)`

### Light Client Functionality

#### Near Rainbow Bridge Ethereum Light Client Walkthrough

The following is a walkthrough of how a transaction executed on Ethereum is propogated to NEAR's [eth2-client](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/near/eth2-client). See [Cryptographic Primitives](#cryptographic-primitives) for more information on the cryptography used. and [Appendix B](#appendix-b-ethereum-light-client-finality-update-verify-components) for verification components.

**At a high level the ethereum light client contract**

* Optionally accepts client updates only from a trusted client
* Can pause functions
* Validates a sync committee exists for the curremt slot
* Validates sync committe has greater than the minimum required sync committee members
* Validates 2/3 or more of the committe members have signed the blocks
* Validates bls signatures (i.e. the bls signatures of the sync comittee for the blocks propogated)
* Stores the hashes of the blocks for the past `hashes_gc_threshold` headers. Events that happen past this threshold cannot be verified by the client. It is desirable that this number is larger than 7 days' worth of headers, which is roughly 51k Ethereum blocks. So this number should be 51k in production.
* Stores the Ethereum Network (e.g. mainnet, kiln)
* Stores Hashes of the finalized execution blocks mapped to their numbers.
* Stores All unfinalized execution blocks' headers hashes mapped to their `HeaderInfo`.
* Stores `AccountId`s mapped to their number of submitted headers.
* Stores Max number of unfinalized blocks allowed to be stored by one submitter account. This value should be at least 32 blocks (1 epoch), but the recommended value is 1024 (32 epochs)
* Stores minimum balance that should be attached to register a new submitter account.
* Stores finalized beacon header
* Stores finalized execution header
* Stores current\_sync\_committee
* Stores next\_sync\_committee

#### Near Rainbow Bridge Near Light Client Walkthrough

The following is a walkthrough of how a transaction executed on NEAR is propogated to Ethereum's [nearbridge](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearbridge). See [nearbridge Cryptographic Primitives](#nearbridge-cryptographic-primitives) for more information on the cryptography used.

**NearOnEthClient Overview**

*The following is an excerpt from a blog by near on [eth-near-rainbow-bridge](https://near.org/blog/eth-near-rainbow-bridge/)*

> NearOnEthClient is an implementation of the NEAR light client in Solidity as an Ethereum contract. Unlike EthOnNearClient it does not need to verify every single NEAR header and can skip most of them as long as it verifies at least one header per NEAR epoch, which is about 43k blocks and lasts about half a day. As a result, NearOnEthClient can memorize hashes of all submitted NEAR headers in history, so if you are making a transfer from NEAR to Ethereum and it gets interrupted you don’t need to worry and you can resume it any time, even months later. Another useful property of the NEAR light client is that every NEAR header contains a root of the merkle tree computed from all headers before it. As a result, if you have one NEAR header you can efficiently verify any event that happened in any header before it.
>
> Another useful property of the NEAR light client is that it only accepts final blocks, and final blocks cannot leave the canonical chain in NEAR. This means that NearOnEthClient does not need to worry about forks.
>
> However, unfortunately, NEAR uses [Ed25519](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-665.mdx) to sign messages of the validators who approve the blocks, and this signature is not available as an EVM precompile. It makes verification of all signatures of a single NEAR header prohibitively expensive. So technically, we cannot verify one NEAR header within one contract call to NearOnEthClient. Therefore we adopt the [optimistic approach](https://medium.com/@deaneigenmann/optimistic-contracts-fb75efa7ca84) where NearOnEthClient verifies everything in the NEAR header except the signatures. Then anyone can challenge a signature in a submitted header within a 4-hour challenge window. The challenge requires verification of a single Ed25519 signature which would cost about 500k Ethereum gas (expensive, but possible). The user submitting the NEAR header would have to post a bond in Ethereum tokens, and a successful challenge would burn half of the bond and return the other half to the challenger. The bond should be large enough to pay for the gas even if the gas price increases exponentially during the 4 hours. For instance, a 20 ETH bond would cover gas price hikes up to 20000 Gwei. This optimistic approach requires having a watchdog service that monitors submitted NEAR headers and challenges any headers with invalid signatures. For added security, independent users can run several watchdog services.
>
> Once EIP665 is accepted, Ethereum will have the Ed25519 signature available as an EVM precompile. This will make watchdog services and the 4-hour challenge window unnecessary.
>
> At its bare minimum, Rainbow Bridge consists of EthOnNearClient and NearOnEthClient contracts, and three services: Eth2NearRelay, Near2EthRelay, and the Watchdog. We might argue that this already constitutes a bridge since we have established a cryptographic link between two blockchains, but practically speaking it requires a large portion of additional code to make application developers even consider using the Rainbow Bridge for their applications.

*The following information on sending assets from NEAR back to Ethereum is an excerpt from [https://near.org/bridge/](https://near.org/bridge/).*

> Sending assets from NEAR back to Ethereum currently takes a maximum of sixteen hours (due to Ethereum finality times) and costs around $60 (due to ETH gas costs and at current ETH price). These costs and speeds will improve in the near future.

### Token Lockers

#### Token Transfer Process Flow

The [NEAR Rainbow Bridge](https://near.org/bridge/) uses ERC-20 connectors which are developed in [rainbow-token-connector](https://github.com/aurora-is-near/rainbow-token-connector) and [rainbow-bridge-client](https://github.com/aurora-is-near/rainbow-bridge-client). Also see [eth2near-fun-transfer.md](https://github.com/aurora-is-near/rainbow-bridge/blob/master/docs/workflows/eth2near-fun-transfer.mdx).

Following is an overview of timing and anticipated costs

* Once on NEAR, transactions will confirm in 1-2 seconds and cost well under $1 in most cases.
* Since the Bridge requires transactions on Ethereum for NEAR and Ethereum, the following costs are expected.
* Sending assets from Ethereum to NEAR takes about six minutes (20 blocks) and for ERC-20 costs about $10 on average.
* Sending assets from NEAR back to Ethereum currently takes a maximum of sixteen hours (due to Ethereum finality times) and costs around $60 (due to ETH gas costs and at current ETH price). These costs and speeds will improve in the near future.

*Note: This uses Ethreum [ERC20](https://eips.ethereum.org/EIPS/eip-20) and NEAR [NEP-141](https://nomicon.io/Standards/Tokens/FungibleToken/Core) initally developed for [NEP-21](https://github.com/near/NEPs/pull/21)*

**[Generic ERC-20/NEP-141 connector for Rainbow Bridge](https://github.com/aurora-is-near/rainbow-token-connector/blob/master/README.mdx)**

**Specification**

**Ethereum's side**

```solidity
contract ERC20Locker {
  constructor(bytes memory nearTokenFactory, INearProver prover) public;
  function lockToken(IERC20 token, uint256 amount, string memory accountId) public;
  function unlockToken(bytes memory proofData, uint64 proofBlockHeader) public;
}
```

**NEAR's side**

```rust
struct BridgeTokenFactory {
    /// The account of the prover that we can use to prove
    pub prover_account: AccountId,
    /// Address of the Ethereum locker contract.
    pub locker_address: [u8; 20],
    /// Hashes of the events that were already used.
    pub used_events: UnorderedSet<Vec<u8>>,
    /// Mapping from Ethereum tokens to NEAR tokens.
    pub tokens: UnorderedMap<EvmAddress, AccountId>;
}

impl BridgeTokenFactory {
    /// Initializes the contract.
    /// `prover_account`: NEAR account of the Near Prover contract;
    /// `locker_address`: Ethereum address of the locker contract, in hex.
    #[init]
    pub fn new(prover_account: AccountId, locker_address: String) -> Self;

    /// Relays the lock event from Ethereum.
    /// Uses prover to validate that proof is correct and relies on a canonical Ethereum chain.
    /// Send `mint` action to the token that is specified in the proof.
    #[payable]
    pub fn deposit(&mut self, proof: Proof);

    /// A callback from BridgeToken contract deployed under this factory.
    /// Is called after tokens are burned there to create an receipt result `(amount, token_address, recipient_address)` for Ethereum to unlock the token.
    pub fn finish_withdraw(token_account: AccountId, amount: Balance, recipient: EvmAddress);

    /// Transfers given NEP-21 token from `predecessor_id` to factory to lock.
    /// On success, leaves a receipt result `(amount, token_address, recipient_address)`.
    #[payable]
    pub fn lock(&mut self, token: AccountId, amount: Balance, recipient: String);

    /// Relays the unlock event from Ethereum.
    /// Uses prover to validate that proof is correct and relies on a canonical Ethereum chain.
    /// Uses NEP-21 `transfer` action to move funds to `recipient` account.
    #[payable]
    pub fn unlock(&mut self, proof: Proof);

    /// Deploys BridgeToken contract for the given EVM address in hex code.
    /// The name of new NEP21 compatible contract will be <hex(evm_address)>.<current_id>.
    /// Expects ~35N attached to cover storage for BridgeToken.
    #[payable]
    pub fn deploy_bridge_token(address: String);

    /// Checks if Bridge Token has been successfully deployed with `deploy_bridge_token`.
    /// On success, returns the name of NEP21 contract associated with given address (<hex(evm_address)>.<current_id>).
    /// Otherwise, returns "token do not exists" error.
    pub fn get_bridge_token_account_id(&self, address: String) -> AccountId;
}

struct BridgeToken {
   controller: AccountId,
   token: Token, // uses https://github.com/ilblackdragon/balancer-near/tree/master/near-lib-rs
}

impl BridgeToken {
    /// Setup the Token contract with given factory/controller.
    pub fn new(controller: AccountId) -> Self;

    /// Mint tokens to given user. Only can be called by the controller.
    pub fn mint(&mut self, account_id: AccountId, amount: Balance);

    /// Withdraw tokens from this contract.
    /// Burns sender's tokens and calls controller to create event for relaying.
    pub fn withdraw(&mut self, amount: U128, recipient: String) -> Promise;
}

impl FungibleToken for BridgeToken {
   // see example https://github.com/ilblackdragon/balancer-near/blob/master/balancer-pool/src/lib.rs#L329
}
```

**Setup new ERC-20 on NEAR**

To setup token contract on NEAR side, anyone can call `<bridge_token_factory>.deploy_bridge_token(<erc20>)` where `<erc20>` is the address of the token.
With this call must attach the amount of $NEAR to cover storage for (at least 30 $NEAR currently).

This will create `<<hex(erc20)>.<bridge_token_factory>>` NEP141-compatible contract.

**Usage flow Ethereum -> NEAR**

1. User sends `<erc20>.approve(<erc20locker>, <amount>)` Ethereum transaction.
2. User sends `<erc20locker>.lock(<erc20>, <amount>, <destination>)` Ethereum transaction. This transaction will create `Locked` event.
3. Relayers will be sending Ethereum blocks to the `EthClient` on NEAR side.
4. After sufficient number of confirmations on top of the mined Ethereum block that contain the `lock` transaction, user or relayer can call `BridgeTokenFactory.deposit(proof)`. Proof is the extracted information from the event on Ethereum side.
5. `BridgeTokenFactory.deposit` function will call `EthProver` and verify that proof is correct and relies on a block with sufficient number of confirmations.
6. `EthProver` will return callback to `BridgeTokenFactory` confirming that proof is correct.
7. `BridgeTokenFactory` will call `<<hex(erc20)>.<bridge_token_factory>>.mint(<near_account_id>, <amount>)`.
8. User can use `<<hex(erc20)>.<bridge_token_factory>>` token in other applications now on NEAR.

**Usage flow NEAR -> Ethereum**

1. `token-locker` locks NEP141 tokens on NEAR side.

To deposit funds into the locker, call `ft_transfer_call` where `msg` contains Ethereum address the funds should arrive to.
This will emit `<token: String, amount: u128, recipient address: EthAddress>` (which arrives to `deposit` on Ethereum side).

Accepts `Unlock(token: String, sender_id: EthAddress, amount: u256, recipient: String)` event from Ethereum side with a proof, verifies its correctness.
If `recipient` contains ':' will split it into `<recipient, msg>` and do `ft_transfer_call(recipient, amount, None, msg)`. Otherwise will `ft_transfer` to `recipient`.

To get metadata of token to Ethereum, need to call `log_metadata`, which will create a result `<token: String, name: String, symbol: String, decimals: u8, blockHeight: u64>`.

2. `erc20-bridge-token` - `BridgeTokenFactory` and `BridgeToken` Ethereum contracts.

`BridgeTokenFactory` creates new `BridgeToken` that correspond to specific token account id on NEAR side.

`BridgeTokenFactory` receives `deposit` with proof from NEAR, verify them and mint appropriate amounts on recipient addresses.

Calling `withdraw` will burn tokens of this user and will generate event `<token: String, sender_id: EthAddress, amount: u256, recipient: String>` that can be relayed to `token-factory`.

**Caveats**

Generally, this connector allows any account to call `ft_transfer_call` opening for potential malicious tokens to be bridged to Ethereum.
The expectation here is that on Ethereum side, the token lists will handle this, as it's the same attack model as malicious tokens on Uniswap and other DEXs.

Using Ethereum `BridgeTokenFactory` contract can always resolve Ethereum address of a contract back to NEAR one to check that it is indeed bridging token from NEAR and is created by this factory.

**Testing**

Testing Ethereum side

```
cd erc20-connector
yarn
yarn run test
```

Testing NEAR side

```
make res/bridge_token_factory.wasm
cargo test --all
```

### Multi-chain support

### Economics

### References

* Ethereum 2.0 Specifications
  * [Beacon Chain Specification](https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.mdx)
  * [Extended light client protocol](https://notes.ethereum.org/@vbuterin/extended_light_client_protocol)
  * [Altair Light Client -- Light Client](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/light-client.mdx)
  * [Altair Light Client -- Sync Protocol](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.mdx)
  * [Beacon Chain Fork Choice](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/fork-choice.mdx)

* Proving Mechanisms
  * [Lighthouse Documentation](https://lighthouse-book.sigmaprime.io/): ETH 2.0 Consensus Client Lighthouse documentation
  * [Lighthouse Github](https://github.com/sigp/lighthouse): ETH 2.0 Consensus Client Lighthouse Github
  * [Lighthouse: Blog](https://lighthouse-blog.sigmaprime.io/): ETH 2.0 Consensus Client Lighthouse Blog
  * [eth2near-block-relay-rs](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/eth2near-block-relay-rs)
  * [nearbridge contracts](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearbridge)
  * [nearprover contracts](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearprover)

* Prysm Light Client Work
  * [Prysm: Light-client (WORK IN PROGRESS)](https://github.com/jinfwhuang/prysm/pull/5)
  * [Prysm: Light-client Client WIP](https://github.com/jinfwhuang/prysm/tree/jin-light/cmd/light-client#light-client-client): An independent light client client
  * [Prysm: light-client server PR](https://github.com/prysmaticlabs/prysm/pull/10034): a feature PR that implements the basic production level changes to Prysm to comply as a light-client server to begin serving light client requests

* Harmony Merkle Mount Range
  * Harmony [MMR PR Review](https://github.com/harmony-one/harmony/pull/3872) and [latest PR](https://github.com/harmony-one/harmony/pull/4198/files) uses Merkle Mountain Ranges to facilitate light client development against Harmony's sharded Proof of Stake Chain

### Appendices

#### Appendix A - Ethereum to NEAR block propagation components

* [EthClientContract Wrapper](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/contract_wrapper/src/eth_client_contract.rs): supports [eth2-client contract](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs) functions `impl EthClientContractTrait for EthClientContract`
  * `fn get_last_submitted_slot(&self) -> u64`
  * `fn is_known_block(&self, execution_block_hash: &H256) -> Result<bool, Box<dyn Error>>`
  * `fn send_light_client_update(&mut self, light_client_update: LightClientUpdate,) -> Result<FinalExecutionOutcomeView, Box<dyn Error>>`
  * `fn get_finalized_beacon_block_hash(&self) -> Result<H256, Box<dyn Error>>`
  * `fn get_finalized_beacon_block_slot(&self) -> Result<u64, Box<dyn Error>>`
  * `fn send_headers(&mut self, headers: &[BlockHeader], end_slot: u64,) -> Result<FinalExecutionOutcomeView, Box<dyn std::error::Error>>`
  * `fn get_min_deposit(&self) -> Result<Balance, Box<dyn Error>>`
  * `fn register_submitter(&self) -> Result<FinalExecutionOutcomeView, Box<dyn Error>>`
  * `fn is_submitter_registered(&self,account_id: Option<AccountId>,) -> Result<bool, Box<dyn Error>>`
  * `fn get_light_client_state(&self) -> Result<LightClientState, Box<dyn Error>>`
  * `fn get_num_of_submitted_blocks_by_account(&self) -> Result<u32, Box<dyn Error>>`
  * `fn get_max_submitted_blocks_by_account(&self) -> Result<u32, Box<dyn Error>>`

* [eth2-client contract storage](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs):
  * High level storage overview
  * provides the `Eth2Client` public data stucture

    ```
    pub struct Eth2Client {
        /// If set, only light client updates by the trusted signer will be accepted
        trusted_signer: Option<AccountId>,
        /// Mask determining all paused functions
        paused: Mask,
        /// Whether the client validates the updates.
        /// Should only be set to `false` for debugging, testing, and diagnostic purposes
        validate_updates: bool,
        /// Whether the client verifies BLS signatures.
        verify_bls_signatures: bool,
        /// We store the hashes of the blocks for the past `hashes_gc_threshold` headers.
        /// Events that happen past this threshold cannot be verified by the client.
        /// It is desirable that this number is larger than 7 days' worth of headers, which is roughly
        /// 51k Ethereum blocks. So this number should be 51k in production.
        hashes_gc_threshold: u64,
        /// Network. e.g. mainnet, kiln
        network: Network,
        /// Hashes of the finalized execution blocks mapped to their numbers. Stores up to `hashes_gc_threshold` entries.
        /// Execution block number -> execution block hash
        finalized_execution_blocks: LookupMap<u64, H256>,
        /// All unfinalized execution blocks' headers hashes mapped to their `HeaderInfo`.
        /// Execution block hash -> ExecutionHeaderInfo object
        unfinalized_headers: UnorderedMap<H256, ExecutionHeaderInfo>,
        /// `AccountId`s mapped to their number of submitted headers.
        /// Submitter account -> Num of submitted headers
        submitters: LookupMap<AccountId, u32>,
        /// Max number of unfinalized blocks allowed to be stored by one submitter account
        /// This value should be at least 32 blocks (1 epoch), but the recommended value is 1024 (32 epochs)
        max_submitted_blocks_by_account: u32,
        // The minimum balance that should be attached to register a new submitter account
        min_storage_balance_for_submitter: Balance,
        /// Light client state
        finalized_beacon_header: ExtendedBeaconBlockHeader,
        finalized_execution_header: LazyOption<ExecutionHeaderInfo>,
        current_sync_committee: LazyOption<SyncCommittee>,
        next_sync_committee: LazyOption<SyncCommittee>,
    }
    ```

* [eth2-client dependencies](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/Cargo.toml) relys heavily on the [lighthouse](https://github.com/aurora-is-near/lighthouse) codebase for it's consensus and cryptogrphic primitives. See [Cryptographic Primitives](#cryptographic-primitives) for more information.
  * `ethereum-types = "0.9.2"`
  * `eth-types =  { path = "../eth-types" }`
  * `eth2-utility =  { path = "../eth2-utility" }`
  * `tree_hash = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }`
  * `merkle_proof = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }`
  * `bls = { git = "https://github.com/aurora-is-near/lighthouse.git", optional = true, rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec", default-features = false, features = ["milagro"]}`
  * `admin-controlled =  { path = "../admin-controlled" }`
  * `near-sdk = "4.0.0"`
  * `borsh = "0.9.3"`
  * `bitvec = "1.0.0"`

* [eth2-client contract functions](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs): provides the following functions in `impl Eth2Client`
  * `fn validate_light_client_update(&self, update: &LightClientUpdate)`
  * `fn verify_finality_branch(&self, update: &LightClientUpdate, finalized_period: u64)`
  * `fn verify_bls_signatures(&self, update: &LightClientUpdate, sync_committee_bits: BitVec<u8>, finalized_period: u64,)`
  * `fn update_finalized_header(&mut self, finalized_header: ExtendedBeaconBlockHeader)`
  * `fn commit_light_client_update(&mut self, update: LightClientUpdate)`
  * `fn gc_finalized_execution_blocks(&mut self, mut header_number: u64)`
  * `fn update_submitter(&mut self, submitter: &AccountId, value: i64)`
  * `fn is_light_client_update_allowed(&self)`

* [Eth2NearRelay](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L84): has the following public structure

  ```
  pub struct Eth2NearRelay {
      beacon_rpc_client: BeaconRPCClient,
      eth1_rpc_client: Eth1RPCClient,
      near_rpc_client: NearRPCClient,
      eth_client_contract: Box<dyn EthClientContractTrait>,
      headers_batch_size: u64,
      ethereum_network: String,
      interval_between_light_client_updates_submission_in_epochs: u64,
      max_blocks_for_finalization: u64,
      near_network_name: String,
      last_slot_searcher: LastSlotSearcher,
      terminate: bool,
      submit_only_finalized_blocks: bool,
      next_light_client_update: Option<LightClientUpdate>,
      sleep_time_on_sync_secs: u64,
      sleep_time_after_submission_secs: u64,
      max_submitted_blocks_by_account: u32,
  }
  ```

* [Eth2NearRelay](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L103): Implements the following functions
  * `fn get_max_slot_for_submission(&self) -> Result<u64, Box<dyn Error>>`
  * `fn get_last_eth2_slot_on_near(&mut self, max_slot: u64) -> Result<u64, Box<dyn Error>>`
  * `fn get_last_finalized_slot_on_near(&self) -> Result<u64, Box<dyn Error>>`
  * `fn get_last_finalized_slot_on_eth(&self) -> Result<u64, Box<dyn Error>>`
  * **`pub fn run(&mut self, max_iterations: Option<u64>)`**
  * `fn wait_for_synchronization(&self) -> Result<(), Box<dyn Error>>`
  * `fn get_light_client_update_from_file(config: &Config, beacon_rpc_client: &BeaconRPCClient,) -> Result<Option<LightClientUpdate>, Box<dyn Error>>`
  * `fn set_terminate(&mut self, iter_id: u64, max_iterations: Option<u64>)`
  * `fn get_execution_blocks_between(&self, start_slot: u64, last_eth2_slot_on_eth_chain: u64,) -> Result<(Vec<BlockHeader>, u64), Box<dyn Error>>`
  * `fn submit_execution_blocks(&mut self, headers: Vec<BlockHeader>, current_slot: u64,last_eth2_slot_on_near: &mut u64,)`
  * `fn verify_bls_signature_for_finality_update(&mut self, light_client_update: &LightClientUpdate,) -> Result<bool, Box<dyn Error>>`
  * `fn get_execution_block_by_slot(&self, slot: u64) -> Result<BlockHeader, Box<dyn Error>>`

* [Eth2NearRelay](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L461): has a second implementation of functions for submitting light client updates
  * `fn is_enough_blocks_for_light_client_update(&self, last_submitted_slot: u64,last_finalized_slot_on_near: u64, last_finalized_slot_on_eth: u64,) -> bool`
  * `fn is_shot_run_mode(&self) -> bool`
  * `fn send_light_client_updates_with_checks(&mut self, last_submitted_slot: u64) -> bool`
  * `fn send_light_client_updates(&mut self, last_submitted_slot: u64, last_finalized_slot_on_near: u64, last_finalized_slot_on_eth: u64,)`
  * `fn send_light_client_update_from_file(&mut self, last_submitted_slot: u64)`
  * `fn send_regular_light_client_update(&mut self, last_finalized_slot_on_eth: u64,last_finalized_slot_on_near: u64,)`
  * `fn get_attested_slot(&mut self, last_finalized_slot_on_near: u64,) -> Result<u64, Box<dyn Error>>`
  * `fn send_hand_made_light_client_update(&mut self, last_finalized_slot_on_near: u64)`
  * `fn send_specific_light_client_update(&mut self, light_client_update: LightClientUpdate)`

* [eth2-contract-init](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/eth2-contract-init) includes (but not limited to) the following additional components
  * [init\_contract.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2-contract-init/src/init_contract.rs): Verifies light client snapshot and initializes the Ethereum Light Contract on Near.
    * `pub fn verify_light_client_snapshot(block_root: String, light_client_snapshot: &LightClientSnapshotWithProof,) -> bool`: Verifies the light client by checking the snapshot format getting the current consensus branch and verifying it via a merkle proof.
    * `pub fn init_contract(config: &Config, eth_client_contract: &mut EthClientContract, mut init_block_root: String,) -> Result<(), Box<dyn std::error::Error>>`: Initializes the Ethereum Light Client Contract on Near.

* [eth\_rpc\_client](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/eth_rpc_client) includes (but not limited to) the following additional components
  * [eth1\_rpc\_client.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth1_rpc_client.rs): Is used to get block headers and check sync status. It has the following functions
    * `pub fn new(endpoint_url: &str) -> Self`
    * `pub fn get_block_header_by_number(&self, number: u64) -> Result<BlockHeader, Box<dyn Error>>`
    * `pub fn is_syncing(&self) -> Result<bool, Box<dyn Error>>`
  * [execution\_block\_proof.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/execution_block_proof.rs): `ExecutionBlockProof` contains a `block_hash` (execution block) and a proof of its inclusion in the `BeaconBlockBody` tree hash. The `block_hash` is the 12th field in execution\_payload, which is the 9th field in `BeaconBlockBody`. The first 4 elements in proof correspondent to the proof of inclusion of `block_hash` in Merkle tree built for `ExecutionPayload`. The last 4 elements of the proof of `ExecutionPayload` in the Merkle tree are built on high-level `BeaconBlockBody` fields. The proof starts from the leaf. It has the following structure and functions
    * `pub struct ExecutionBlockProof {block_hash: H256, proof: [H256; Self::PROOF_SIZE],}`
    * `pub fn construct_from_raw_data(block_hash: &H256, proof: &[H256; Self::PROOF_SIZE]) -> Self`
    * `pub fn construct_from_beacon_block_body(beacon_block_body: &BeaconBlockBody<MainnetEthSpec>,) -> Result<Self, Box<dyn Error>>`
    * `pub fn get_proof(&self) -> [H256; Self::PROOF_SIZE]`
    * `pub fn get_execution_block_hash(&self) -> H256`
    * `pub fn verify_proof_for_hash(&self, beacon_block_body_hash: &H256,) -> Result<bool, IncorrectBranchLength>`
    * `fn merkle_root_from_branch(leaf: H256, branch: &[H256], depth: usize, index: usize,) -> Result<H256, IncorrectBranchLength>`
  * [beacon\_block\_body\_merkle\_tree.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth_rpc_client/src/beacon_block_body_merkle_tree.rs): implements merkle trees for the Beacon and the ExecutionPayload
    * `BeaconBlockBodyMerkleTree` is built on the `BeaconBlockBody` data structure, where the leaves of the Merkle Tree are the hashes of the high-level fields of the `BeaconBlockBody`. The hashes of each element are produced by using `ssz` serialization.
    * `ExecutionPayloadMerkleTree` is a built on the `ExecutionPayload` data structure, where the leaves of the Merkle Tree are the hashes of the high-level fields of the `ExecutionPayload`. The hashes of each element are produced by using `ssz` serialization. `ExecutionPayload` is one of the field in BeaconBlockBody. The hash of the root of `ExecutionPlayloadMerkleTree` is the 9th leaf in BeaconBlockBody Merkle Tree.
  * [beacon\_rpc\_client.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth_rpc_client/src/beacon_rpc_client.rs): allows getting beacon block body, beacon block header and light client updates using [Beacon RPC API](https://ethereum.github.io/beacon-APIs/). It has the following functions
    * `pub fn new(endpoint_url: &str, timeout_seconds: u64, timeout_state_seconds: u64) -> Self`: Creates `BeaconRPCClient` for the given BeaconAPI `endpoint_url`
    * `pub fn get_beacon_block_body_for_block_id(&self, block_id: &str,) -> Result<BeaconBlockBody<MainnetEthSpec>, Box<dyn Error>>`: Returns `BeaconBlockBody` struct for the given `block_id`. It uses the following arguments
      * `block_id` - Block identifier. Can be one of: `"head" (canonical head in node's view),"genesis", "finalized", <slot>, <hex encoded blockRoot with 0x prefix>`(see [beacon-APIs/#/Beacon/getBlockV2](https://ethereum.github.io/beacon-APIs/#/Beacon/getBlockV2)).
    * `pub fn get_beacon_block_header_for_block_id(&self, block_id: &str,) -> Result<types::BeaconBlockHeader, Box<dyn Error>>`: Returns `BeaconBlockHeader` struct for the given `block_id`. It uses the following arguments
      * `block_id` - Block identifier. Can be one of: `"head" (canonical head in node's view),"genesis", "finalized", <slot>, <hex encoded blockRoot with 0x prefix>`(see [beacon-APIs/#/Beacon/getBlockV2](https://ethereum.github.io/beacon-APIs/#/Beacon/getBlockV2)).
    * `pub fn get_light_client_update(&self, period: u64,) -> Result<LightClientUpdate, Box<dyn Error>>`: Returns `LightClientUpdate` struct for the given `period`. It uses the following arguments
      * `period` - period id for which `LightClientUpdate` is fetched. On Mainnet, one period consists of 256 epochs, and one epoch consists of 32 slots
    * `pub fn get_bootstrap(&self, block_root: String,) -> Result<LightClientSnapshotWithProof, Box<dyn Error>>`: Fetch a bootstrapping state with a proof to a trusted block root. The trusted block root should be fetched with similar means to a weak subjectivity checkpoint. Only block roots for checkpoints are guaranteed to be available.
    * `pub fn get_checkpoint_root(&self) -> Result<String, Box<dyn Error>>`
    * `pub fn get_last_finalized_slot_number(&self) -> Result<types::Slot, Box<dyn Error>>`: Return the last finalized slot in the Beacon chain
    * `pub fn get_last_slot_number(&self) -> Result<types::Slot, Box<dyn Error>>`: Return the last slot in the Beacon chain
    * `pub fn get_slot_by_beacon_block_root(&self, beacon_block_hash: H256,) -> Result<u64, Box<dyn Error>>`
    * `pub fn get_block_number_for_slot(&self, slot: types::Slot) -> Result<u64, Box<dyn Error>>`
    * `pub fn get_finality_light_client_update(&self) -> Result<LightClientUpdate, Box<dyn Error>>`
    * `pub fn get_finality_light_client_update_with_sync_commity_update(&self,) -> Result<LightClientUpdate, Box<dyn Error>>`
    * `pub fn get_beacon_state(&self, state_id: &str,) -> Result<BeaconState<MainnetEthSpec>, Box<dyn Error>>`
    * `pub fn is_syncing(&self) -> Result<bool, Box<dyn Error>>`
    * `fn get_json_from_client(client: &Client, url: &str) -> Result<String, Box<dyn Error>>`
    * `fn get_json_from_raw_request(&self, url: &str) -> Result<String, Box<dyn Error>>`
    * `fn get_body_json_from_rpc_result(block_json_str: &str,) -> Result<std::string::String, Box<dyn Error>>`
    * `fn get_header_json_from_rpc_result(json_str: &str,) -> Result<std::string::String, Box<dyn Error>>`
    * `fn get_attested_header_from_light_client_update_json_str(light_client_update_json_str: &str,) -> Result<BeaconBlockHeader, Box<dyn Error>>`
    * `fn get_sync_aggregate_from_light_client_update_json_str(light_client_update_json_str: &str,) -> Result<SyncAggregate, Box<dyn Error>>`
    * `fn get_signature_slot(&self, light_client_update_json_str: &str,) -> Result<Slot, Box<dyn Error>>`: `signature_slot` is not provided in the current API. The slot is brute-forced until `SyncAggregate` in `BeconBlockBody` in the current slot is equal to `SyncAggregate` in `LightClientUpdate`
    * `fn get_finality_update_from_light_client_update_json_str(&self, light_client_update_json_str: &str,) -> Result<FinalizedHeaderUpdate, Box<dyn Error>>`
    * `fn get_sync_committee_update_from_light_client_update_json_str(light_client_update_json_str: &str,) -> Result<SyncCommitteeUpdate, Box<dyn Error>>`
    * `pub fn get_period_for_slot(slot: u64) -> u64`
    * `pub fn get_non_empty_beacon_block_header(&self, start_slot: u64,) -> Result<types::BeaconBlockHeader, Box<dyn Error>>`
    * `fn check_block_found_for_slot(&self, json_str: &str) -> Result<(), Box<dyn Error>>`
  * [hand\_made\_finality\_light\_client\_update.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth_rpc_client/src/hand_made_finality_light_client_update.rs): Has two implementations
    * The first implementation which calls functions in the second
      * `pub fn get_finality_light_client_update(beacon_rpc_client: &BeaconRPCClient, attested_slot: u64, include_next_sync_committee: bool,) -> Result<LightClientUpdate, Box<dyn Error>>`
      * `pub fn get_finality_light_client_update_from_file(beacon_rpc_client: &BeaconRPCClient, file_name: &str,) -> Result<LightClientUpdate, Box<dyn Error>>`
      * `pub fn get_light_client_update_from_file_with_next_sync_committee(beacon_rpc_client: &BeaconRPCClient, attested_state_file_name: &str, finality_state_file_name: &str,) -> Result<LightClientUpdate, Box<dyn Error>>`
    * The second implementation
      * `fn get_attested_slot_with_enough_sync_committee_bits_sum(beacon_rpc_client: &BeaconRPCClient,attested_slot: u64,) -> Result<(u64, u64), Box<dyn Error>>`
      * `fn get_state_from_file(file_name: &str) -> Result<BeaconState<MainnetEthSpec>, Box<dyn Error>>`
      * `fn get_finality_light_client_update_for_state(beacon_rpc_client: &BeaconRPCClient,attested_slot: u64, signature_slot: u64, beacon_state: BeaconState<MainnetEthSpec>, finality_beacon_state: Option<BeaconState<MainnetEthSpec>>,) -> Result<LightClientUpdate, Box<dyn Error>>`
      * `fn get_next_sync_committee(beacon_state: &BeaconState<MainnetEthSpec>,) -> Result<SyncCommitteeUpdate, Box<dyn Error>>`
      * `fn from_lighthouse_beacon_header(beacon_header: &BeaconBlockHeader,) -> eth_types::eth2::BeaconBlockHeader`
      * `fn get_sync_committee_bits(sync_committee_signature: &types::SyncAggregate<MainnetEthSpec>,) -> Result<[u8; 64], Box<dyn Error>>`
      * `fn get_finality_branch(beacon_state: &BeaconState<MainnetEthSpec>,) -> Result<Vec<H256>, Box<dyn Error>>`
      * `fn get_finality_update(finality_header: &BeaconBlockHeader, beacon_state: &BeaconState<MainnetEthSpec>, finalized_block_body: &BeaconBlockBody<MainnetEthSpec>,) -> Result<FinalizedHeaderUpdate, Box<dyn Error>>`
  * [light\_client\_snapshot\_with\_proof.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth_rpc_client/src/light_client_snapshot_with_proof.rs): contains the structure for `LightClientSnapshotWithProof`

    ```
    pub struct LightClientSnapshotWithProof {
        pub beacon_header: BeaconBlockHeader,
        pub current_sync_committee: SyncCommittee,
        pub current_sync_committee_branch: Vec<H256>,
    }
    ```

* [eth2near-block-relay-rs](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/eth2near-block-relay-rs) includes (but not limited to) the following additional components
  * [config.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/config.rs):
  * [last\_slot\_searcher.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/last_slot_searcher.rs): Implementation of functions for searching last slot on NEAR contract. Supports both binary and linear searches.
    * `pub fn get_last_slot(&mut self, last_eth_slot: u64, beacon_rpc_client: &BeaconRPCClient, eth_client_contract: &Box<dyn EthClientContractTrait>,) -> Result<u64, Box<dyn Error>>`
    * `n binary_slot_search(&self, slot: u64, finalized_slot: u64, last_eth_slot: u64, beacon_rpc_client: &BeaconRPCClient, eth_client_contract: &Box<dyn EthClientContractTrait>,) -> Result<u64, Box<dyn Error>>` : Search for the slot before the first unknown slot on NEAR. Assumptions: (1) start\_slot is known on NEAR (2) last\_slot is unknown on NEAR. Return error in case of problem with network connection.
    * `fn binsearch_slot_forward(&self, slot: u64, max_slot: u64, beacon_rpc_client: &BeaconRPCClient,eth_client_contract: &Box<dyn EthClientContractTrait>,) -> Result<u64, Box<dyn Error>> {`: Search for the slot before the first unknown slot on NEAR. Assumptions: (1) start\_slot is known on NEAR (2) last\_slot is unknown on NEAR. Return error in case of problem with network connection.
    * `fn binsearch_slot_range(&self, start_slot: u64, last_slot: u64, beacon_rpc_client: &BeaconRPCClient, eth_client_contract: &Box<dyn EthClientContractTrait>,) -> Result<u64, Box<dyn Error>>`: Search for the slot before the first unknown slot on NEAR. Assumptions: (1) start\_slot is known on NEAR (2) last\_slot is unknown on NEAR. Return error in case of problem with network connection.
    * `fn linear_slot_search(&self, slot: u64, finalized_slot: u64, last_eth_slot: u64, beacon_rpc_client: &BeaconRPCClient, eth_client_contract: &Box<dyn EthClientContractTrait>,) -> Result<u64, Box<dyn Error>>`: Returns the last slot known with block known on NEAR. `Slot` -- expected last known slot. `finalized_slot` -- last finalized slot on NEAR, assume as known slot. `last_eth_slot` -- head slot on Eth.
    * `fn linear_search_forward(&self, slot: u64, max_slot: u64, beacon_rpc_client: &BeaconRPCClient,eth_client_contract: &Box<dyn EthClientContractTrait>,) -> Result<u64, Box<dyn Error>>`: Returns the slot before the first unknown block on NEAR. The search range is \[slot .. max\_slot). If there is no unknown block in this range max\_slot - 1 will be returned. Assumptions: (1) block for slot is submitted to NEAR. (2) block for max\_slot is not submitted to NEAR.
    * `fn linear_search_backward(&self, start_slot: u64, last_slot: u64, beacon_rpc_client: &BeaconRPCClient, eth_client_contract: &Box<dyn EthClientContractTrait>,) -> Result<u64, Box<dyn Error>>`: Returns the slot before the first unknown block on NEAR. The search range is \[last\_slot .. start\_slot). If no such block are found the start\_slot will be returned. Assumptions: (1) block for start\_slot is submitted to NEAR (2) block for last\_slot + 1 is not submitted to NEAR.
    * `fn find_left_non_error_slot(&self, left_slot: u64, right_slot: u64, step: i8, beacon_rpc_client: &BeaconRPCClient, eth_client_contract: &Box<dyn EthClientContractTrait>,) -> (u64, bool)`: Find the leftmost non-empty slot. Search range: \[left\_slot, right\_slot). Returns pair: (1) slot\_id and (2) is this block already known on Eth client on NEAR. Assume that right\_slot is non-empty and it's block were submitted to NEAR, so if non correspondent block is found we return (right\_slot, false).
    * `fn block_known_on_near( &self, slot: u64, beacon_rpc_client: &BeaconRPCClient,eth_client_contract: &Box<dyn EthClientContractTrait>,) -> Result<bool, Box<dyn Error>>`: Check if the block for current slot in Eth2 already were submitted to NEAR. Returns Error if slot doesn't contain any block.
  * [main.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/main.rs): [Command Line Argument Parser](https://docs.rs/clap/latest/clap/) used to run the Ethereum to Near Block Relay. It contains the following functions
    * `fn get_eth_contract_wrapper(config: &Config) -> Box<dyn ContractWrapper>`
    * `fn get_dao_contract_wrapper(config: &Config) -> Box<dyn ContractWrapper>`
    * `fn get_eth_client_contract(config: &Config) -> Box<dyn EthClientContractTrait>`
    * `fn init_log(args: &Arguments, config: &Config)`
    * `fn main() -> Result<(), Box<dyn std::error::Error>>`
  * [near\_rpc\_client.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/near_rpc_client.rs)
    * `pub fn new(endpoint_url: &str) -> Self`
    * `pub fn check_account_exists(&self, account_id: &str) -> Result<bool, Box<dyn Error>>`
    * `pub fn is_syncing(&self) -> Result<bool, Box<dyn Error>>`

#### Appendix B - Ethereum Light Client Finality Update Verify Components

[finality-update-verify](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/finality-update-verify) is called from [fn verify\_bls\_signature\_for\_finality\_update](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L422) to verify signatures as part of light\_client updates. It relies heavily on the [lighthouse](https://github.com/aurora-is-near/lighthouse) codebase for it's consensus and cryptogrphic primitives. See [Cryptographic Primitives](#cryptographic-primitives) for more information.

* Dependencies in [Cargo.toml](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/finality-update-verify/Cargo.toml)
  * `eth-types = { path ="../../contracts/near/eth-types/", features = ["eip1559"]}`
  * `bls = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }`
  * `eth2-utility  = { path ="../../contracts/near/eth2-utility"}`
  * `tree_hash = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }`
  * `types =  { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }`
  * `bitvec = "1.0.0"`

* Functions in [lib.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/finality-update-verify/src/lib.rs)
  * `fn h256_to_hash256(hash: H256) -> Hash256`
  * `fn tree_hash_h256_to_eth_type_h256(hash: tree_hash::Hash256) -> eth_types::H256`
  * `fn to_lighthouse_beacon_block_header(bridge_beacon_block_header: &BeaconBlockHeader,) -> types::BeaconBlockHeader`
  * `pub fn is_correct_finality_update(ethereum_network: &str, light_client_update: &LightClientUpdate,   sync_committee: SyncCommittee,) -> Result<bool, Box<dyn Error>>`

#### Appendix C - Cryptographic Primitives

Following are cryptographic primitives used in the [eth2-client contract](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/near/eth2-client) and [finality-update-verify](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/finality-update-verify). Many are from the [lighthouse](https://github.com/aurora-is-near/lighthouse) codebase. Specifically [consensus](https://github.com/aurora-is-near/lighthouse/tree/stable/consensus) and [crypto](https://github.com/aurora-is-near/lighthouse/tree/stable/crypto) functions.

Some common primitives

* [bitvec](https://docs.rs/bitvec/1.0.1/bitvec/): Addresses memory by bits, for packed collections and bitfields
* [eth2\_serde\_utils](https://docs.rs/eth2_serde_utils/0.1.0/eth2_serde_utils/): Serialization and deserialization utilities useful for JSON representations of Ethereum 2.0 types.
* [eth2\_hashing](https://docs.rs/eth2_hashing/0.2.0/eth2_hashing/): Hashing primitives used in Ethereum 2.0
* [blst](https://docs.rs/blst/0.3.10/blst/): The blst crate provides a rust interface to the blst BLS12-381 signature library.
* [tree\_hash](https://docs.rs/tree_hash/0.4.0/tree_hash/): Efficient Merkle-hashing as used in Ethereum 2.0
* [eth2\_ssz\_types](https://docs.rs/eth2_ssz_types/0.2.1/ssz_types/): Provides types with unique properties required for SSZ serialization and Merklization.

Some Primitives from Lighthouse

* [bls](https://github.com/aurora-is-near/lighthouse/tree/stable/crypto/bls): [Boneh–Lynn–Shacham](https://en.wikipedia.org/wiki/BLS_digital_signature) digital signature support
  * [impls](https://github.com/aurora-is-near/lighthouse/tree/stable/crypto/bls/src/impls): Implementations
    * [blst](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/impls/blst.rs)
    * [fake\_crypto](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/impls/fake_crypto.rs)
    * [milagro](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/impls/milagro.rs): support for [Apache Milagro](https://milagro.apache.org/docs/milagro-intro/)
    * [functionality](https://github.com/aurora-is-near/lighthouse/tree/stable/crypto/bls/src)
      * [generic\_aggregate\_public\_key](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_aggregate_public_key.rs)
      * [generic\_aggregate\_signature](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_aggregate_signature.rs)
      * [generic\_keypair](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_keypair.rs)
      * [generic\_public\_key](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_public_key.rs)
      * [generic\_public\_key\_bytes](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_public_key_bytes.rs)
      * [generic\_secret\_key](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_secret_key.rs)
      * [generic\_signature](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_signature.rs)
      * [generic\_signature\_bytes](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_signature_bytes.rs)
      * [generic\_signature\_set](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_signature_set.rs)
      * [get\_withdrawal\_credentials](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/get_withdrawal_credentials.rs)
      * [zeroize\_hash](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/zeroize_hash.rs)
* [merkle\_proof](https://github.com/aurora-is-near/lighthouse/tree/stable/consensus/merkle_proof)
* [tree\_hash](https://github.com/aurora-is-near/lighthouse/tree/stable/consensus/tree_hash)
* [types](https://github.com/aurora-is-near/lighthouse/tree/stable/consensus/types/src): Implements Ethereum 2.0 types including but not limited to
  * [attestation](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/attestation.rs)
  * [beacon\_block](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/beacon_block.rs)
  * [beacon\_committee](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/beacon_committee.rs)
  * [beacon\_state](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/beacon_state.rs)
  * [builder\_bid](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/builder_bid.rs)
  * [chain\_spec](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/chain_spec.rs)
  * [checkpoint](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/checkpoint.rs)
  * [contribution\_and\_proof](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/contribution_and_proof.rs): A Validators aggregate sync committee contribution and selection proof.
  * [deposit](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/deposit.rs): A deposit to potentially become a beacon chain validator.
  * [enr\_fork\_id](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/enr_fork_id.rs): Specifies a fork which allows nodes to identify each other on the network. This fork is used in a nodes local ENR.
  * [eth\_spec](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/eth_spec.rs): Ethereum Foundation specifications.
  * [execution\_block\_hash](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/execution_block_hash.rs)
  * [execution\_payload](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/execution_payload.rs)
  * [fork](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/fork.rs): Specifies a fork of the `BeaconChain`, to prevent replay attacks.
  * [free\_attestation](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/free_attestation.rs): Note: this object does not actually exist in the spec. We use it for managing attestations that have not been aggregated.
  * [payload](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/payload.rs)
  * [signed\_aggregate\_and\_proof](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/signed_aggregate_and_proof.rs): A Validators signed aggregate proof to publish on the `beacon_aggregate_and_proof` gossipsub topic.
  * [signed\_beacon\_block](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/signed_beacon_block.rs): A `BeaconBlock` and a signature from its proposer.
  * [slot\_data](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/slot_data.rs): A trait providing a `Slot` getter for messages that are related to a single slot. Useful in making parts of attestation and sync committee processing generic.
  * [slot\_epoch](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/slot_epoch.rs): The `Slot` and `Epoch` types are defined as new types over u64 to enforce type-safety between the two types. Note: Time on Ethereum 2.0 Proof of Stake is divided into slots and epochs. One slot is 12 seconds. One epoch is 6.4 minutes, consisting of 32 slots. One block can be created for each slot.
  * [sync\_aggregate](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/sync_aggregate.rs): Create a `SyncAggregate` from a slice of `SyncCommitteeContribution`s. Equivalent to `process_sync_committee_contributions` from the spec.
  * [sync\_committee](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/sync_committee.rs)
  * [tree\_hash\_impls](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/tree_hash_impls.rs): contains custom implementations of `CachedTreeHash` for ETH2-specific types. It makes some assumptions about the layouts and update patterns of other structs in this crate, and should be updated carefully whenever those structs are changed.
  * [validator](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/validator.rs): Information about a `BeaconChain` validator.

Some Smart Contracts deployed on Ethereum

* [nearprover](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearprover)
  * [ProofDecoder.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearprover/contracts/ProofDecoder.sol)
  * [NearProver.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearprover/contracts/NearProver.sol)
* [nearbridge](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearbridge/contracts)
  * [NearDecoder.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/NearDecoder.sol): handles decoing of Public Keys, Signatures, BlockProducers and LightClientBlocks using `Borsh.sol`
  * [Utils.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Utils.sol): handles reading and writing to memory, memoryToBytes and has functions such as `keccak256Raw` and `sha256Raw`
  * [Borsh.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Borsh.sol): [Borsh](https://borsh.io/): Binary Object Representation Serializer for Hashing. It is meant to be used in security-critical projects as it prioritizes consistency, safety, speed; and comes with a strict specification.
  * [Ed25519.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Ed25519.sol): [Ed25519](https://ed25519.cr.yp.to/) high-speed high-security signatures

Some Primitives from NEAR Rainbow Bridge

* [eth-types](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/near/eth-types): utilities to serialize and encode eth2 types using [borsh](https://borsh.io/) and [rlp](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp).
* [eth2-utility](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/near/eth2-utility): Utility functions used for Ethereum 2.0 Consensus. Functions include
  * `fn from_str(input: &str) -> Result<Network, Self::Err>`
  * `pub fn new(network: &Network) -> Self`
  * `pub fn compute_fork_version(&self, epoch: Epoch) -> Option<ForkVersion>`
  * `pub fn compute_fork_version_by_slot(&self, slot: Slot) -> Option<ForkVersion>`
  * `pub const fn compute_epoch_at_slot(slot: Slot) -> u64`
  * `pub const fn compute_sync_committee_period(slot: Slot) -> u64`
  * `pub const fn floorlog2(x: u32) -> u32`: Compute floor of log2 of a u32.
  * `pub const fn get_subtree_index(generalized_index: u32) -> u32`
  * `pub fn compute_domain(domain_constant: DomainType, fork_version: ForkVersion, genesis_validators_root: H256,) -> H256`
  * `pub fn compute_signing_root(object_root: H256, domain: H256) -> H256`
  * `pub fn get_participant_pubkeys(public_keys: &[PublicKeyBytes], sync_committee_bits: &BitVec<u8, Lsb0>,) -> Vec<PublicKeyBytes>`
  * `pub fn convert_branch(branch: &[H256]) -> Vec<ethereum_types::H256>`
  * `pub fn validate_beacon_block_header_update(header_update: &HeaderUpdate) -> bool`
  * `pub fn calculate_min_storage_balance_for_submitter(max_submitted_blocks_by_account: u32,) -> Balance`

**Nearbridge Cryptographic Primitives**

* [Ed25519.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Ed25519.sol): Solidity implementation of the [Ed25519](https://en.wikipedia.org/wiki/EdDSA) which is the EdDSA signature scheme using SHA-512 (SHA-2) and Curve25519 (see [here](https://nbeguier.medium.com/a-real-world-comparison-of-the-ssh-key-algorithms-b26b0b31bfd9)). It has the following functions
  * `function pow22501(uint256 v) private pure returns (uint256 p22501, uint256 p11)` : Computes (v^(2^250-1), v^11) mod p
  * `function check(bytes32 k, bytes32 r, bytes32 s, bytes32 m1, bytes9 m2)` : has the following steps
    * Step 1: compute SHA-512(R, A, M)
    * Step 2: unpack k
    * Step 3: compute multiples of k
    * Step 4: compute s*G - h*A
    * Step 5: compare the points
* [Utils.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Utils.sol): A set of utilty functions for byte manipulation, memory updates and [keccak](https://keccak.team/keccak_specs_summary.html) functions.
  * `function swapBytes2(uint16 v) internal pure returns (uint16)`
  * `function swapBytes4(uint32 v) internal pure returns (uint32)`
  * `function swapBytes8(uint64 v) internal pure returns (uint64)`
  * `function swapBytes16(uint128 v) internal pure returns (uint128)`
  * `function swapBytes32(uint256 v) internal pure returns (uint256)`
  * `function readMemory(uint ptr) internal pure returns (uint res)`
  * `function writeMemory(uint ptr, uint value) internal pure`
  * `function memoryToBytes(uint ptr, uint length) internal pure returns (bytes memory res)`
  * `function keccak256Raw(uint ptr, uint length) internal pure returns (bytes32 res)`
  * `function sha256Raw(uint ptr, uint length) internal view returns (bytes32 res)`
* [Borsh.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Borsh.sol) provides Binary Object Representation Serializer for Hashing [borsh](https://borsh.io/) functionality and imports `Utils.sols`. Structures and functions include
  * `struct Data {uint ptr; uint end;}`
  * `function from(bytes memory data) internal pure returns (Data memory res)`
  * `function requireSpace(Data memory data, uint length) internal pure`: This function assumes that length is reasonably small, so that data.ptr + length will not overflow. In the current code, length is always less than 2^32.
  * `function read(Data memory data, uint length) internal pure returns (bytes32 res)`
  * `function done(Data memory data) internal pure`
  * `function peekKeccak256(Data memory data, uint length) internal pure returns (bytes32)`: Same considerations as for requireSpace.
  * `function peekSha256(Data memory data, uint length) internal view returns (bytes32)`: Same considerations as for requireSpace.
  * `function decodeU8(Data memory data) internal pure returns (uint8)`
  * `function decodeU16(Data memory data) internal pure returns (uint16)`
  * `function decodeU32(Data memory data) internal pure returns (uint32)`
  * `function decodeU64(Data memory data) internal pure returns (uint64)`
  * `function decodeU128(Data memory data) internal pure returns (uint128)`
  * `function decodeU256(Data memory data) internal pure returns (uint256)`
  * `function decodeBytes20(Data memory data) internal pure returns (bytes20)`
  * `function decodeBytes32(Data memory data) internal pure returns (bytes32)`
  * `function decodeBool(Data memory data) internal pure returns (bool)`
  * `function skipBytes(Data memory data) internal pure`
  * `function decodeBytes(Data memory data) internal pure returns (bytes memory res)`
* [NearDecoder.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/NearDecoder.sol): Imports `Borsh.sol` and has utilities for decoding Public Keys, Signatures, Block Producers, Block Headers and Light Client Blocks.
  * `function decodePublicKey(Borsh.Data memory data) internal pure returns (PublicKey memory res)`
  * `function decodeSignature(Borsh.Data memory data) internal pure returns (Signature memory res)`
  * `function decodeBlockProducer(Borsh.Data memory data) internal pure returns (BlockProducer memory res)`
  * `function decodeBlockProducers(Borsh.Data memory data) internal pure returns (BlockProducer[] memory res)`
  * `function decodeOptionalBlockProducers(Borsh.Data memory data) internal view returns (OptionalBlockProducers memory res)`
  * `function decodeOptionalSignature(Borsh.Data memory data) internal pure returns (OptionalSignature memory res)`
  * `function decodeBlockHeaderInnerLite(Borsh.Data memory data) internal view returns (BlockHeaderInnerLite memory res)`
  * `function decodeLightClientBlock(Borsh.Data memory data) internal view returns (LightClientBlock memory res)`
* [ProofDecoder.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearprover/contracts/ProofDecoder.sol): Imports `Borsh.sol` and `NearDecoder.sol` and has utilities for decoding Proofs, BlockHeader, ExecutionStatus, ExecutionOutcome and MerklePaths. Structures and functions include
  * `struct FullOutcomeProof {ExecutionOutcomeWithIdAndProof outcome_proof; MerklePath outcome_root_proof; BlockHeaderLight block_header_lite; MerklePath block_proof;}`
  * `function decodeFullOutcomeProof(Borsh.Data memory data) internal view returns (FullOutcomeProof memory proof)`
  * `struct BlockHeaderLight {bytes32 prev_block_hash; bytes32 inner_rest_hash; NearDecoder.BlockHeaderInnerLite inner_lite; bytes32 hash;}`
  * `function decodeBlockHeaderLight(Borsh.Data memory data) internal view returns (BlockHeaderLight memory header)`
  * `struct ExecutionStatus {uint8 enumIndex; bool unknown; bool failed; bytes successValue; bytes32 successReceiptId;}`
    * `successValue` indicates if the final action succeeded and returned some value or an empty vec.
    * `successReceiptId` is the final action of the receipt returned a promise or the signed transaction was converted to a receipt. Contains the receipt\_id of the generated receipt.
  * `function decodeExecutionStatus(Borsh.Data memory data) internal pure returns (ExecutionStatus memory executionStatus)`
  * `struct ExecutionOutcome {bytes[] logs; bytes32[] receipt_ids; uint64 gas_burnt; uint128 tokens_burnt; bytes executor_id; ExecutionStatus status; bytes32[] merkelization_hashes;}`
    * `bytes[] logs;`: Logs from this transaction or receipt.
    * `bytes32[] receipt_ids;`: Receipt IDs generated by this transaction or receipt.
    * `uint64 gas_burnt;`: The amount of the gas burnt by the given transaction or receipt.
    * `uint128 tokens_burnt;`: The total number of the tokens burnt by the given transaction or receipt.
    * `bytes executor_id;`: Hash of the transaction or receipt id that produced this outcome.
    * `ExecutionStatus status`: Execution status. Contains the result in case of successful execution.
    * `bytes32[] merkelization_hashes;`
  * `function decodeExecutionOutcome(Borsh.Data memory data) internal view returns (ExecutionOutcome memory outcome)`
  * `struct ExecutionOutcomeWithId {bytes32 id; ExecutionOutcome outcome; bytes32 hash;}`
    * `bytes32 id`: is the transaction hash or the receipt ID.
  * `function decodeExecutionOutcomeWithId(Borsh.Data memory data) internal view returns (ExecutionOutcomeWithId memory outcome)`
  * `struct MerklePathItem {bytes32 hash; uint8 direction;}`
    * `uint8 direction`: where 0 = left, 1 = right
  * `function decodeMerklePathItem(Borsh.Data memory data) internal pure returns (MerklePathItem memory item)`
  * `struct MerklePath {MerklePathItem[] items;}`
  * `function decodeMerklePath(Borsh.Data memory data) internal pure returns (MerklePath memory path)`
  * `struct ExecutionOutcomeWithIdAndProof {MerklePath proof; bytes32 block_hash; ExecutionOutcomeWithId outcome_with_id;}`
  * `function decodeExecutionOutcomeWithIdAndProof(Borsh.Data memory data)internal view returns (ExecutionOutcomeWithIdAndProof memory outcome)`

#### Appendix D - NEAR to Ethereum block propagation costing

The following links provide the production Ethereum addresses and blockexplorer views for NearBridge.sol and the ERC20 Locker

* [Ethereum Mainnet Bridge addresses and parameters](https://github.com/aurora-is-near/rainbow-bridge-client/tree/main/packages/client#ethereum-mainnet-bridge-addresses-and-parameters)
* [NearBridge.sol on Ethereum Block Explorer](https://etherscan.io/address/0x3fefc5a4b1c02f21cbc8d3613643ba0635b9a873)
  * [Sample `addLightClientBlock(bytes data)` function call](https://etherscan.io/tx/0xa0fbf1405747dbc1c1bda1227e46bc7c5feac36c0eeaab051022cfdb268e60cc/advanced)
* [NEAR ERC20Locker on Ethereum Block Explorer](https://etherscan.io/address/0x23ddd3e3692d1861ed57ede224608875809e127f#code)

At time of writing (Oct 26th, 2022).

* NEAR Light Client Blocks are propogated every `4 hours`
* Sample Transaction fee `0.061600109576901025 Ether ($96.56)`
* Daily Transaction fees cost approximately `$600`
* *Note: Infrastructure costs for running relayer, watchdog, etc are not included.*

#### Appendix F - NEAR to Ethereum block propagation components

* [eth2near-relay](https://github.com/aurora-is-near/rainbow-bridge/blob/master/cli/commands/start/eth2near-relay.js): Command to start the NEAR to Ethereum relay. See sample invocation [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/docs/development.md#near2eth-relay)
* [near2eth-block-relay](https://github.com/aurora-is-near/rainbow-bridge/tree/master/near2eth/near2eth-block-relay) is written in javascript
  * Has [dependencies](https://github.com/aurora-is-near/rainbow-bridge/blob/master/near2eth/near2eth-block-relay/package.json) including [rainbow-bridge-utils](https://github.com/aurora-is-near/rainbow-bridge/tree/master/utils) see [here](near-rainbow-bridge-utils) for more information. It's other dependencies are also included in `rainbow-bridge-utils`.
    * [ethereumjs-util](https://www.npmjs.com/package/ethereumjs-util): A collection of utility functions for Ethereum.
  * Has the following functions and classes
    * `class Near2EthRelay`
      * `async initialize ({nearNodeUrl, nearNetworkId, ethNodeUrl, ethMasterSk, ethClientArtifactPath, ethClientAddress, ethGasMultiplier, metricsPort })`
      * `async withdraw ({ethGasMultiplier})`
      * `async runInternal ({submitInvalidBlock, near2ethRelayMinDelay, near2ethRelayMaxDelay, near2ethRelayErrorDelay, near2ethRelayBlockSelectDuration, near2ethRelayNextBlockSelectDelayMs, near2ethRelayAfterSubmitDelayMs, ethGasMultiplier, ethUseEip1559, logVerbose})`
      * `run (options) {return this.runInternal({...options, submitInvalidBlock: false}) }`
* [NearBridge.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/NearBridge.sol): Is the NEAR light client deployed on ethereum.
  * It imports the following contracts (see [nearbridge cryptographic primitives](#nearbridge-cryptographic-primitives))
    * `import "./AdminControlled.sol";`
    * `import "./INearBridge.sol";`
    * `import "./NearDecoder.sol";`
    * `import "./Ed25519.sol";`
  * It provides the following structure for Bridge State. If there is currently no unconfirmed block, the last three fields are zero.
    * `uint currentHeight;`: Height of the current confirmed block
    * `uint nextTimestamp;`: Timestamp of the current unconfirmed block
    * `uint nextValidAt;`: Timestamp when the current unconfirmed block will be confirmed
    * `uint numBlockProducers;`: Number of block producers for the current unconfirmed block
  * It provides the following storage
    * `uint constant MAX_BLOCK_PRODUCERS = 100;`: Assumed to be even and to not exceed 256.
    * `struct Epoch {bytes32 epochId; uint numBPs; bytes [MAX_BLOCK_PRODUCERS] keys; bytes32[MAX_BLOCK_PRODUCERS / 2] packedStakes; uint256 stakeThreshold;}`
    * `uint256 public lockEthAmount;`
    * `uint256 public lockDuration;`: lockDuration and replaceDuration shouldn't be extremely big, so adding them to an uint64 timestamp should not overflow uint256.
    * `uint256 public replaceDuration;`: replaceDuration is in nanoseconds, because it is a difference between NEAR timestamps.
    * `Ed25519 immutable edwards;`
    * `uint256 public lastValidAt;`: End of challenge period. If zero, *`untrusted`* fields and `lastSubmitter` are not meaningful.
    * `uint64 curHeight;`
    * `uint64 untrustedHeight;`: The most recently added block. May still be in its challenge period, so should not be trusted.
    * `address lastSubmitter;`: Address of the account which submitted the last block.
    * `bool public initialized;`: Whether the contract was initialized.
    * `bool untrustedNextEpoch;`
    * `bytes32 untrustedHash;`
    * `bytes32 untrustedMerkleRoot;`
    * `bytes32 untrustedNextHash;`
    * `uint256 untrustedTimestamp;`
    * `uint256 untrustedSignatureSet;`
    * `NearDecoder.Signature[MAX_BLOCK_PRODUCERS] untrustedSignatures;`
    * `Epoch[3] epochs;`
    * `uint256 curEpoch;`
    * `mapping(uint64 => bytes32) blockHashes_;`
    * `mapping(uint64 => bytes32) blockMerkleRoots_;`
    * `mapping(address => uint256) public override balanceOf;`
  * It provides the following functions
    * `constructor(Ed25519 ed, uint256 lockEthAmount_, uint256 lockDuration_, uint256 replaceDuration_, address admin_, uint256 pausedFlags_)`: \_Note: require the `lockDuration` (in seconds) to be at least one second less than the `replaceDuration` (in nanoseconds) `require(replaceDuration* > lockDuration* _ 1000000000);`
      * `ethEd25519Address`: The address of the ECDSA signature checker using Ed25519 curve (see [here](https://nbeguier.medium.com/a-real-world-comparison-of-the-ssh-key-algorithms-b26b0b31bfd9))
      * `lockEthAmount`: The amount that `BLOCK_PRODUCERS` need to deposit (in wei)to be able to provide blocks. This amount will be slashed if the block is challenged and proven not to have a valid signature. Default value is 100000000000000000000 WEI = 100 ETH.
      * `lockDuration` : 30 seconds
      * `replaceDuration`: 60 seconds it is passed in nanoseconds, because it is a difference between NEAR timestamps.
      * `ethAdminAddress`: Bridge Administrator Address
      * `0` : Indicates nothing is paused `UNPAUSE_ALL`
    * `function deposit() public payable override pausable(PAUSED_DEPOSIT)`
    * `function withdraw() public override pausable(PAUSED_WITHDRAW)`
    * `function challenge(address payable receiver, uint signatureIndex) external override pausable(PAUSED_CHALLENGE`
    * `function checkBlockProducerSignatureInHead(uint signatureIndex) public view override returns (bool)`
    * `function initWithValidators(bytes memory data) public override onlyAdmin`: The first part of initialization -- setting the validators of the current epoch.
    * `function initWithBlock(bytes memory data) public override onlyAdmin`: The second part of the initialization -- setting the current head.
    * `function bridgeState() public view returns (BridgeState memory res)`
    * `function bridgeState() public view returns (BridgeState memory res)`
    * `function addLightClientBlock(bytes memory data) public override pausable(PAUSED_ADD_BLOCK)`
    * `function setBlockProducers(NearDecoder.BlockProducer[] memory src, Epoch storage epoch) internal`
    * `function blockHashes(uint64 height) public view override pausable(PAUSED_VERIFY) returns (bytes32 res)`
    * `function blockMerkleRoots(uint64 height) public view override pausable(PAUSED_VERIFY) returns (bytes32 res)`
* [NearProver.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearprover/contracts/NearProver.sol): Is used to prove the validity of NEAR blocks on Ethereum.
  * It imports the following contracts (see [nearbridge cryptographic primitives](#nearbridge-cryptographic-primitives))
    * `import "rainbow-bridge-sol/nearbridge/contracts/NearDecoder.sol";`
    * `import "./ProofDecoder.sol";`
  * It has the following functions
    * `constructor(INearBridge _bridge, address _admin, uint _pausedFlags)`
      * `_bridge`: Interface to `NearBridge.sol`
      * `_admin`: Administrator address
      * `_pausedFlags`: paused indicator defaults to `UNPAUSE_ALL = 0`
    * `function proveOutcome(bytes memory proofData, uint64 blockHeight)`
    * `function _computeRoot(bytes32 node, ProofDecoder.MerklePath memory proof) internal pure returns (bytes32 hash)`

#### Appendix G - NEAR Rainbow Bridge Utils

[rainbow-bridge-utils](https://github.com/aurora-is-near/rainbow-bridge/tree/master/utils) provides a set of utilities for the near rainbow bridge written in javascript.

* It has the following [dependencies](https://github.com/aurora-is-near/rainbow-bridge/blob/master/utils/package.json)
  * [bn.js](https://www.npmjs.com/package/bn.js): Big number implementation in pure javascript
  * [bsert](https://www.npmjs.com/package/bsert): Minimal assert with type checking.
  * [bs58](https://www.npmjs.com/package/bs58): JavaScript component to compute base 58 encoding
  * [change-case](https://www.npmjs.com/package/change-case): Transform a string between camelCase, PascalCase, Capital Case, snake\_case, param-case, CONSTANT\_CASE and others.
  * [configstore](https://www.npmjs.com/package/configstore): Easily load and save config without having to think about where and how
  * [eth-object](https://github.com/near/eth-object#383b6ea68c7050bea4cab6950c1d5a7fa553e72b): re-usable and composable objects that you can just call Object.from to ingest new data to serialize Ethereum Trie / LevelDB data from hex, buffers and rpc into the same format.
  * [eth-util-lite](https://github.com/near/eth-util-lite): a low-dependency utility for Ethereum. It replaces a small subset of the ethereumjs-util and ethjs-util APIs.
  * [lodash](https://www.npmjs.com/package/lodash): A set of utilities for working with arrays, numbers, objects, strings, etc.
  * [near-api-js](https://www.npmjs.com/package/near-api-js): JavaScript library to interact with NEAR Protocol via RPC API
  * [web3](https://www.npmjs.com/package/web3): Ethereum JavaScript API
* It provides the following functions
  * [address-watcher](https://github.com/aurora-is-near/rainbow-bridge/blob/master/utils/address-watcher.js): Watches a group of near and ethereum acccounts polling NEAR and Ethereum every second and updating `nearAccount.balanceGauge`, `nearAccount.stateStorageGauge` and `ethereumAccount.balanceGauge`.
  * [borsh](https://github.com/aurora-is-near/rainbow-bridge/blob/master/utils/borsh.js): provides the following functions for Binary Object Representation Serializer for Hashing [borsh](https://borsh.io/)
    * `function serializeField (schema, value, fieldType, writer)`
    * `function deserializeField (schema, fieldType, reader)`
    * `function serialize (schema, fieldType, obj)`: Serialize given object using schema of the form: `{ class_name -> [ [field_name, field_type], .. ], .. }`
    * `class BinaryReader`: Includes utilities to read numbers, strings arrays and burggers
    * `function deserialize (schema, fieldType, buffer)`
    * `const signAndSendTransactionAsync = async (accessKey, account, receiverId,actions) =>`
    * `const txnStatus = async (account, txHash, retries = RETRY_TX_STATUS, wait = 1000) =>`
    * `function getBorshTransactionLastResult (txResult)`
    * `class BorshContract {`
      * `constructor (borshSchema, account, contractId, options)`
      * `async accessKeyInit ()`
    * `function borshify (block)`
    * `function borshifyInitialValidators (initialValidators)`
    * `const hexToBuffer = (hex) =>`
    * `const readerToHex = (len) =>`
  * [borshify-proof](https://github.com/aurora-is-near/rainbow-bridge/blob/master/utils/borshify-proof.js)
    * `function borshifyOutcomeProof (proof)`
  * [robust](https://github.com/aurora-is-near/rainbow-bridge/blob/master/utils/robust.js): his module gives a few utils for robust error handling, and wrap web3 with error handling and retry
  * [utils](https://github.com/aurora-is-near/rainbow-bridge/blob/master/utils/utils.js)
    * `async function setupNear (config)`
    * `async function setupEth (config)`
    * `async function setupEthNear (config)`: Setup connection to NEAR and Ethereum from given configuration.
    * `function remove0x (value)`: Remove 0x if prepended
    * `function normalizeHex (value)`
    * `async function accountExists (connection, accountId)`
    * `async function createLocalKeyStore (networkId, keyPath)`
    * `function getWeb3 (config)`
    * `function getEthContract (web3, path, address)`
    * `function addSecretKey (web3, secretKey)`
    * `async function ethCallContract (contract, methodName, args)`: Wrap pure calls to Web3 contract to handle errors/reverts/gas usage.

#### Appendix H - Token Transfer Components

*Note: This uses Ethreum [ERC20](https://eips.ethereum.org/EIPS/eip-20) and NEAR [NEP-141](https://nomicon.io/Standards/Tokens/FungibleToken/Core) initally developed for [NEP-21](https://github.com/near/NEPs/pull/21)*

* [rainbow-token-connector](https://github.com/aurora-is-near/rainbow-token-connector)
  * NEAR rust based contracts
    * [bridge-common](https://github.com/aurora-is-near/rainbow-token-connector/tree/master/bridge-common): Common functions for NEAR, currently only `pub fn parse_recipient(recipient: String) -> Recipient`
    * [bridge-token-factory](https://github.com/aurora-is-near/rainbow-token-connector/tree/master/bridge-token-factory): Functions for managing tokens on NEAR including but not limited to `update_metadata`, `deposit`, `get_tokens`, `finish_updating_metadata`, `finish_updating_metadata`, `finish_withdraw`, `deploy_bridge_token`, `get_bridge_token_account_id`, `is_used_proof`, `record_proof`
    * [bridge-token](https://github.com/aurora-is-near/rainbow-token-connector/tree/master/bridge-token): Token functions on NEAR including but not limited to `mint` and `withdraw`
    * [token-locker](https://github.com/aurora-is-near/rainbow-token-connector/tree/master/token-locker): Token Locker functions on NEAR including but not limited to `withdraw`, `finish_deposit`, `is_used_proof`
  * Ethereum solidity based contracts
    * [erc20-bridge-token](https://github.com/aurora-is-near/rainbow-token-connector/tree/master/erc20-bridge-token): Ethereum Bridge token contracts including but not limited to
      * [BridgeToken.sol](https://github.com/aurora-is-near/rainbow-token-connector/blob/master/erc20-bridge-token/contracts/BridgeToken.sol)
      * [BridgeTokenFactory.sol](https://github.com/aurora-is-near/rainbow-token-connector/blob/master/erc20-bridge-token/contracts/BridgeTokenFactory.sol)
      * [BridgeTokenProxy.sol](https://github.com/aurora-is-near/rainbow-token-connector/blob/master/erc20-bridge-token/contracts/BridgeTokenProxy.sol)
      * [ProofConsumer.sol](https://github.com/aurora-is-near/rainbow-token-connector/blob/master/erc20-bridge-token/contracts/ProofConsumer.sol)
      * [ResultsDecoder](https://github.com/aurora-is-near/rainbow-token-connector/blob/master/erc20-bridge-token/contracts/ResultsDecoder.sol)
    * [erc20-connector](https://github.com/aurora-is-near/rainbow-token-connector/tree/master/erc20-connector): has [ERC20Locker.sol](https://github.com/aurora-is-near/rainbow-token-connector/blob/master/erc20-connector/contracts/ERC20Locker.sol) which is used to lock and unlock tokens. It is linked to the bridge token factory on NEAR side. It also links to the prover that it uses to unlock the tokens. (see [here](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearbridge/contracts))

#### Appendix I - NEAR Rainbow Bridge: Component Overview

The following smart contracts are deployed on NEAR and work in conjunction with eth2near bridging functionality to propogate blocks from Ethereum to NEAR.

**\*Note** here we will focus on the `eth2-client` for ETH 2.0 Proof of Stake Bridging however if interested in however there is also an `eth-client` which was used for ETH 1.0 Proof of Work Integration using [rust-ethhash](https://github.com/nearprotocol/rust-ethash).\*

* [Smart Contracts Deployed on NEAR](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/near)
  * [eth2-client](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/near/eth2-client) implements the Ethereum Light Client on Near
    * it provides functions including but not limited to:
      * validate the light client
      * verify the finality branch
      * verify bls signatures
      * update finalized headers
      * updates the submittes
      * prune finalized blocks.
    * It interacts with the beach chain, uses [Borsh](https://borsh.io/) for serialization and [lighthouse](https://github.com/aurora-is-near/lighthouse) for Ethereum 2.0 Consensus and tree\_hash functions as well as bls signatures. See [here](https://lighthouse-book.sigmaprime.io/) for more information on lighthouse. Below is a list of dependencies from [eth2-client/Cargo.toml](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/Cargo.toml)

      ```
      [dependencies]
      ethereum-types = "0.9.2"
      eth-types =  { path = "../eth-types" }
      eth2-utility =  { path = "../eth2-utility" }
      tree_hash = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
      merkle_proof = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
      bls = { git = "https://github.com/aurora-is-near/lighthouse.git", optional = true, rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec", default-features = false, features = ["milagro"]}
      admin-controlled =  { path = "../admin-controlled" }
      near-sdk = "4.0.0"
      borsh = "0.9.3"
      bitvec = "1.0.0"
      ```

* [eth2near](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near) supports the relaying of blocks and the verification of finality between etherum and Near. It has the following components
  * [contract\_wrapper](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/contract_wrapper): provides rust wrappers for interacting with the [solidity contracts on near](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/near)
    * Contracts include (from [`lib.rs`](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/contract_wrapper/src/lib.rs))

      ```
      pub mod contract_wrapper_trait;
      pub mod dao_contract;
      pub mod dao_eth_client_contract;
      pub mod dao_types;
      pub mod errors;
      pub mod eth_client_contract;
      pub mod eth_client_contract_trait;
      pub mod file_eth_client_contract;
      pub mod near_contract_wrapper;
      pub mod sandbox_contract_wrapper;
      pub mod utils;
      ```

    * Dependencies include (from [contract\_wrapper/Cargo.toml](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/contract_wrapper/Cargo.toml))

      ```
      [dependencies]
      borsh = "0.9.3"
      futures = "0.3.21"
      async-std = "1.12.0"
      near-sdk = "4.0.0"
      near-jsonrpc-client = "=0.4.0-beta.0"
      near-crypto = "0.14.0"
      near-primitives = "0.14.0"
      near-chain-configs = "0.14.0"
      near-jsonrpc-primitives = "0.14.0"
      tokio = { version = "1.1", features = ["rt", "macros"] }
      reqwest = { version = "0.11", features = ["blocking"] }
      serde_json = "1.0.74"
      serde = { version = "1.0", features = ["derive"] }
      eth-types = { path = "../../contracts/near/eth-types/", features = ["eip1559"]}
      workspaces = "0.5.0"
      anyhow = "1.0"
      ```

  * [eth2near-block-relay-rs](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/eth2near-block-relay-rs) is built in rust and integrates with the Ethereum 2.0 lgihthouse consensus client to propogate blocks to near.
    * Functionality includes (from [lib.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/lib.rs))

      ```
      pub mod beacon_block_body_merkle_tree;
      pub mod beacon_rpc_client;
      pub mod config;
      pub mod eth1_rpc_client;
      pub mod eth2near_relay;
      pub mod execution_block_proof;
      pub mod hand_made_finality_light_client_update;
      pub mod init_contract;
      pub mod last_slot_searcher;
      pub mod light_client_snapshot_with_proof;
      pub mod logger;
      pub mod near_rpc_client;
      pub mod prometheus_metrics;
      pub mod relay_errors;
      ```

    * Dependencies include (from [eth2near-block-relay-rs/Cargo.toml](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/Cargo.toml))

      ```
      types =  { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
      tree_hash = { git = "https://github.com/aurora-is-near/lighthouse.git",  rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
      merkle_proof = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
      eth2_hashing = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
      eth2_ssz = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }

      eth-types = { path = "../../contracts/near/eth-types/", features = ["eip1559"]}
      eth2-utility  = { path = "../../contracts/near/eth2-utility" }

      contract_wrapper = { path = "../contract_wrapper" }
      finality-update-verify = { path = "../finality-update-verify" }

      log = { version = "0.4", features = ["std", "serde"] }
      serde_json = "1.0.74"
      serde = { version = "1.0", features = ["derive"] }
      ethereum-types = "0.9.2"
      reqwest = { version = "0.11", features = ["blocking"] }
      clap = { version = "3.1.6", features = ["derive"] }
      tokio = { version = "1.1", features = ["macros", "rt", "time"] }
      env_logger = "0.9.0"
      borsh = "0.9.3"
      near-sdk = "4.0.0"
      futures = { version = "0.3.21", default-features = false }
      async-std = "1.12.0"
      hex = "*"
      toml = "0.5.9"
      atomic_refcell = "0.1.8"
      bitvec = "*"
      primitive-types = "0.7.3"

      near-jsonrpc-client = "=0.4.0-beta.0"
      near-crypto = "0.14.0"
      near-primitives = "0.14.0"
      near-chain-configs = "0.14.0"
      near-jsonrpc-primitives = "0.14.0"

      prometheus = { version = "0.9", features = ["process"] }
      lazy_static = "1.4"
      warp = "0.2"
      thread = "*"

      ```

  * [eth2near-block-relay](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/eth2near-block-relay) is built using javascript and supports ETH 1.0 Proof of Work (`ethhash`) using merkle patrica trees.
    * key classes from [index.js](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay/index.js) include
      * `Ethashproof` : which has functions to `getParseBlock` and `calculateNextEpoch`
      * `Eth2NearRelay` : which interacts with the `ethClientContract` and has a `run()` function which loops through relaying blocks and includes additional functions such as `getParseBlock` , `submitBlock`
    * Dependencies include (from [package.json](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay/package.json))

      ```
      "dependencies": {
          "bn.js": "^5.1.3",
          "eth-object": "https://github.com/near/eth-object#383b6ea68c7050bea4cab6950c1d5a7fa553e72b",
          "eth-util-lite": "near/eth-util-lite#master",
          "@ethereumjs/block": "^3.4.0",
          "merkle-patricia-tree": "^2.1.2",
          "prom-client": "^12.0.0",
          "promisfy": "^1.2.0",
          "rainbow-bridge-utils": "1.0.0",
          "got": "^11.8.5"
      },
      ```

  * [ethhashproof](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/ethashproof): is a commandline to calculate proof data for an ethash POW, it is used by project `SmartPool` and a decentralizedbridge between Etherum and EOS developed by Kyber Network team. It is written in `GO`.
    * Features Include 1. Calculate merkle root of the ethash dag dataset with given epoch 2. Calculate merkle proof of the pow (dataset elements and their merkle proofs) given the pow submission with given block header 3. Generate dag datase
    * Dependencies include (from [ethahsproof/go.mod](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/ethashproof/go.mod))

      ```
      require (
       github.com/deckarep/golang-set v1.7.1
          github.com/edsrzf/mmap-go v1.0.0
          github.com/ethereum/go-ethereum v1.10.4
          github.com/hashicorp/golang-lru v0.5.5-0.20210104140557-80c98217689d
          golang.org/x/crypto v0.0.0-20210322153248-0c34fe9e7dc2
      )
      ```

  * [finality-update-verify](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/finality-update-verify) checks and updates finality using the lighthouse beacon blocks.
    * Functions include (from [lib.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/finality-update-verify/src/lib.rs))
      * `fn h256_to_hash256(hash: H256) -> Hash256`
      * `fn tree_hash_h256_to_eth_type_h256(hash: tree_hash::Hash256) -> eth_types::H256`
      * `fn to_lighthouse_beacon_block_header(bridge_beacon_block_header: &BeaconBlockHeader,) -> types::BeaconBlockHeader {types::BeaconBlockHeader`
      * `pub fn is_correct_finality_update(ethereum_network: &str, light_client_update: &LightClientUpdate, sync_committee: SyncCommittee, ) -> Result<bool, Box<dyn Error>>`
    * Dependencies include (from [finality-update-verify/Cargo.toml](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/finality-update-verify/Cargo.toml))

      ```
      [dependencies]
          eth-types = { path ="../../contracts/near/eth-types/", features = ["eip1559"]}
          bls = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
          eth2-utility  = { path ="../../contracts/near/eth2-utility"}
          tree_hash = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
          types =  { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
          bitvec = "1.0.0"

          [dev-dependencies]
          eth2_to_near_relay = { path = "../eth2near-block-relay-rs"}
          serde_json = "1.0.74"
          serde = { version = "1.0", features = ["derive"] }
          toml = "0.5.9"
      ```

The following smart contracts are deployed on Ethereum and used for propogating blocks from NEAR to Ethereum.

* [Smart Contracts deployed on Ethereum](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth) including
  * [Near Bridge Contracts](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearbridge/contracts) including [NearBridge.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/NearBridge.sol) which the interface [INearBridge.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/INearBridge.sol)

  * Interface Overview

    ```
    interface INearBridge {
        event BlockHashAdded(uint64 indexed height, bytes32 blockHash);
        event BlockHashReverted(uint64 indexed height, bytes32 blockHash);
        function blockHashes(uint64 blockNumber) external view returns (bytes32);
        function blockMerkleRoots(uint64 blockNumber) external view returns (bytes32);
        function balanceOf(address wallet) external view returns (uint256);
        function deposit() external payable;
        function withdraw() external;
        function initWithValidators(bytes calldata initialValidators) external;
        function initWithBlock(bytes calldata data) external;
        function addLightClientBlock(bytes calldata data) external;
        function challenge(address payable receiver, uint256 signatureIndex) external;
        function checkBlockProducerSignatureInHead(uint256 signatureIndex) external view returns (bool);
    }
    ```

  * Key Storage items for epoch and block information

    ```
        Epoch[3] epochs;
        uint256 curEpoch;

        mapping(uint64 => bytes32) blockHashes_;
        mapping(uint64 => bytes32) blockMerkleRoots_;
        mapping(address => uint256) public override balanceOf;
    ```

  * Signing and Serializing Primitives
    * [NearDecoder.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/NearDecoder.sol): handles decoing of Public Keys, Signatures, BlockProducers and LightClientBlocks using `Borsh.sol`
    * [Utils.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Utils.sol): handles reading and writing to memory, memoryToBytes and has functions such as `keccak256Raw` and `sha256Raw`
    * [Borsh.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Borsh.sol): [Borsh](https://borsh.io/): Binary Object Representation Serializer for Hashing. It is meant to be used in security-critical projects as it prioritizes consistency, safety, speed; and comes with a strict specification.
    * [Ed25519.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Ed25519.sol): [Ed25519](https://ed25519.cr.yp.to/) high-speed high-security signatures

  * [Near Prover Contracts](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearprover/contracts)
    * [NearProver.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearprover/contracts/NearProver.sol): Has a `proveOutcome` which validates the outcome merkle proof and the block proof is valid using `_computeRoot` which is passed in a `bytes32 node, ProofDecoder.MerklePath memory proof`
    * [ProofDecoder.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearprover/contracts/ProofDecoder.sol): Uses MerklePaths to provide decoding functions such as `decodeExecutionStatus`, `decodeExecutionOutcome`, `decodeExecutionOutcomeWithId`, `decodeMerklePathItem`, `decodeMerklePath` and `decodeExecutionOutcomeWithIdAndProof`. It relies on the primitives `Borsh.sol` and `NearDecoder.sol` above.

#### Appendix J - Ethereum to NEAR Walkthrough

Following is a walkthough of a funds transfer from Ethereum to a target chain (In this example Near), complete with light client updates, block propogation and proofs to ensure the transaction validity.

![Ethereum to Near Funds Transfer](/assets/posts/2023-02-05-ethereum-bridging-costs/eth2NearFundsTransfer.jpg "Ethereum to NEAR Funds Transfer")

**Actors**
From the diagram above you'll notice that there are many actors involved, below is an overview of the actors and the operations they perform.

* Accounts
  * [User Account](https://etherscan.io/address/0x29da2ef94deeaf2d2f9003e9354abfcb1ff04b32) : The user is the owner of the funds being transferred and is responsible for signing the transactions to authorize bridging them accross chains. In this example they have accounts on [Ethereum](https://etherscan.io/address/0x29da2ef94deeaf2d2f9003e9354abfcb1ff04b32) and [NEAR](https://nearblocks.io/address/johnrubini.near#tokentxns)
  * [Target Chain Relayer Acccount](https://nearblocks.io/address/relayer.bridge.near): The relayer account is responsible for relaying messages from Ethereum to the target chain. \*Note this is connected to a relayer which is responsible for tasks such as querying latest block headers and getting light client status updates. Source code is [here](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/eth2near-block-relay-rs).
  * [Target Chain Bridge Validator Accounts](https://nearblocks.io/address/bridge-validator1.near): are responsible for validating light client update proposals and sending approval votes to [DAO Eth Client Contract](https://nearblocks.io/address/bridge-validator.sputnik-dao.near).
* Ethereum Components
  * [ERC20 Token Contract](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code): this is the token contract securing the funds in this examle USDT (Tether). Source code is [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.8/contracts/token/ERC20/presets/ERC20PresetMinterPauser.sol)
  * [Bridge Contract](https://etherscan.io/address/0x23ddd3e3692d1861ed57ede224608875809e127f#code): Responsible for deposits and withdrawals of tokens on Ethereum as well as various proving and propogation mechanisms such as checking of Signatures and adding Light Client Blocks. Source code is [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/NearBridge.sol)
* Target Chain (NEAR) Components
  * [Validator DAO Contract](https://nearblocks.io/address/bridge-validator.sputnik-dao.near): Responsible for receivng light client update proposals from the relayer and gathering approval votes for these propoals from Validators and submitting light client updates once the proposal is approved by the Validators. Source code is [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/contract_wrapper/src/dao_eth_client_contract.rs)
  * [Etherum 2 Client](https://nearblocks.io/address/client-eth2.bridge.near): The Ethereum 2 client is responsbile for processing light client updates and receiving execution header blocks from Ethereum via the relayer. Source code is [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs). *Note: this replaced the [Ethereum 1 client](https://nearblocks.io/address/client.bridge.near) source code [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth-client/src/lib.rs)*
  * [Ethereum Prover](https://nearblocks.io/address/prover.bridge.near) : The Ethereum Prover is used to prove transactions are included in a valid block Header. Source code is [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth-prover/src/lib.rs)
  * [Bridge Contract](https://nearblocks.io/address/factory.bridge.near#contract): The Bridge contract is responsible for managing tokens including creating new tokens, setting metadata and depositing and withdrawal of tokens. Source code is [here](https://github.com/aurora-is-near/rainbow-token-connector/blob/master/bridge-token-factory/src/lib.rs).
    * [NEAR Token Contract](https://nearblocks.io/token/dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near?a=dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near): The target chain representation of the token (USDT) managed by the target chain bridge contract.

**Sample TransactionFlow**

1. Block Propogation
   1. Get the Latest Slot: The relayer loops polling Ethereum every 12 seconds to get the latest slot. It then checks if it is for a new epoch and if so (every 6 minutes) submits an execution header (with 32 blocks in it) and a light client update with the latest approved epochs and updated sync\_comittee. Relayer source code for the loop is [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L258) for retrieving the latest slot is [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L163), for submitting execution blocks is [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L399) and for sending light client updates is [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L489).
      1. [Send Block Headers (submit\_execution\_header)](https://nearblocks.io/txns/HaXUxCvA1D87QXJzPzSYXmFYNuSLbTmyuxShzWgSLvPM): Batch transaction which submits 32 block headers to [client-eth2.bridge.near](https://nearblocks.io/address/client-eth2.bridge.near) for Ethereum Blocks 16493592 to 16493623. (The second slot in epoch [176,936](https://beaconcha.in/epoch/176936) to the first slot in epoch [176,937](https://beaconcha.in/epoch/176937)). **Executed every 6 minutes when the first slot of a new epoch is found.**
      2. [Create Light Client update proposal(add\_proposal)](https://nearblocks.io/txns/J1tQ465Dxt4UhWy9Msn2pZCbdkWatSepqsx9sDZaX35z#): calls [bridge-validator.sputnik-dao.near](https://nearblocks.io/address/bridge-validator.sputnik-dao.near) to add proposal 17410 for [slot 5,661,984](https://beaconcha.in/slot/5661984) in epoch [176,937](https://beaconcha.in/epoch/176937).
   2. [Approve Proposal (act\_proposal)](https://nearblocks.io/txns/D5uP4BbRSUX4ZGijRfWGkR5KbFb2Kb9q1gSsFVQbYSLt): sends a VoteApprove action for proposal 17410 from a [bridge validator](https://nearblocks.io/address/bridge-validator1.near) to the [Validator DAO Contract](https://nearblocks.io/address/bridge-validator.sputnik-dao.near).
      1. act\_proposal in contract [bridge-validator.sputnik-dao.near](https://nearblocks.io/address/bridge-validator.sputnik-dao.near)
      2. submit\_beacon\_chain\_light\_client\_update in [client-eth2.bridge.near](https://nearblocks.io/address/client-eth2.bridge.near)
      3. on\_proposal\_callback in contract [bridge-validator.sputnik-dao.near](https://nearblocks.io/address/bridge-validator.sputnik-dao.near)
2. Funds Transfer Transaction Flow
   1. [Lock Funds On Ethereum](https://etherscan.io/tx/0xa685c59a24cc2056e10e660ce8a8bff7bbc335433698e138c77aaadf20ecb614): Locking 10,000 USDT to send to user on NEAR.
   2. [Deposit Funds on Target Chain Bridge Contract (deposit)](https://nearblocks.io/txns/vniyRR67ndrtvpoQ9c5ACoT4e9c283VSQsrZcN6GGto#execution)
      1. deposit in contract factory.bridge.near
      2. verify\_log\_entry in contract prover.bridge.near
      3. block\_hash\_safe in contract client-eth2.bridge.near
      4. finish\_deposit in contract factory.bridge.near : mint of 10,000 USDT.

**TODO**

* Find and review the source code for the [validator light client approval update](https://nearblocks.io/txns/HnzBR7x5Sxnmcm4MfRt1ghhMjJNspDaygUUKeM9T27Li#execution). *Note: the eth2\_client has a [validate\_light\_client\_update](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs#L311) which is [configurable](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs#L42) and is used for debugging purposes.*

**Bridging Resources Required**

Here is the storage and compuational costs per component.

| Component                                                                                                                   | Data           | Storage | Notes |
| --------------------------------------------------------------------------------------------------------------------------- | -------------- | ------- | ----- |
| [Ethereum 2 Client](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs#L35) | ---            | ---     | ---   |
| [Prover](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth-prover/src/lib.rs)                 | not applicable | 0 bytes |       |
| [DAO Contract](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/contract_wrapper/src/dao_contract.rs)  |                |         |       |

**TODO**
Review the following data structure and elements and move into the table above commenting on any mandatory requirements and structures that can be improved.

```
pub struct Eth2Client {
    /// If set, only light client updates by the trusted signer will be accepted
    trusted_signer: Option<AccountId>,
    /// Mask determining all paused functions
    paused: Mask,
    /// Whether the client validates the updates.
    /// Should only be set to `false` for debugging, testing, and diagnostic purposes
    validate_updates: bool,
    /// Whether the client verifies BLS signatures.
    verify_bls_signatures: bool,
    /// We store the hashes of the blocks for the past `hashes_gc_threshold` headers.
    /// Events that happen past this threshold cannot be verified by the client.
    /// It is desirable that this number is larger than 7 days' worth of headers, which is roughly
    /// 51k Ethereum blocks. So this number should be 51k in production.
    hashes_gc_threshold: u64,
    /// Network. e.g. mainnet, kiln
    network: Network,
    /// Hashes of the finalized execution blocks mapped to their numbers. Stores up to `hashes_gc_threshold` entries.
    /// Execution block number -> execution block hash
    finalized_execution_blocks: LookupMap<u64, H256>,
    /// All unfinalized execution blocks' headers hashes mapped to their `HeaderInfo`.
    /// Execution block hash -> ExecutionHeaderInfo object
    unfinalized_headers: UnorderedMap<H256, ExecutionHeaderInfo>,
    /// `AccountId`s mapped to their number of submitted headers.
    /// Submitter account -> Num of submitted headers
    submitters: LookupMap<AccountId, u32>,
    /// Max number of unfinalized blocks allowed to be stored by one submitter account
    /// This value should be at least 32 blocks (1 epoch), but the recommended value is 1024 (32 epochs)
    max_submitted_blocks_by_account: u32,
    // The minimum balance that should be attached to register a new submitter account
    min_storage_balance_for_submitter: Balance,
    /// Light client state
    finalized_beacon_header: ExtendedBeaconBlockHeader,
    finalized_execution_header: LazyOption<ExecutionHeaderInfo>,
    current_sync_committee: LazyOption<SyncCommittee>,
    next_sync_committee: LazyOption<SyncCommittee>,
}
```

#### Appendix K - Explorer and Interactive Links

* Near
  * eth-prover
    * [https://nearblocks.io/address/relayer.bridge.near](https://nearblocks.io/address/relayer.bridge.near)
    * [https://nearblocks.io/address/client-eth2.bridge.near](https://nearblocks.io/address/client-eth2.bridge.near)
    * [https://nearblocks.io/address/client.bridge.near](https://nearblocks.io/address/client.bridge.near)
  * eth-client
    * [https://nearblocks.io/address/prover.bridge.near](https://nearblocks.io/address/prover.bridge.near)
    * [https://nearblocks.io/address/client.bridge.near](https://nearblocks.io/address/client.bridge.near)
  * factory (manages tokens)
    * [https://nearblocks.io/address/factory.bridge.near](https://nearblocks.io/address/factory.bridge.near)
  * dao
    * [https://nearblocks.io/address/bridge-validator.sputnik-dao.near](https://nearblocks.io/address/bridge-validator.sputnik-dao.near)
  * aurora
    * [https://nearblocks.io/address/aurora](https://nearblocks.io/address/aurora)
    * [https://nearblocks.io/address/relay.aurora](https://nearblocks.io/address/relay.aurora)

* Ethereum
  * [beaconcha.in](https://beaconcha.in/)
    * [validators](https://beaconcha.in/validators)
    * [epochs](https://beaconcha.in/epochs)
    * [slots](https://beaconcha.in/slots)
    * [blocks](https://beaconcha.in/blocks)
    * [transactions](https://beaconcha.in/transactions)
  * Near Bridge
    * [NearBridge](https://etherscan.io/address/0x3fefc5a4b1c02f21cbc8d3613643ba0635b9a873)
    * [ERC20Locker](https://etherscan.io/tx/0xa685c59a24cc2056e10e660ce8a8bff7bbc335433698e138c77aaadf20ecb614)


## Polymer Labs

* date: 2023-02-24
* last updated: 2023-02-24

### Overview

Polymer’s[^ov-1] modular IBC[^ov-2] design allows for chains, like Ethereum[^ov-3], to easily integrate IBC transport and become interoperable across all ecosystems in a decentralized manner.

Our protocol combines a novel consensus engine[^ov-4], zero knowledge technology[^ov-5], and modular IBC[^ov-6] to create the most efficient and scalable IBC routing solution.
Polymer is the first chain dedicated to the routing of IBC packets.

### Approach

### Sample Process Flow

### Design Notes

### Code Review

* [plonky2](https://github.com/mir-protocol/plonky2): a SNARK implementation based on techniques from PLONK and FRI. It has since expanded to include tools such as Starky, a highly performant STARK implementation.
  * [plonky2-solidity-verifier](https://github.com/polymerdao/plonky2-solidity-verifier)
  * [plonky2-circom](https://github.com/polymerdao/plonky2-circom): Plonky2 verifier in Circom
  * [plonky2-ed25519](https://github.com/polymerdao/plonky2-ed25519): SNARK verification circuits of a digital signature scheme Ed25519 implemented with Plonky2.
  * [plonky2-sha256](https://github.com/polymerdao/plonky2-sha256): SNARK circuits of a cryptographic hash function SHA-256 implemented with Plonky2.
  * [plonky2-sha512](https://github.com/polymerdao/plonky2-sha512): SNARK circuits of a cryptographic hash function SHA-512 implemented with Plonky2.
  * [plonky2-pairing](https://github.com/polymerdao/plonky2-pairing)

#### Signing Mechanisms

#### Cryptographic Primitives

#### Proving Mechanisms

#### Relayer Mechanisms

#### Light Client Functionality

#### Token Lockers

### References

### Appendices

### Footnotes

[^ov-1]: [An Introduction to Polymer Labs, Cosmos, and IBC (Inter-Blockchain Communication)](https://polymerlabs.medium.com/an-introduction-to-polymer-labs-cosmos-and-ibc-inter-blockchain-communication-b9f941ee2cdb): Polymer Chain provides a seamless way to provide cross chain communication by utilizing IBC to connect chains even when they may not support IBC natively.

[^ov-2]: [INTER‑BLOCKCHAIN COMMUNICATION PROTOCOL](https://ibcprotocol.org/): IBC is an interoperability protocol for communicating arbitrary data between arbitrary state machines.

[^ov-3]: [The Multi-hop IBC upgrade will take IBC to Ethereum and beyond](https://polymerlabs.medium.com/the-multi-hop-ibc-upgrade-will-take-ibc-to-ethereum-and-beyond-b4bee43523e): A discussion on some key areas of improvement that Polymer is tackling to upgrade IBC functionality and expand the IBC network across the industry.

[^ov-4]: [zkMint: The First ZK-friendly Tendermint Consensus Engine](https://polymerlabs.medium.com/zkmint-the-first-zk-friendly-tendermint-consensus-engine-116000b9d4f9): Polymer’s solution that optimizes IBC across all major chains.

[^ov-5]: [Developing the Most Truly Decentralized Interoperability Solution : Polymer ZK-IBC](https://polymerlabs.medium.com/developing-the-most-truly-decentralized-interoperability-solution-polymer-zk-ibc-f0287ea84a2b): ZK-IBC allows different blockchain protocols to communicate with each other without trusting third parties. It does this by verifying the blockchain consensus on-chain.

[^ov-6]: [Modular IBC for the Modular World](https://polymerlabs.medium.com/modular-ibc-for-the-modular-world-9fc021f6322e): IBC network topology is changing from a homogenous and densely connected network to a heterogenous and sparsely connected network. Modular IBC adapts the IBC protocol to this dynamic environment.


## Snowbridge

* date: 2023-02-24
* last-updated: 2023-02-24

### Overview

Snowbridge is a general purpose, trustless and decentralized bridge between Polkadot and Ethereum. The goal is to launch as common-good bridge on the proposed BridgeHub parachain.
**Quick Links**

* Bridge Type : Proof Based Validity Proofs
* [Design](https://docs.snowbridge.network/architecture/overview): bridge has a layered architecture, inspired by networking protocols such as TCP/IP. At the lowest level we have channels, which send messages across the bridge. At the highest level, we have apps, which can invoke methods on apps living on foreign chains.
* [Docs](https://docs.snowbridge.network/): Snowbridge documentation
* [Implementation snowfork snowbridge](https://github.com/Snowfork/snowbridge): A trustless bridge between Polkadot and Ethereum.
* FronteEnd: Still Under Development
* [Explorer](https://polkadot.subscan.io/parachain): Can be used to review if a common good parachain is deployed. Bridge messages will be displayed as Cross Chain Messages (XCM) on this [xcm dashboard](https://polkadot.subscan.io/xcm_dashboard).
* [Roadmap](https://gateway.pinata.cloud/ipfs/QmfYGxQvyjVrgm9ajfzCysbuvLXdsRxP5R5HFjWcrj2yYY): The [Snowbridge Funding Proposal](https://polkadot.polkassembly.io/post/1341) includes a link to the [roadmap](https://gateway.pinata.cloud/ipfs/QmfYGxQvyjVrgm9ajfzCysbuvLXdsRxP5R5HFjWcrj2yYY) which details the milestones and rollout.

### Design Notes

**[light-client verification polkadot](https://docs.snowbridge.network/architecture/verification/polkadot)**

We use Polkadot’s BEEFY gadget to implement an efficient light client that only needs to verify a very small subset of relay chain validator signatures. BEEFY is live on Rococo, and is awaiting deployment on Kusama and Polkadot.
Fundamentally, the BEEFY light client allows the bridge to prove that a specified parachain header was finalized by the relay chain.

**[BEEFY light client](https://github.com/paritytech/parity-bridges-common/blob/master/modules/beefy/src/lib.rs)**

> BEEFY bridge pallet.
>
> This pallet is an on-chain BEEFY light client for Substrate-based chains that are using the following pallets bundle: `pallet-mmr`, `pallet-beefy` and `pallet-beefy-mmr`.
>
> The pallet is able to verify MMR leaf proofs and BEEFY commitments, so it has access to the following data of the bridged chain:
>
> * header hashes
> * changes of BEEFY authorities
> * extra data of MMR leafs
>
> Given the header hash, other pallets are able to verify header-based proofs (e.g. storage proofs, transaction inclusion proofs, etc.).

**[light-client verification ethereum](https://docs.snowbridge.network/architecture/verification/ethereum)**

We have implemented a Proof-of-Stake (PoS) light client for the Beacon chain. This client deprecates the older PoW light client we developed in 2020.

The beacon client tracks the beacon chain, the new Ethereum chain that will replace Ethereum's Proof-of-Work consensus method around mid-September, called the Merge. The work we have done consists of the following parts:

* Beacon Client pallet
  * Initial chain snapshot (forms part of the Genesis Config)
  * Sync committee updates
  * Finalized beacon header updates
  * Execution header updates
  * Message verification
* Beacon Relayer
  * Sends data from a beacon node to the beacon client

### Code Review

#### Signing Mechanisms

* [secp256k1](https://www.secg.org/sec2-v2.pdf)
  * [snowbridge secp256k1](https://github.com/Snowfork/snowbridge/tree/main/relayer/crypto/secp256k1)
* [sr25519](https://wiki.polkadot.network/docs/learn-cryptography#what-is-sr25519-and-where-did-it-come-from): schnorr over ristretto25519
  * [snowbridge sr25519](https://github.com/Snowfork/snowbridge/tree/main/relayer/crypto/secp256k1)

#### Cryptographic Primitives

* [keccak256](https://keccak.team/keccak.html) hash function
  * [snowbridge keccak](https://github.com/Snowfork/snowbridge/blob/main/relayer/crypto/keccak/keccak.go)
* [merkle trees](https://en.wikipedia.org/wiki/Merkle_tree)
  * [snowbridge merkle.go](https://github.com/Snowfork/snowbridge/blob/main/relayer/crypto/merkle/merkle.go)
  * [snowbridge merkleization.rs](https://github.com/Snowfork/snowbridge/blob/main/parachain/pallets/ethereum-beacon-client/src/merkleization.rs)
* [merkle\_proof](https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.mdx) [explainer](https://soliditydeveloper.com/merkle-tree)
  * [snowbridge simplified\_mmr\_proof.go](https://github.com/Snowfork/snowbridge/blob/main/relayer/crypto/merkle/simplified_mmr_proof.go)
  * [snowbridge merkle-proof rust](https://github.com/Snowfork/snowbridge/tree/main/parachain/pallets/basic-channel/merkle-proof)
  * [snowbridge MerkleProof.sol](https://github.com/Snowfork/snowbridge/blob/main/core/packages/contracts/contracts/utils/MerkleProof.sol)
* [Merkle Mountain Range](https://docs.grin.mw/wiki/chain-state/merkle-mountain-range/)
  * [snowbridge MMRProof.sol](https://github.com/Snowfork/snowbridge/blob/main/core/packages/contracts/contracts/utils/MMRProof.sol)
  * [snowfork merkle-mountain-range](https://github.com/Snowfork/merkle-mountain-range)
* [Simple Serialize](https://ethereum.org/en/developers/docs/data-structures-and-encoding/ssz/)
  * [snowbridge ssz.rs](https://github.com/Snowfork/snowbridge/blob/main/parachain/pallets/ethereum-beacon-client/src/ssz.rs)

#### Proving Mechanisms

* [Beefy](https://wiki.polkadot.network/docs/learn-consensus#bridging-beefy)
  * [snowbridge BeefyClient.sol](https://github.com/Snowfork/snowbridge/blob/main/core/packages/contracts/contracts/BeefyClient.sol)

* [snowbridge ethereum-beacon-client rust](https://github.com/Snowfork/snowbridge/tree/main/parachain/pallets/ethereum-beacon-client)

* [snowbridge ethereum-light-client rust](https://github.com/Snowfork/snowbridge/tree/main/parachain/pallets/ethereum-light-client)

#### Relayer Mechanisms

The [relays folder](https://github.com/Snowfork/snowbridge/tree/main/relayer/relays) has multiple relayers controlled by [execution](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/execution/main.go). All written in go.

* Relaying from Ethereum to Polkadot
  * [beacon](https://github.com/Snowfork/snowbridge/tree/main/relayer/relays/beacon): Responsible for retrieving state from the beacon chain including
    * [synching](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go):
      * [Header](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#L47)
      * [CurrentSyncCommittee](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#L55)
      * [SyncAggregate](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#LL60C12-L60C12)
    * functions include
      * [GetSyncPeriodsToFetch](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#L65)
      * [GetInitialSync](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#L83)
      * [GetSyncCommitteePeriodUpdate](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#L118)
      * [GetBlockRoots](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#L187)
      * [GetFinalizedUpdate](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#L252)
      * [HasFinalizedHeaderChanged](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#L305)
      * [GetLatestFinalizedHeader](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#L326)
      * [getNextBlockRootBySlot](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#L379)
      * [GetNextHeaderUpdateBySlotWithAncestryProof](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#L425)
      * [GetNextHeaderUpdateBySlot](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#L434)
      * [GetHeaderUpdateWithAncestryProof](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#L457)
      * [getBlockHeaderAncestryProof](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#L495)
      * [GetSyncAggregate](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#L520)
      * [GetSyncAggregateForSlot](https://github.com/Snowfork/snowbridge/blob/main/relayer/relays/beacon/header/syncer/syncer.go#L534)
  * [ethereum](https://github.com/Snowfork/snowbridge/tree/main/relayer/relays/ethereum): Responsible for retreiving block headers from the execution chain.
* Relaying from Polkadot to Etherem
  * [parachain](https://github.com/Snowfork/snowbridge/tree/main/relayer/relays/parachain)
  * [beefy](https://github.com/Snowfork/snowbridge/tree/main/relayer/relays/beefy)

#### Light Client Functionality

* [Beefy](https://wiki.polkadot.network/docs/learn-consensus#bridging-beefy)
  * [snowbridge BeefyClient.sol](https://github.com/Snowfork/snowbridge/blob/main/core/packages/contracts/contracts/BeefyClient.sol)

* [snowbridge ethereum-beacon-client rust](https://github.com/Snowfork/snowbridge/tree/main/parachain/pallets/ethereum-beacon-client)

* [snowbridge ethereum-light-client rust](https://github.com/Snowfork/snowbridge/tree/main/parachain/pallets/ethereum-light-client)

#### Token Lockers

* [snowbridge ERC20Vault.sol](https://github.com/Snowfork/snowbridge/blob/main/core/packages/contracts/contracts/ERC20Vault.sol)

### References

### Appendices


## Succinct Labs

* date: 2023-02-24
* last updated: 2023-02-24

### Overview

Succinct[^ov-1] is building Telepathy[^ov-2] a zkSNARK circuit that verifies Ethereum validator signatures, allowing for a gas-efficient light client to run as a smart contract on any EVM chain.

* [succint](https://github.com/succinctlabs)
  * [https://github.com/succinctlabs/plonky2-ecdsa](https://github.com/succinctlabs/plonky2-ecdsa)
  * [https://github.com/succinctlabs/gnark-plonky2-verifier](https://github.com/succinctlabs/gnark-plonky2-verifier)
  * [https://github.com/succinctlabs/telepathy-contracts](https://github.com/succinctlabs/telepathy-contracts)
    * [Arbitrary Message Bridge](https://github.com/succinctlabs/telepathy-contracts/tree/main/src/amb)
    * [https://github.com/succinctlabs/optimism-bedrock-contracts](https://github.com/succinctlabs/optimism-bedrock-contracts)
    * [https://github.com/succinctlabs/v3-core](https://github.com/succinctlabs/v3-core) (Business Source License 2023-04-01)

### Succinct Bridge Overview

1. [Succinct Blog Oct 29, 2022](https://blog.succinct.xyz/blog/proof-of-consensus): Proof of Consensus Bridging between Ethereum and Gnosis Chain

> The on-chain light client recreates the light client spec in Solidity (code here). In particular, we implement the process\_light\_client\_finality\_update function inside the step function in our smart contract. Then, inside step, where we would typically verify an aggregate BLS signature, we instead replace it with verification of a single Groth16 zkSNARK to reduce gas costs.
>
> Recall that the validator set of the sync committee rotates every 27 hours. On chain, we keep track of a commitment to the set of validators in the mapping syncCommitteeRootByPeriod. To update this mapping for the next period, we verify the merkle inclusion proof that the current validator set signs for the commitment for the next validator set. This computation happens inside the updateSyncCommittee function.
>
> Unfortunately, the commitment the validators sign is an SSZ commitment (simple serialization, Eth PoS serialization format) that is quite SNARK unfriendly, as it uses the SHA-256 hash function. It takes \~70 million constraints in a Groth16 circuit to compute the serialization of 512 validator BLS public keys to its corresponding SSZ commitment. Because we don’t want to do this for every single header verification proof (which happens every 6 minutes, i.e. once per epoch), we use an additional SNARK (the commitmentMappingProof argument) to provably map an SSZ commitment to a SNARK-friendly Poseidon commitment, that is stored in the mapping sszToPoseidon. For each BLS signature verification, we pass in the poseidon commitment of the sync committee validators as public input to ensure that the BLS signature we are verifying is from the correct public keys. Overall this approach (using 2 SNARKs) saves us 70M constraints on the BLS signature verification SNARK, which we must run for every update we wish to submit to the light client. The commitment mapping SNARK must only be run every sync committee period (roughly once every 27 hours).
>
> Toolchain
> We use the Circom programming language and the Groth16 proving system to generate our zkSNARKs. While a newer proof system (like PLONK arithmetization + KZG or FRI) would improve proving time, we believe Circom is the most production-ready zkSNARK stack today. In particular, Tornado Cash’s circuits are built on top of Circom and have been used for several years. Additionally, the on-chain verification cost of a Groth16 zkSNARK is the cheapest of all proving systems available today.

2. [eth-proof-of-consensus](https://github.com/succinctlabs/eth-proof-of-consensus): github repository
3. [GIP-57](https://forum.gnosis.io/t/gip-57-should-gnosis-dao-support-research-of-a-zksnark-enabled-light-client-and-bridge/5421): $600,000 Grant from Gnosis to Succinct to support
4. [Succinct Tweet](https://twitter.com/succinctlabs/status/1572299292177481729) : Succinct tweet giving an overview of the bridge
5. [Succinct Blog Sep 20, 2022](https://blog.succinct.xyz/post/2022/09/20/proof-of-consensus): Towards the endgame of blockchain interoperability with proof of consensus
6. [GIP-57](https://forum.gnosis.io/t/gip-57-should-gnosis-dao-support-research-of-a-zksnark-enabled-light-client-and-bridge/5421): $600,000 Grant from Gnosis to Succinct to support research of a zkSNARK-enabled light client and bridge.
7. [Succinct Video](https://youtu.be/cMSayTJA1B4): ZK8: Succinct Verification of Consensus with zkSNARKs - Uma Roy & John Guibas - Succinct Labs

### Trusted Setup

#### Best Practices for Setup

1. [Best Practices for Large Circuits](https://hackmd.io/V-7Aal05Tiy-ozmzTGBYPA): compiling and generating Groth16 proofs for large ZK circuits using the circom / snarkjs toolstack.

> For such large circuits, you need a machine with an Intel processor, lots of RAM and a large hard drive with swap enabled. For example, the zkPairing project used an AWS r5.8xlarge instance with 32-core 3.1GHz, 256G RAM machine with 1T hard drive and 400G swap.
>
> Compilation: for circuits with >20M constraints, one should not compile to WebAssembly because witness generation will exceed the memory cap of WebAssembly. For this reason, one must compile with the C++ flag and remove the wasm flag.

2. [Hermez Zero-Knowledge Proofs](https://blog.hermez.io/hermez-zero-knowledge-proofs/): Overview of the Hermez Trusted Setupi

[Machine](https://aws.amazon.com/ec2/pricing/on-demand/): AWS r5.8xlarge instance with 32-core 3.1GHz, 256G RAM machine with 1T hard drive and 400G swap. $2.016 per hour

#### Trusted Ceremony (Powers of Tau)

1. [Perpetual Powers of Tau](https://github.com/weijiekoh/perpetualpowersoftau): The goal is to securely generate zk-SNARK
2. [snarkjs Prepare phase 2](https://github.com/iden3/snarkjs/blob/master/README.md#7-prepare-phase-2): Provide instructions on prepare phase 2 and links to the Powers of Tau files.
3. [Powers of Tau files on Dropbox](https://www.dropbox.com/sh/mn47gnepqu88mzl/AACaJkBU7mmCq8uU8ml0-0fma?dl=0):

[Download powersOfTau28\_hez\_final\_27.ptau](https://hermez.s3-eu-west-1.amazonaws.com/powersOfTau28_hez_final_27.ptau): 144 GB file containing the encrypted evaluation of the Lagrange polynomials at tau for tau, alpha*tau and beta*tau. It takes the beacon ptau file we generated in the previous step, and outputs a final ptau file which will be used to generate the circuit proving and verification keys.

#### Example Build

1. [build\_aggregate\_bls\_verify.sh](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/circuits/circuits/aggregate_bls_verify.circom)

```
#!/bin/bash
PHASE1=/home/ubuntu/powersOfTau28_hez_final_27.ptau
BUILD_DIR=../build
CIRCUIT_NAME=test_aggregate_bls_verify_512
TEST_DIR=../test
OUTPUT_DIR="$BUILD_DIR"/"$CIRCUIT_NAME"_cpp

run() {
    if [ ! -d "$BUILD_DIR" ]; then
        echo "No build directory found. Creating build directory..."
        mkdir -p "$BUILD_DIR"
    fi

    # echo "****COMPILING CIRCUIT****"
    # start=`date +%s`
    # circom "$TEST_DIR"/circuits/"$CIRCUIT_NAME".circom --O1 --r1cs --sym --c --output "$BUILD_DIR"
    # end=`date +%s`
    # echo "DONE ($((end-start))s)"

    # echo "****Running make to make witness generation binary****"
    # start=`date +%s`
    # make -C "$OUTPUT_DIR"
    # end=`date +%s`
    # echo "DONE ($((end-start))s)"

    echo "****Executing witness generation****"
    start=`date +%s`
    ./"$OUTPUT_DIR"/"$CIRCUIT_NAME" "$TEST_DIR"/input_aggregate_bls_verify_512.json witness.wtns
    end=`date +%s`
    echo "DONE ($((end-start))s)"

    echo "****Converting witness to json****"
    start=`date +%s`
    npx snarkjs wej "$OUTPUT_DIR"/witness.wtns "$OUTPUT_DIR"/witness.json
    end=`date +%s`
    echo "DONE ($((end-start))s)"

    echo "****GENERATING ZKEY 0****"
    start=`date +%s`
    npx --trace-gc --trace-gc-ignore-scavenger --max-old-space-size=2048000 --initial-old-space-size=2048000 --no-global-gc-scheduling --no-incremental-marking --max-semi-space-size=1024 --initial-heap-size=2048000 --expose-gc snarkjs zkey new "$BUILD_DIR"/"$CIRCUIT_NAME".r1cs "$PHASE1" "$OUTPUT_DIR"/"$CIRCUIT_NAME"_p1.zkey
    end=`date +%s`
    echo "DONE ($((end-start))s)"

    echo "****CONTRIBUTE TO PHASE 2 CEREMONY****"
    start=`date +%s`
    npx snarkjs zkey contribute "$OUTPUT_DIR"/"$CIRCUIT_NAME"_p1.zkey "$OUTPUT_DIR"/"$CIRCUIT_NAME"_p2.zkey -n="First phase2 contribution" -e="some random text for entropy"
    end=`date +%s`
    echo "DONE ($((end-start))s)"

    echo "****VERIFYING FINAL ZKEY****"
    start=`date +%s`
    npx --trace-gc --trace-gc-ignore-scavenger --max-old-space-size=2048000 --initial-old-space-size=2048000 --no-global-gc-scheduling --no-incremental-marking --max-semi-space-size=1024 --initial-heap-size=2048000 --expose-gc npx snarkjs zkey verify "$BUILD_DIR"/"$CIRCUIT_NAME".r1cs "$PHASE1" "$OUTPUT_DIR"/"$CIRCUIT_NAME"_p2.zkey
    end=`date +%s`
    echo "DONE ($((end-start))s)"

    echo "****EXPORTING VKEY****"
    start=`date +%s`
    npx snarkjs zkey export verificationkey "$OUTPUT_DIR"/"$CIRCUIT_NAME"_p2.zkey "$OUTPUT_DIR"/"$CIRCUIT_NAME"_vkey.json
    end=`date +%s`
    echo "DONE ($((end-start))s)"

    echo "****GENERATING PROOF FOR SAMPLE INPUT****"
    start=`date +%s`
    ~/rapidsnark/build/prover "$OUTPUT_DIR"/"$CIRCUIT_NAME"_p2.zkey "$OUTPUT_DIR"/witness.wtns "$OUTPUT_DIR"/"$CIRCUIT_NAME"_proof.json "$OUTPUT_DIR"/"$CIRCUIT_NAME"_public.json
    end=`date +%s`
    echo "DONE ($((end-start))s)"

    echo "****VERIFYING PROOF FOR SAMPLE INPUT****"
    start=`date +%s`
    npx snarkjs groth16 verify "$OUTPUT_DIR"/"$CIRCUIT_NAME"_vkey.json "$OUTPUT_DIR"/"$CIRCUIT_NAME"_public.json "$OUTPUT_DIR"/"$CIRCUIT_NAME"_proof.json
    end=`date +%s`
    echo "DONE ($((end-start))s)"

    echo "****EXPORTING SOLIDITY SMART CONTRACT****"
    start=`date +%s`
    npx snarkjs zkey export solidityverifier "$OUTPUT_DIR"/"$CIRCUIT_NAME"_p2.zkey verifier.sol
    end=`date +%s`
    echo "DONE ($((end-start))s)"
}

mkdir -p logs
run 2>&1 | tee logs/"$CIRCUIT_NAME"_$(date '+%Y-%m-%d-%H-%M').log
```

### circuits

1. [Circom Documentation](https://docs.circom.io/getting-started/installation/): Circom is a novel domain-specific language for defining arithmetic circuits that can be used to generate zero-knowledge proofs.
2. [Circom github](https://github.com/iden3/circom)
3. [circomlib github](https://github.com/iden3/circomlib) contains a library of circuit templates.
4. [zkPairing Docs](https://0xparc.org/blog/zk-pairing-1): zkSNARKs for Elliptic Curve Pairings (Part 1)
5. [circom-paring github](https://github.com/yi-sun/circom-pairing): proof-of-concept implementations of elliptic curve pairings (in particular, the optimal Ate pairing and Tate pairing) for the BLS12-381 curve in circom.
6. [Batch ECDSA Verification (github)](https://github.com/puma314/batch-ecdsa): Implementation of batch ECDSA verification in circom.
7. [circom-ecdsa (github)](https://github.com/0xPARC/circom-ecdsa): proof-of-concept implementations of ECDSA operations in circom.
8. [snarkjs](https://www.npmjs.com/package/snarkjs): This is a JavaScript and Pure Web Assembly implementation of zkSNARK and PLONK schemes. It uses the Groth16 Protocol (3 point only and 3 pairings) and PLONK.
9. [snarkjs Prepare phase 2](https://github.com/iden3/snarkjs/blob/master/README.md#7-prepare-phase-2): Provide instructions on prepare phase 2 and links to the Powers of Tau files.
10. [Perpetual Powers of Tau](https://github.com/weijiekoh/perpetualpowersoftau): The goal is to securely generate zk-SNARK parameters for circuits of up to 2 ^ 28 (260+ million) constraints.
11. [Powers of Tau files on Dropbox](https://www.dropbox.com/sh/mn47gnepqu88mzl/AACaJkBU7mmCq8uU8ml0-0fma?dl=0):
12. [eth-proof-of-consensus: circuits aggregate\_bls\_verify.circom](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/circuits/circuits/aggregate_bls_verify.circom): example circuit with the following includes

```
include "../circom-pairing/circuits/bls_signature.circom";
include "../circom-pairing/circuits/curve.circom";
include "../circom-pairing/circuits/bls12_381_func.circom";
include "./sha256_bytes.circom";
```

### Contracts

Built using [foundry](https://book.getfoundry.sh/)([github](https://github.com/foundry-rs/foundry)) and [forge](https://book.getfoundry.sh/forge/). Verifiers ([Light Client Contracts](#light-client-contracts)) can be [generated](https://docs.circom.io/getting-started/proving-circuits/#verifying-from-a-smart-contract) from [circuits](#circuits) using [snarkjs](https://www.npmjs.com/package/snarkjs)

#### Library Contracts

1. [eth-proof-of-consensus/contracts/lib/](https://github.com/succinctlabs/eth-proof-of-consensus/tree/main/contracts/lib)
   1. [RLP decoder/reader](https://github.com/hamdiallam/Solidity-RLP): The reader contract provides an interface to first take RLP encoded bytes and convert them into an internal data structure, RLPItem through the function, toRlpItem(bytes).
   2. [curve-merkle-oracle](https://github.com/lidofinance/curve-merkle-oracle): Trustless price oracle for ETH/stETH Curve pool.

> Mechanics
> The oracle works by generating and verifying Merkle Patricia proofs of the following Ethereum state:
>
> Curve stETH/ETH pool contract account and the following slots from its storage trie:
>
> admin\_balances\[0]
> admin\_balances\[1]
> stETH contract account and the following slots from its storage trie:
>
> shares\[0xDC24316b9AE028F1497c275EB9192a3Ea0f67022]
> keccak256("lido.StETH.totalShares")
> keccak256("lido.Lido.beaconBalance")
> keccak256("lido.Lido.bufferedEther")
> keccak256("lido.Lido.depositedValidators")
> keccak256("lido.Lido.beaconValidators")

#### Light Client Contracts

1. [eth-proof-of-consensus: lightclient](https://github.com/succinctlabs/eth-proof-of-consensus/tree/main/contracts/src/lightclient)
   1. [BeaconLightClient.sol](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BeaconLightClient.sol)
   2. [PoseidonCommitmentVerifier.sol](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/PoseidonCommitmentVerifier.sol)
   3. [BLSAggregatedSignatureVerifier.sol](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BLSAggregatedSignatureVerifier.sol)

#### Bridge Contracts

1. [eth-proof-of-consensus: amb](https://github.com/succinctlabs/eth-proof-of-consensus/tree/main/contracts/src/amb): Arbitrary Message Bridge
   1. [Ethereum Magicians: A standard interface for arbitrary message bridges between chains/layers](https://ethereum-magicians.org/t/a-standard-interface-for-arbitrary-message-bridges-between-chains-layers/6163)
   2. [Token BridgeL ETH-xDai Arbitrary Message Bridge](https://docs.tokenbridge.net/eth-xdai-amb-bridge/about-the-eth-xdai-amb): An Arbitrary Message Bridge (AMB) between the Ethereum Mainnet and the xDai chain
2. [eth-proof-of-consensus: bridge](https://github.com/succinctlabs/eth-proof-of-consensus/tree/main/contracts/src/bridge)

#### Additional Contracts

1. [tokenbridge-contracts](https://github.com/succinctlabs/tokenbridge-contracts): core functionality for the POA bridge. They implement the logic to relay assests between two EVM-based blockchain networks. The contracts collect bridge validator's signatures to approve and facilitate relay operations. (forked from [omni](https://github.com/omni/tokenbridge-contracts))

### Relayer

*Note: no public repository for relay functionality was found in [succinctlabs github](https://github.com/succinctlabs).*

**TODO**: This section should give an overview of

* Communication Protocol
* Message Formatting
* Relayer CodeBase
* Relayers Roles : Creating Proofs relaying blocks etc.
* Economic incentives.

Additional References

1. [BeaconLightClient on Gnosis Chain](https://blockscout.com/xdai/mainnet/address/0xa3ae36abaD813241b75b3Bb0e9E7a37aeFD70807): Transactions every 50 blocks on Gnosis i.e. approximately every 3 minutes
2. [Succinct Blog Oct 29, 2022](https://blog.succinct.xyz/blog/proof-of-consensus/): Proof of Consensus Bridging between Ethereum and Gnosis Chain

> On Gnosis Chain, after the Ethereum block in which the deposit transaction was included is finalized (generally 2 epochs, \~12 minutes) and the light client has been updated with a block of height greater than or equal to this block, our relayer automatically submits an executeMessage transaction to the Gnosis AMB.

### Appendices

### Footnotes

[^ov-1]: [Succint](https://www.succinct.xyz/): Building the end game of interoperability with zkSNARKs

[^ov-2]: [Telepathy](https://docs.telepathy.xyz/): a zkSNARK circuit that verifies Ethereum validator signatures, allowing for a gas-efficient light client to run as a smart contract on any EVM chain.


## Horizon Bridge

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

This document reviews the [horizon](https://github.com/johnwhitton/horizon/tree/refactorV2) current implementation, development tasks that need to be done to support POW and offers some thoughts on next steps to support Ethereum 2.0 and other chains.

Further thoughts on ETH 2.0 support, removing the ETHHASH logic and SPV client and potentially replacing with MMR trees per epoch and checkpoints similar to Harmony Light Client on Ethereum, can be found [here](/research/chains/ethereum.mdx).

### Next Steps

Following are some of the improvements needed broken down by functional areas.

#### Ethereum Light Client

1. ETH 2.0 support see [here](/research/chains/ethereum.mdx)
2. Queuing mechanism should be implemented to queue bridge transactions. The queue can be polled as part of the block relay functionality to process bridge transactions once the blocks have been relayed.
3. Consider whether we can use p2p messaging to receive published blocks rather than looping and polling via an RPC.

#### Harmony Light Client

1. Needs to implement a process to `submitCheckpoint`.
2. `eprove` logic needs to be reviewed
3. Queuing mechanism should be implemented to queue bridge transactions. The queue can be polled as part of the `submitCheckpoint` functionality to process bridge transactions once the blocks have been relayed.
4. Need to facilitate the core protocol [MMR enhancements PR](https://github.com/harmony-one/harmony/pull/4198/files)

#### Transaction Sequencing

Sequencing of Transactions: Needs to be implemented and `TokenMap` in `bridge.js` needs to be refactored. Below is the current sequence flow and areas for improvements.

1. Ethereum Mapping Request
2. Relay of Block to EthereumLightClient.sol on Harmony
   * The block has to be relayed before we can process the Harmony Mapping request, as we have just executed the transaction the relayer usually has not relayed the block so this will fail.
   * There must be an additional 25 blocks on Ethereum before this block can be considered part of the canonical chain.
   * This logic needs to be rewritten to break down execution for 1. the ethereum mapping request 2. After a 25 block delay the Harmony Proof validation and executing the Harmony Mapping Request\*\*
3. Harmony Mapping Request
4. Relay of Checkpoint to HarmonyLightClient.sol on Ethereum
   * A `submitCheckpoint` in `HarmonyLightClient.sol` needs to have called either for the next epoch or for a checkpoint, after the block the harmony mapping transaction was in.\*\*
   * Automatic submission of checkpoints to the Harmony Light Client has not been developed as yet. (It is not part of the `ethRelay.js`). And so the checkpoint would need to be manually submitted before the Ethereum Mapping could take place.
5. Etherem Process Harmony Mapping Acknowledgement

#### Bridge Functionality

1. Need to support mapping Harmony Tokens to Ethereum

#### MultiChain Support

1. Need to support other chains
   * EVM: BSC, Polygon, Avalanche, Arbitrum, Optimism
   * Bitcoin
   * NEAR
   * Solana
   * Polkadot
2. Links to initial Design thoughs including reviews of cross chain messaging protocols and other multichain bridges can be found in Multichain Trustless Bridge : Draft.

### Current Implementation Walkthough

Following is a detailed walk though of the current implementation of the Ethereum Light Client and the flow for mapping tokens from Ethereum to Harmony.

### Ethereum Light Client (on Harmony)

**Design**
Existing Design

1. DAG is generated for each Ethereum EPOCH: This takes a couple of hours and has a size of approx 1GB.
2. Relayer is run to replicate each block header to the SPV Client on Harmony.
3. EthereumLightClient.sol addBlockHeader: Adds each block header to the Ethereum Light Client.
4. Transactions are Verified

**Running the Relayer**

```
# Start the relayer (note: replace the etherum light client address below)
# relay [options] <ethUrl> <hmyUrl> <elcAddress>   relay eth block header to elc on hmy
 yarn cli ethRelay relay http://localhost:8645 http://localhost:9500 0x3Ceb74A902dc5fc11cF6337F68d04cB834AE6A22
```

**Implementation**

1. DAG Generation can be done explicity by calling `dagProve` from the CLI or it is done automatically by `getHeaderProof` in `ethHashProof/BlockProof.js` which is called from `blockRelay` in `cli/ethRelay.js`.
2. Relaying of Block Headers is done by `blockRelayLoop` in `cli/ethRelay.js` which
   * Reads the last block header from EthereumLightClient.sol
   * Loops through calling an Ethereum RPC per block to retrieve the blockHeader using `return eth.getBlock(blockNo).then(fromRPC)` in function `getBlockByNumber` in `eth2hmy-relay/getBlockHeader.js`
3. Adding BlockHeaders is done by `await elc.addBlockHeader(rlpHeader, proofs.dagData, proofs.proofs)` which is called from `cli/ethRelay.js`. `addBlockHeader` in `EthereumLightClient.sol`
   * calculates the blockHeader Hash
   * and checks that it
     * hasn't already been relayed,
     * is the next block to be added,
     * has a valid timestamp
     * has a valid difficulty
     * has a valid Proof of Work (POW)
   * Check if the canonical chain needs to be replaced by another fork

#### Mapping Tokens (Ethereum to Harmony)

**Design**

1. If the Token Has not already been mapped on Harmony
   * Harmony: Create an ERC20 Token
   * Harmony: Map the Ethereum Token to the new ERC20 Contract
   * Ethereum: Validate the Harmony Mapping Transaction
   * Ethereum: Map the Harmony ERC20 token to the existing Ethereum Token
   * Harmony: Validate the Ethereum mapping Transaction

*Note: The key difference between `TokenLockerOnEthereum.sol` and `TokenLockerOnHarmony.sol` is the proof validation. `TokenLockerOnEthereum.sol` uses `./lib/MMRVerifier.sol` to validate the [Mountain Merkle Ranges](https://github.com/opentimestamps/opentimestamps-server/blob/master/doc/merkle-mountain-range.mdx) on Harmony and `HarmonyProver.sol`. `TokenLockerOnHarmony.sol` imports `./lib/MPTValidatorV2.sol` to validate [Merkle Patrica Trie](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/#merkle-patricia-trees) and `./EthereumLightClient.sol`.*

*Note: `validateAndExecuteProof` is responsible for creation of the BridgeTokens on the destination chain it does this by calling `execute` call in `TokenLockerLocker.sol` which then calls the function `onTokenMapReqEvent` in `TokenRegistry.sol` which creates a new Bridge Token `BridgedToken mintAddress = new BridgedToken{salt: salt}();` and then initializes it. This uses [(RLP) Serialization](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/)*

*Note: The shims in `ethWeb3.js` provide simplified functions for `ContractAt`, `ContractDeploy`, `sendTx` and `addPrivateKey` and have a constructor which uses `process.env.PRIVATE_KEY`.*

**Mapping the Tokens**

```
# Map the Tokens
# map <ethUrl> <ethBridge> <hmyUrl> <hmyBridge> <token>
yarn cli Bridge map http://localhost:8645 0x017f8C7d1Cb04dE974B8aC1a6B8d3d74bC74E7E1 http://localhost:9500 0x017f8C7d1Cb04dE974B8aC1a6B8d3d74bC74E7E1 0x4e59AeD3aCbb0cb66AF94E893BEE7df8B414dAB1
```

**Implementation**

* The CLI calls `tokenMap` in `src/bridge/contract.js` to
  * Instantiate the Ethereum Bridge and Harmony Bridge Contracts
  * Calls `TokenMap` in `scr/bridge/bridge.js` to
    * Issue a token Map request on Ethereum `const mapReq = await src.IssueTokenMapReq(token)`
    * Acknowledge the Map Request on Harmony `const mapAck = await Bridge.CrossRelayEthHmy(src, dest, mapReq)`
    * Issue a token Map request on Harmony `return Bridge.CrossRelayHmyEth(dest, src, mapAck.transactionHash)`

**Here is the Logic (call execution overview) when Mapping Tokens across Chains. *NOTE: Currently mapping has only been developed from Ethereum to Harmony (not bi-directional)*.**

1. Bridge Map is called in src.cli.index.js and it calls `tokenMap` in `bridge/contract.js` which
   * Get srcBridge Contract on Ethereum `TokenLockerOnEthereum.sol` from `ethBridge.js` it also instantiates an `eprover` using `tools/eprover/index.js` which calls `txProof.js` which uses [eth-proof npm package](https://www.npmjs.com/package/eth-proof). *Note: this is marked with a //TODO need to test and develop proving logic on Harmony.*
   * Get destBridge Contract on Hamony `TokenLockerOnHarmony.sol` from `hmyBridge.js` it also instantiates an `hprove` using `tools/eprover/index.js` which calls `txProof.js` which uses [eth-proof npm package](https://www.npmjs.com/package/eth-proof).
   * calls `TokenMap` in `bridge.js`
2. `TokenMap` Calls IssueTokenMapReq (on the Ethreum Locker) returning the `mapReq.transactionHash`
   * `IssueTokenMapReq(token)` is held in `bridge.js` as part of the bridge class
   * It calls `issueTokenMapReq` on `TokenLockerOnEthereum.sol` which is implemented by `TokenRegistry.sol`
   * `issueTokenMapReq` checks if the token has already been mapped if not it was emitting a `TokenMapReq` with the details of the token to be mapped. However this was commented out as it was felt that, if it has not been mapped, we use the `transactionHash` of the mapping request\` to drive the logic below (not the event).
3. `TokenMap` calls `Bridge.CrossRelay` with the IssueTokenMapReq.hash to
   * gets the proof of the transaction on Ethereum via `getProof` calling `prover.ReceiptProof` which calls the eprover and returns `proof` with
     * `hash: sha3(resp.header.serialize()),`
     * `root: resp.header.receiptRoot,`
     * `proof: encode(resp.receiptProof),`
     * `key: encode(Number(resp.txIndex)) // '0x12' => Nunmber`
   * We then call `dest.ExecProof(proof)` to execute the proof on Harmony
     * This calls `validateAndExecuteProof` on `TokenLockerOnHarmony.sol` with the `proofData` from above, which
       * requires `lightclient.VerifyReceiptsHash(blockHash, rootHash),` implemented by `./EthereumLightClient.sol`
         * This returns `return bytes32(blocks[uint256(blockHash)].receiptsRoot) == receiptsHash;`
         * **Which means the block has to be relayed first, as we have just executed the transaction the relayer usually has not relayed the block so this will fail**
       * requires `lightclient.isVerified(uint256(blockHash)` implemented by `./EthereumLightClient.sol`
         * This returns `return canonicalBlocks[blockHash] && blocks[blockHash].number + 25 < blocks[canonicalHead].number;`
         * **Which means there must be an additional 25 blocks on Ethereum before this can be processed. This logic needs to be rewritten to break down execution for 1. the ethereum mapping request 2. After a 25 block delay the Harmony Proof validation and executing the Harmony Mapping Request**
       * `require(spentReceipt[receiptHash] == false, "double spent!");` to ensure that we haven't already executed this proof
       * gets the `rlpdata` using `EthereumProver.validateMPTProof` implemented by `EthereumProver.sol` which
         * Validates a Merkle-Patricia-Trie proof.
         * Returns a value whose inclusion is proved or an empty byte array for a proof of exclusion
       * marks `spentReceipt[receiptHash] = true;`
       * `execute(rlpdata)` implemented by `TokenLocker.sol` which calls `onTokenMapReqEvent(topics, Data)` implemented by `TokenRegistry.sol`
         * `address tokenReq = address(uint160(uint256(topics[1])));` gets the address of the token to be mapped.
         * require `address(RxMapped[tokenReq]) == address(0)` that the token has not already been mapped.
         * `address(RxMapped[tokenReq]) == address(0)` creates a new BridgedToken implemented by `BridgedToken.sol`
           * `contract BridgedToken is ERC20Upgradeable, ERC20BurnableUpgradeable, OwnableUpgradeable` it is a standard openzepplin ERC20 Burnable, Ownable, Upgradeable token
         * `mintAddress.initialize` initialize the token with the same `name`, `symbol` and `decimals` as the ethereum bridged token
         * `RxMappedInv[address(mintAddress)] = tokenReq;` updates the inverse Key Value Mapping
         * `RxMapped[tokenReq] = mintAddress;` updates the Ethereum mapped tokens
         * `RxTokens.push(mintAddress);` add the newly created token to a list of bridged tokens
         * `emit TokenMapAck(tokenReq, address(mintAddress));`
       * `require(executedEvents > 0, "no valid event")` to check if it executed the mapping correctly.
4. We then take the Harmony Mapping `transactionHash` and repeat the above process to prove the Harmony mapping acknowledgment on Ethereum (Cross Relay second call) `return Bridge.CrossRelay(dest, src, mapAck.transactionHash);`

* gets the proof of the transaction on Harmony via `getProof` calling `prover.ReceiptProof` which calls the eprover and returns `proof` with
  \_`hash: sha3(resp.header.serialize()),`
  \_ `root: resp.header.receiptRoot,`
  \_`proof: encode(resp.receiptProof),`
  \_ `key: encode(Number(resp.txIndex)) // '0x12' => Nunmber`
  * We then call `dest.ExecProof(proof)` to execute the proof on Ethereum
    * This calls `validateAndExecuteProof` on `TokenLokerOnEthereum.sol` with the `proofData` from above, which
      * `require(lightclient.isValidCheckPoint(header.epoch, mmrProof.root),` implemented by `HarmonyLightClient.sol`
        * `return epochMmrRoots[epoch][mmrRoot]` which means that the epoch has to have had a checkpoint submitted via `submitCheckpoint`
      * `bytes32 blockHash = HarmonyParser.getBlockHash(header);` gets the blockHash implemented by `HarmonyParser.sol`
        * This returns `return keccak256(getBlockRlpData(header));`
        * `getBlockRlpData` creates a list `bytes[] memory list = new bytes[](15);` and uses statements like `list[0] = RLPEncode.encodeBytes(abi.encodePacked(header.parentHash));` to perform [Recursive-Length Prefix (RLP) Serialization](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/) implemented by `RLPEncode.sol`
      * `HarmonyProver.verifyHeader(header, mmrProof);` verifys the header implemented by `HarmonyProver.sol`
        * `bytes32 blockHash = HarmonyParser.getBlockHash(header);` gets the blockHash implemented by `HarmonyParser.sol` as above
        * `valid = MMRVerifier.inclusionProof(proof.root, proof.width, proof.index, blockHash, proof.peaks, proof.siblings);` verifys the proff using the [Merkle Mountain Range Proof](https://github.com/opentimestamps/opentimestamps-server/blob/master/doc/merkle-mountain-range.mdx) passed `MMRVerifier.MMRProof memory proof` and the `blockHash`.
        * **NOTE: This means that a `submitCheckpoint` in `HarmonyLightClient.sol` needs to have called either for the next epoch or for a checkpoint, after the block the harmony mapping transaction was in.**
        * **NOTE: Automatic submission of checkpoints to the Harmony Light Client has not been developed as yet. (It is not part of the `ethRelay.js`). And so the checkpoint would need to be manually submitted before the Ethereum Mapping could take place.**
      * `require(spentReceipt[receiptHash] == false, "double spent!");` ensure that we haven't already processed this mapping request\`
      * `HarmonyProver.verifyReceipt(header, receiptdata)` ensure the receiptdata is valid
      * `spentReceipt[receiptHash] = true;` marks the receipt as having been processed
      * `execute(receiptdata.expectedValue);` implemented by `TokenLocker.sol` which calls `onTokenMapAckEvent(topics)` implemented by `TokenRegistry.sol`
        * `address tokenReq = address(uint160(uint256(topics[1])));`
        * `address tokenAck = address(uint160(uint256(topics[2])));`
        * `require(TxMapped[tokenReq] == address(0), "missing mapping to acknowledge");`
        * `TxMapped[tokenReq] = tokenAck;`
        * `TxMappedInv[tokenAck] = IERC20Upgradeable(tokenReq);`
        * `TxTokens.push(IERC20Upgradeable(tokenReq));`

5. Upon completion of tokenMap control is passed back to Bridge Map which
6. Calls TokenPair on Ethereum
7. Calls ethTokenInfo to get the status of the ERC20
8. Calls hmyTokenInfo to get the tokenStatus on Harmony


## Ethereum Near Bridging

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

This document reviews the Ethereum 2.0 specifications including Light Client specifications. It does a detailed review of the NEAR Rainbow Bridge implementation and also includes references to Harmony's design to support Mountain Merkle Ranges.

Key differences in supporting Ethereum 2.0 (Proof of Stake) vs Proof of Work involves removing the ETHHASH logic and SPV client and potentially replacing with MMR trees per epoch and checkpoints similar to Harmony Light Client on Ethereum.

### Ethereum 2.0 Specifications

* [Beacon Chain Specification](https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.mdx)
* [Extended light client protocol](https://notes.ethereum.org/@vbuterin/extended_light_client_protocol)
* [Altair Light Client -- Light Client](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/light-client.mdx)
* [Altair Light Client -- Sync Protocol](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.mdx)
* [Beacon Chain Fork Choice](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/fork-choice.mdx)

### Ethereum 2.0 Light Client Support

How light client implementation and verification of ETH and ETH2 can be done via smart contracts in other protocols.

For this we review three Key items

1. Light Client Specifications including [Extended light client protocol](https://notes.ethereum.org/@vbuterin/extended_light_client_protocol) described by [Altair Light Client -- Sync Protocol](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.mdx) and the [The Portal Network Specification](https://github.com/ethereum/portal-network-specs)
2. Near Rainbow Bridge Light Client Walkthrough include [eth2near-block-relay-rs](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/eth2near-block-relay-rs), [nearbridge contracts](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearbridge) and [nearprover contracts](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearprover)
3. Prysm light-client [prototype](https://github.com/jinfwhuang/prysm/tree/jin-light/cmd/light-client)

*Note: Time on Ethereum 2.0 Proof of Stake is divided into slots and epochs. One slot is 12 seconds. One epoch is 6.4 minutes, consisting of 32 slots. One block can be created for each slot.*

#### Light Client Specification

##### Altair Light Client -- Sync Protocol

* [Altair Light Client -- Sync Protocol](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.mdx): The beacon chain is designed to be light client friendly for constrained environments to access Ethereum with reasonable safety and liveness.

  Such environments include resource-constrained devices (e.g. phones for trust-minimized wallets)and metered VMs (e.g. blockchain VMs for cross-chain bridges).

  This document suggests a minimal light client design for the beacon chain thatuses sync committees introduced in [this beacon chain extension](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/beacon-chain.mdx).

  Additional documents describe how the light client sync protocol can be used:

  * [Full node](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/full-node.mdx)
  * [Light client](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/light-client.mdx)
  * [Networking](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/p2p-interface.mdx)

* [Light client sync process](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/light-client.mdx): explains how light clients MAY obtain light client data to sync with the network.
  1. The light client MUST be configured out-of-band with a spec/preset (including fork schedule), with `genesis_state` (including `genesis_time` and `genesis_validators_root`), and with a trusted block root. The trusted block SHOULD be within the weak subjectivity period, and its root SHOULD be from a finalized `Checkpoint`.
  2. The local clock is initialized based on the configured `genesis_time`, and the current fork digest is determined to browse for and connect to relevant light client data providers.
  3. The light client fetches a [`LightClientBootstrap`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/light-client.mdx) object for the configured trusted block root. The `bootstrap` object is passed to [`initialize_light_client_store`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#initialize_light_client_store) to obtain a local [`LightClientStore`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#lightclientstore).
  4. The light client tracks the sync committee periods `finalized_period` from `store.finalized_header.slot`, `optimistic_period` from `store.optimistic_header.slot`, and `current_period` from `current_slot` based on the local clock.
     1. When `finalized_period == optimistic_period` and [`is_next_sync_committee_known`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#is_next_sync_committee_known) indicates `False`, the light client fetches a [`LightClientUpdate`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#lightclientupdate) for `finalized_period`. If `finalized_period == current_period`, this fetch SHOULD be scheduled at a random time before `current_period` advances.
     2. When `finalized_period + 1 < current_period`, the light client fetches a `LightClientUpdate` for each sync committee period in range `[finalized_period + 1, current_period)` (current period excluded)
     3. When `finalized_period + 1 >= current_period`, the light client keeps observing [`LightClientFinalityUpdate`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#lightclientfinalityupdate) and [`LightClientOptimisticUpdate`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#lightclientoptimisticupdate). Received objects are passed to [`process_light_client_finality_update`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#process_light_client_finality_update) and [`process_light_client_optimistic_update`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#process_light_client_optimistic_update). This ensures that `finalized_header` and `optimistic_header` reflect the latest blocks.
  5. [`process_light_client_store_force_update`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#process_light_client_store_force_update) MAY be called based on use case dependent heuristics if light client sync appears stuck. If available, falling back to an alternative syncing mechanism to cover the affected sync committee period is preferred.

##### The Portal Network

* [The Portal Network](https://github.com/ethereum/portal-network-specs): The Portal Network is an in progess effort to enable lightweight protocol access by resource constrained devices. The term *"portal"* is used to indicate that these networks provide a *view* into the protocol but are not critical to the operation of the core Ethereum protocol.

  The Portal Network is comprised of multiple peer-to-peer networks which together provide the data and functionality necessary to expose the standard [JSON-RPC API](https://eth.wiki/json-rpc/API). These networks are specially designed to ensure that clients participating in these networks can do so with minimal expenditure of networking bandwidth, CPU, RAM, and HDD resources.

  The term 'Portal Client' describes a piece of software which participates in these networks. Portal Clients typically expose the standard JSON-RPC API.

  * Motivation: The Portal Network is focused on delivering reliable, lightweight, and decentralized access to the Ethereum protocol.

  * Prior Work on the "Light Ethereum Subprotocol" (LES): The term "light client" has historically refered to a client of the existing [DevP2P](https://github.com/ethereum/devp2p/blob/master/rlpx.mdx) based [LES](https://github.com/ethereum/devp2p/blob/master/caps/les.mdx) network. This network is designed using a client/server architecture. The LES network has a total capacity dictated by the number of "servers" on the network. In order for this network to scale, the "server" capacity has to increase. This also means that at any point in time the network has some total capacity which if exceeded will cause service degradation across the network. Because of this the LES network is unreliable when operating near capacity.

* Block Relay
  * [Beacon State](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/beacon-state-network.md#dht-overview): A client has a trusted beacon state root, and it wants to access some parts of the state. Each of the access request corresponds to some leave nodes of the beacon state. The request is a content lookup on a DHT. The response is a Merkle proof.

    A Distributed Hash Table (DHT) allows network participants to have retrieve data on-demand based on a content

  * [Syncing Block Headers](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/sync-gossip.mdx): A beacon chain client could sync committee to perform state updates. The data object LightClientSkipSyncUpdate allows a client to quickly sync to a recent header with the appropriate sync committee. Once the client establishes a recent header, it could sync to other headers by processing LightClientUpdates. These two data types allow a client to stay up-to-date with the beacon chain.
    * [Sync State](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/skip-sync-network.mdx): A client uses SkipSyncUpdate to skip sync from a known header to a recent header. A client with a trusted but outdated header cannot use the messages in the gossip channel bc-light-client-update to update. The client's sync-committee in the stored snapshot is too old and not connected to any update messages. The client look for the appropriate SkipSyncUpdate to skip sync its header.
    * [Advance Block Headers](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/sync-gossip.mdx): A beacon chain client could sync committee to perform [state updates](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/sync-protocol.mdx). The data object [LightClientSkipSyncUpdate](skip-sync-network) allows a client to quickly sync to a recent header with the appropriate sync committee. Once the client establishes a recent header, it could sync to other headers by processing [LightClientUpdates](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/sync-protocol.md#lightclientupdate). These two data types allow a client to stay up-to-date with the beacon chain.

      These two data types are placed into separate sub-networks. A light client make find-content requests on `skip-sync-network` at start of the sync to get a header with the same `SyncCommittee` object as in the current sync period. The client uses messages in the gossip topic `bc-light-client-update` to advance its header.

      The gossip topics described in this document is part of a [proposal](https://ethresear.ch/t/a-beacon-chain-light-client-proposal/11064) for a beacon chain light client.

##### Transaction Proofs

* [Retrieving Beacon State](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/beacon-state-network.mdx): A client has a trusted beacon state root, and it wants to access some parts of the state. Each of the access request corresponds to some leave nodes of the beacon state. The request is a content lookup on a DHT. The response is a Merkle proof.

  A Distributed Hash Table (DHT) allows network participants to have retrieve data on-demand based on a content key. A portal-network DHT is different than a traditional one in that each participant could selectively limit its workload by choosing a small interest radius r. A participants only process messages that are within its chosen radius boundary.

  * [Wire Protocol](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/beacon-state-network.md#wire-protocol): For a subprotocol, we need to further define the following to be able to instantiate the wire format of each message type. 1. `content_key` 2. `content_id` 3. `payload`

    The content of the message is a Merkle proof contains multiple leave nodes for a [BeaconState](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/beacon-chain.md#beaconstate).

    Finally, we define the necessary encodings. A light client only knows the root of the beacon state. The client wants to know the details of some leave nodes. The client has to be able to construct the `content_key` only knowing the root and which leave nodes it wants see. The `content_key` is the ssz serialization of the paths. The paths represent the part of the beacon state that one wants to know about. The paths are represented by generalized indices. Note that `hash_tree_root` and `serialize` are the same as those defined in [sync-gossip](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/sync-gossip.mdx).

* TODO: Review of Retrieving a transaction proof not just retrieving data on-demand

##### References

* Ethereum 2.0 Specifications
  * [Beacon Chain Specification](https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.mdx)
  * [Extended light client protocol](https://notes.ethereum.org/@vbuterin/extended_light_client_protocol)
  * [Altair Light Client -- Light Client](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/light-client.mdx)
  * [Altair Light Client -- Sync Protocol](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.mdx)
  * [Beacon Chain Fork Choice](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/fork-choice.mdx)
  * [The Portal Network Specification](https://github.com/ethereum/portal-network-specs): an in progess effort to enable lightweight protocol access by resource constrained devices.

* [Light Ethereum Subprotocol (LES)](https://github.com/ethereum/devp2p/blob/master/caps/les.mdx): the protocol used by "light" clients, which only download block headers as they appear and fetch other parts of the blockchain on-demand.

* [BlockDaemon: Ethereum Altair Hard Folk: Light Clients & Sync Committees](https://blockdaemon.com/blog/ethereum-altair-hard-folk-light-clients-sync-committees/)

* [Efficient algorithms for CBC Casper](https://docs.google.com/presentation/d/1oc_zdywOsHxz3zez1ILAgrerS7RkaF1hHoW0FLtp0Gw/edit#slide=id.p): Review of LMD GHOST (Latest Message Driven, Greediest Heaviest Observed Sub-Tree)

* [SSZ: Simple Serialize](https://ethereum.org/en/developers/docs/data-structures-and-encoding/ssz/): Overview of Simple serialize (SSZ) is the serialization method used on the Beacon Chain. (including merkalization and multiproofs)

* [The Noise Protocol Framework](https://noiseprotocol.org/noise.html): Noise is a framework for crypto protocols based on Diffie-Hellman key agreement.

* [Flashbots for Ethereum Consensus Clients](https://hackmd.io/QoLwVQf3QK6EiVt15YOYqQ?view)

* [Optimistic Sync Specification](https://github.com/ethereum/consensus-specs/blob/dev/sync/optimistic.mdx): Optimistic Sync is a stop-gap measure to allow execution nodes to sync via established methods until future Ethereum roadmap items are implemented (e.g., statelessness).

* [Consensus Light Client Server Implementation Notes](https://hackmd.io/hsCz1G3BTyiwwJtjT4pe2Q?view): How Lodestar beacon node was tweaked to serve light clients

* [beacon chain light client design doc](https://notes.ethereum.org/@ralexstokes/HJxDMi8vY): notes about the design/implementation of a beacon chain light client using standard APIs and protocol features

* [A Beacon Chain Light Client Proposal](https://ethresear.ch/t/a-beacon-chain-light-client-proposal/11064): proposing a light client implementation that goes a step further than the minimum light client described in the altair consensus-spec. The proposed client aims to allow queries into the beacon state.

* [Distributed Hash Table (DHT) Overview](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/beacon-state-network.md#dht-overview): allows network participants to have retrieve data on-demand based on a content key.

* [(WIP) Light client p2p interface Specification](https://github.com/ethereum/consensus-specs/pull/2786): a PR to get the conversation going about a p2p approach.

#### Near Rainbow Bridge Ethereum Light Client Walkthrough

The following is a walkthrough of how a transaction executed on Ethereum is propogated to NEAR's [eth2-client](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/near/eth2-client). See [Cryptographic Primitives](#cryptographic-primitives) for more information on the cryptography used.

**At a high level the ethereum light client contract**

* Optionally accepts client updates only from a trusted client
* Can pause functions
* Validates a sync committee exists for the curremt slot
* Validates sync committe has greater than the minimum required sync committee members
* Validates 2/3 or more of the committe members have signed the blocks
* Validates bls signatures (i.e. the bls signatures of the sync comittee for the blocks propogated)
* Stores the hashes of the blocks for the past `hashes_gc_threshold` headers. Events that happen past this threshold cannot be verified by the client. It is desirable that this number is larger than 7 days' worth of headers, which is roughly 51k Ethereum blocks. So this number should be 51k in production.
* Stores the Ethereum Network (e.g. mainnet, kiln)
* Stores Hashes of the finalized execution blocks mapped to their numbers.
* Stores All unfinalized execution blocks' headers hashes mapped to their `HeaderInfo`.
* Stores `AccountId`s mapped to their number of submitted headers.
* Stores Max number of unfinalized blocks allowed to be stored by one submitter account. This value should be at least 32 blocks (1 epoch), but the recommended value is 1024 (32 epochs)
* Stores minimum balance that should be attached to register a new submitter account.
* Stores finalized beacon header
* Stores finalized execution header
* Stores current\_sync\_committee
* Stores next\_sync\_committee

##### Ethereum to NEAR block propagation flow

* [Light Clients are deployed on Near](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/main.rs#L107):
  * [init\_contract](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/main.rs#L107): The eth2near relayer is called with an argument to initialize the [eth2-client contract](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs)
    * [eth\_client\_contract](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/main.rs#L108): is created using a contract\_wrapper
      * `let mut eth_client_contract = EthClientContract::new(get_eth_contract_wrapper(&config));`
    * [EthClientContract Wrapper](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/contract_wrapper/src/eth_client_contract.rs): creates an instance of [eth2-client contract](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs) with the following arguments
      * `network` - the name of Ethereum network such as `mainnet`, `goerli`, `kiln`, etc.
      * `finalized_execution_header` - the finalized execution header to start initialization with.
      * `finalized_beacon_header` - correspondent finalized beacon header.
      * `current_sync_committee` - sync committee correspondent for finalized block.
      * `next_sync_committee` - sync committee for the next period after period for finalized block.
      * `hashes_gs_threshold` - the maximum number of stored finalized blocks.
      * `max_submitted_block_by_account` - the maximum number of unfinalized blocks which one relay can store in the client's storage.
      * `trusted_signer` - the account address of the trusted signer which is allowed to submit light client updates.
* [Relayer is Created](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/main.rs#L111):
  * [eth2near\_relay](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/main.rs#L111) is created using the following arguments
    * `let mut eth2near_relay = Eth2NearRelay::init(&config, get_eth_client_contract(&config), args.enable_binary_search, args.submit_only_finalized_blocks,);`
* [Relayer is Started](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/main.rs):
  * The relayer is started using `eth2near_relay.run(None);`
  * This executes the [eth2near\_relay run function](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L257) `pub fn run(&mut self, max_iterations: Option<u64>)` which runs until terminated doing using the following loop `while !self.terminate`
    * `self.wait_for_synchronization(),`: gets the sync status
    * `sleep(Duration::from_secs(12));`: waits for 12 seconds
    * `self.get_max_slot_for_submission()`: gets the maximum slot for submission from Ethereum
    * `self.get_last_eth2_slot_on_near`: gets the latest slot propogated from Ethereum to NEAR
    * `if last_eth2_slot_on_near < max_slot_for_submission`: If there are slots to process
      * `self.get_execution_blocks_between(last_eth2_slot_on_near + 1, max_slot_for_submission,),`: Get the execution blocks to be processed
      * `self.submit_execution_blocks(headers, current_slot, &mut last_eth2_slot_on_near)`: submit them
      * `were_submission_on_iter = true;`: flags that there were submissions
    * `were_submission_on_iter |= self.send_light_client_updates_with_checks(last_eth2_slot_on_near);`: send light\_client updates with checks and updates the submission flag to true if if passes. Following is some key logic
      * `self.is_enough_blocks_for_light_client_update`: Checks if there are enough blocks for a light client update
        * `self.send_light_client_updates` calls `send_light_client_update` which
          * `if last_finalized_slot_on_eth >= last_finalized_slot_on_near + self.max_blocks_for_finalization`: checks if the gap is too big (i.e. we are at a new slot) between slot of finalized block on NEAR and ETH. If it is it sends a hand made client update (which will loop getting the new slots sync committees) otherwise it sends a regular client update (which propogates the block headers)
            * `self.send_hand_made_light_client_update(last_finalized_slot_on_near);`
              * `let include_next_sync_committee = BeaconRPCClient::get_period_for_slot (last_finalized_slot_on_near) != BeaconRPCClient::get_period_for_slot(attested_slot);`
            * `self.send_regular_light_client_update(last_finalized_slot_on_eth, last_finalized_slot_on_near,);`
          * `self.send_specific_light_client_update(light_client_update)` is called for both regular and hand made updates.
            * `self.eth_client_contract.is_known_block`: Checks if the block is already known on the Etherum Client Contract on NEAR
            * `self.verify_bls_signature_for_finality_update(&light_client_update)`: Verifies the BLS signatures. This calls `is_correct_finality_update` in `eth2near/finality-update-verify/src/lib.rs` \*
            * `self.eth_client_contract.send_light_client_update(light_client_update.clone())`: Updates the light client with the finalized block
            * `self.beacon_rpc_client.get_block_number_for_slot(types::Slot::new(light_client_update.finality_update.header_update.beacon_header.slot.as_u64())),`: Validates Finalized block number is correct on Ethereum usng the `beacon_rpc_client`.
            * `sleep(Duration::from_secs(self.sleep_time_after_submission_secs));`: sleeps for the configured submission sleep time.
    * `if !were_submission_on_iter {thread::sleep(Duration::from_secs(self.sleep_time_on_sync_secs));}`: if there were submissions sleep for however many seconds were configured for sync sleep time.

##### Ethereum to NEAR block propagation components

* [EthClientContract Wrapper](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/contract_wrapper/src/eth_client_contract.rs): supports [eth2-client contract](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs) functions `impl EthClientContractTrait for EthClientContract`
  * `fn get_last_submitted_slot(&self) -> u64`
  * `fn is_known_block(&self, execution_block_hash: &H256) -> Result<bool, Box<dyn Error>>`
  * `fn send_light_client_update(&mut self, light_client_update: LightClientUpdate,) -> Result<FinalExecutionOutcomeView, Box<dyn Error>>`
  * `fn get_finalized_beacon_block_hash(&self) -> Result<H256, Box<dyn Error>>`
  * `fn get_finalized_beacon_block_slot(&self) -> Result<u64, Box<dyn Error>>`
  * `fn send_headers(&mut self, headers: &[BlockHeader], end_slot: u64,) -> Result<FinalExecutionOutcomeView, Box<dyn std::error::Error>>`
  * `fn get_min_deposit(&self) -> Result<Balance, Box<dyn Error>>`
  * `fn register_submitter(&self) -> Result<FinalExecutionOutcomeView, Box<dyn Error>>`
  * `fn is_submitter_registered(&self,account_id: Option<AccountId>,) -> Result<bool, Box<dyn Error>>`
  * `fn get_light_client_state(&self) -> Result<LightClientState, Box<dyn Error>>`
  * `fn get_num_of_submitted_blocks_by_account(&self) -> Result<u32, Box<dyn Error>>`
  * `fn get_max_submitted_blocks_by_account(&self) -> Result<u32, Box<dyn Error>>`

* [eth2-client contract storage](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs):
  * High level storage overview
  * provides the `Eth2Client` public data stucture

    ```
    pub struct Eth2Client {
        /// If set, only light client updates by the trusted signer will be accepted
        trusted_signer: Option<AccountId>,
        /// Mask determining all paused functions
        paused: Mask,
        /// Whether the client validates the updates.
        /// Should only be set to `false` for debugging, testing, and diagnostic purposes
        validate_updates: bool,
        /// Whether the client verifies BLS signatures.
        verify_bls_signatures: bool,
        /// We store the hashes of the blocks for the past `hashes_gc_threshold` headers.
        /// Events that happen past this threshold cannot be verified by the client.
        /// It is desirable that this number is larger than 7 days' worth of headers, which is roughly
        /// 51k Ethereum blocks. So this number should be 51k in production.
        hashes_gc_threshold: u64,
        /// Network. e.g. mainnet, kiln
        network: Network,
        /// Hashes of the finalized execution blocks mapped to their numbers. Stores up to `hashes_gc_threshold` entries.
        /// Execution block number -> execution block hash
        finalized_execution_blocks: LookupMap<u64, H256>,
        /// All unfinalized execution blocks' headers hashes mapped to their `HeaderInfo`.
        /// Execution block hash -> ExecutionHeaderInfo object
        unfinalized_headers: UnorderedMap<H256, ExecutionHeaderInfo>,
        /// `AccountId`s mapped to their number of submitted headers.
        /// Submitter account -> Num of submitted headers
        submitters: LookupMap<AccountId, u32>,
        /// Max number of unfinalized blocks allowed to be stored by one submitter account
        /// This value should be at least 32 blocks (1 epoch), but the recommended value is 1024 (32 epochs)
        max_submitted_blocks_by_account: u32,
        // The minimum balance that should be attached to register a new submitter account
        min_storage_balance_for_submitter: Balance,
        /// Light client state
        finalized_beacon_header: ExtendedBeaconBlockHeader,
        finalized_execution_header: LazyOption<ExecutionHeaderInfo>,
        current_sync_committee: LazyOption<SyncCommittee>,
        next_sync_committee: LazyOption<SyncCommittee>,
    }
    ```

* [eth2-client dependencies](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/Cargo.toml) relys heavily on the [lighthouse](https://github.com/aurora-is-near/lighthouse) codebase for it's consensus and cryptogrphic primitives. See [Cryptographic Primitives](#cryptographic-primitives) for more information.
  * `ethereum-types = "0.9.2"`
  * `eth-types =  { path = "../eth-types" }`
  * `eth2-utility =  { path = "../eth2-utility" }`
  * `tree_hash = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }`
  * `merkle_proof = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }`
  * `bls = { git = "https://github.com/aurora-is-near/lighthouse.git", optional = true, rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec", default-features = false, features = ["milagro"]}`
  * `admin-controlled =  { path = "../admin-controlled" }`
  * `near-sdk = "4.0.0"`
  * `borsh = "0.9.3"`
  * `bitvec = "1.0.0"`

* [eth2-client contract functions](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/src/lib.rs): provides the following functions in `impl Eth2Client`
  * `fn validate_light_client_update(&self, update: &LightClientUpdate)`
  * `fn verify_finality_branch(&self, update: &LightClientUpdate, finalized_period: u64)`
  * `fn verify_bls_signatures(&self, update: &LightClientUpdate, sync_committee_bits: BitVec<u8>, finalized_period: u64,)`
  * `fn update_finalized_header(&mut self, finalized_header: ExtendedBeaconBlockHeader)`
  * `fn commit_light_client_update(&mut self, update: LightClientUpdate)`
  * `fn gc_finalized_execution_blocks(&mut self, mut header_number: u64)`
  * `fn update_submitter(&mut self, submitter: &AccountId, value: i64)`
  * `fn is_light_client_update_allowed(&self)`

* [Eth2NearRelay](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L84): has the following public structure

  ```
  pub struct Eth2NearRelay {
      beacon_rpc_client: BeaconRPCClient,
      eth1_rpc_client: Eth1RPCClient,
      near_rpc_client: NearRPCClient,
      eth_client_contract: Box<dyn EthClientContractTrait>,
      headers_batch_size: u64,
      ethereum_network: String,
      interval_between_light_client_updates_submission_in_epochs: u64,
      max_blocks_for_finalization: u64,
      near_network_name: String,
      last_slot_searcher: LastSlotSearcher,
      terminate: bool,
      submit_only_finalized_blocks: bool,
      next_light_client_update: Option<LightClientUpdate>,
      sleep_time_on_sync_secs: u64,
      sleep_time_after_submission_secs: u64,
      max_submitted_blocks_by_account: u32,
  }
  ```

* [Eth2NearRelay](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L103): Implements the following functions
  * `fn get_max_slot_for_submission(&self) -> Result<u64, Box<dyn Error>>`
  * `fn get_last_eth2_slot_on_near(&mut self, max_slot: u64) -> Result<u64, Box<dyn Error>>`
  * `fn get_last_finalized_slot_on_near(&self) -> Result<u64, Box<dyn Error>>`
  * `fn get_last_finalized_slot_on_eth(&self) -> Result<u64, Box<dyn Error>>`
  * **`pub fn run(&mut self, max_iterations: Option<u64>)`**
  * `fn wait_for_synchronization(&self) -> Result<(), Box<dyn Error>>`
  * `fn get_light_client_update_from_file(config: &Config, beacon_rpc_client: &BeaconRPCClient,) -> Result<Option<LightClientUpdate>, Box<dyn Error>>`
  * `fn set_terminate(&mut self, iter_id: u64, max_iterations: Option<u64>)`
  * `fn get_execution_blocks_between(&self, start_slot: u64, last_eth2_slot_on_eth_chain: u64,) -> Result<(Vec<BlockHeader>, u64), Box<dyn Error>>`
  * `fn submit_execution_blocks(&mut self, headers: Vec<BlockHeader>, current_slot: u64,last_eth2_slot_on_near: &mut u64,)`
  * `fn verify_bls_signature_for_finality_update(&mut self, light_client_update: &LightClientUpdate,) -> Result<bool, Box<dyn Error>>`
  * `fn get_execution_block_by_slot(&self, slot: u64) -> Result<BlockHeader, Box<dyn Error>>`

* [Eth2NearRelay](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L461): has a second implementation of functions for submitting light client updates
  * `fn is_enough_blocks_for_light_client_update(&self, last_submitted_slot: u64,last_finalized_slot_on_near: u64, last_finalized_slot_on_eth: u64,) -> bool`
  * `fn is_shot_run_mode(&self) -> bool`
  * `fn send_light_client_updates_with_checks(&mut self, last_submitted_slot: u64) -> bool`
  * `fn send_light_client_updates(&mut self, last_submitted_slot: u64, last_finalized_slot_on_near: u64, last_finalized_slot_on_eth: u64,)`
  * `fn send_light_client_update_from_file(&mut self, last_submitted_slot: u64)`
  * `fn send_regular_light_client_update(&mut self, last_finalized_slot_on_eth: u64,last_finalized_slot_on_near: u64,)`
  * `fn get_attested_slot(&mut self, last_finalized_slot_on_near: u64,) -> Result<u64, Box<dyn Error>>`
  * `fn send_hand_made_light_client_update(&mut self, last_finalized_slot_on_near: u64)`
  * `fn send_specific_light_client_update(&mut self, light_client_update: LightClientUpdate)`

* [eth2-contract-init](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/eth2-contract-init) includes (but not limited to) the following additional components
  * [init\_contract.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2-contract-init/src/init_contract.rs): Verifies light client snapshot and initializes the Ethereum Light Contract on Near.
    * `pub fn verify_light_client_snapshot(block_root: String, light_client_snapshot: &LightClientSnapshotWithProof,) -> bool`: Verifies the light client by checking the snapshot format getting the current consensus branch and verifying it via a merkle proof.
    * `pub fn init_contract(config: &Config, eth_client_contract: &mut EthClientContract, mut init_block_root: String,) -> Result<(), Box<dyn std::error::Error>>`: Initializes the Ethereum Light Client Contract on Near.

* [eth\_rpc\_client](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/eth_rpc_client) includes (but not limited to) the following additional components
  * [eth1\_rpc\_client.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth1_rpc_client.rs): Is used to get block headers and check sync status. It has the following functions
    * `pub fn new(endpoint_url: &str) -> Self`
    * `pub fn get_block_header_by_number(&self, number: u64) -> Result<BlockHeader, Box<dyn Error>>`
    * `pub fn is_syncing(&self) -> Result<bool, Box<dyn Error>>`
  * [execution\_block\_proof.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/execution_block_proof.rs): `ExecutionBlockProof` contains a `block_hash` (execution block) and a proof of its inclusion in the `BeaconBlockBody` tree hash. The `block_hash` is the 12th field in execution\_payload, which is the 9th field in `BeaconBlockBody`. The first 4 elements in proof correspondent to the proof of inclusion of `block_hash` in Merkle tree built for `ExecutionPayload`. The last 4 elements of the proof of `ExecutionPayload` in the Merkle tree are built on high-level `BeaconBlockBody` fields. The proof starts from the leaf. It has the following structure and functions
    * `pub struct ExecutionBlockProof {block_hash: H256, proof: [H256; Self::PROOF_SIZE],}`
    * `pub fn construct_from_raw_data(block_hash: &H256, proof: &[H256; Self::PROOF_SIZE]) -> Self`
    * `pub fn construct_from_beacon_block_body(beacon_block_body: &BeaconBlockBody<MainnetEthSpec>,) -> Result<Self, Box<dyn Error>>`
    * `pub fn get_proof(&self) -> [H256; Self::PROOF_SIZE]`
    * `pub fn get_execution_block_hash(&self) -> H256`
    * `pub fn verify_proof_for_hash(&self, beacon_block_body_hash: &H256,) -> Result<bool, IncorrectBranchLength>`
    * `fn merkle_root_from_branch(leaf: H256, branch: &[H256], depth: usize, index: usize,) -> Result<H256, IncorrectBranchLength>`
  * [beacon\_block\_body\_merkle\_tree.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth_rpc_client/src/beacon_block_body_merkle_tree.rs): implements merkle trees for the Beacon and the ExecutionPayload
    * `BeaconBlockBodyMerkleTree` is built on the `BeaconBlockBody` data structure, where the leaves of the Merkle Tree are the hashes of the high-level fields of the `BeaconBlockBody`. The hashes of each element are produced by using `ssz` serialization.
    * `ExecutionPayloadMerkleTree` is a built on the `ExecutionPayload` data structure, where the leaves of the Merkle Tree are the hashes of the high-level fields of the `ExecutionPayload`. The hashes of each element are produced by using `ssz` serialization. `ExecutionPayload` is one of the field in BeaconBlockBody. The hash of the root of `ExecutionPlayloadMerkleTree` is the 9th leaf in BeaconBlockBody Merkle Tree.
  * [beacon\_rpc\_client.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth_rpc_client/src/beacon_rpc_client.rs): allows getting beacon block body, beacon block header and light client updates using [Beacon RPC API](https://ethereum.github.io/beacon-APIs/). It has the following functions
    * `pub fn new(endpoint_url: &str, timeout_seconds: u64, timeout_state_seconds: u64) -> Self`: Creates `BeaconRPCClient` for the given BeaconAPI `endpoint_url`
    * `pub fn get_beacon_block_body_for_block_id(&self, block_id: &str,) -> Result<BeaconBlockBody<MainnetEthSpec>, Box<dyn Error>>`: Returns `BeaconBlockBody` struct for the given `block_id`. It uses the following arguments
      * `block_id` - Block identifier. Can be one of: `"head" (canonical head in node's view),"genesis", "finalized", <slot>, <hex encoded blockRoot with 0x prefix>`(see [beacon-APIs/#/Beacon/getBlockV2](https://ethereum.github.io/beacon-APIs/#/Beacon/getBlockV2)).
    * `pub fn get_beacon_block_header_for_block_id(&self, block_id: &str,) -> Result<types::BeaconBlockHeader, Box<dyn Error>>`: Returns `BeaconBlockHeader` struct for the given `block_id`. It uses the following arguments
      * `block_id` - Block identifier. Can be one of: `"head" (canonical head in node's view),"genesis", "finalized", <slot>, <hex encoded blockRoot with 0x prefix>`(see [beacon-APIs/#/Beacon/getBlockV2](https://ethereum.github.io/beacon-APIs/#/Beacon/getBlockV2)).
    * `pub fn get_light_client_update(&self, period: u64,) -> Result<LightClientUpdate, Box<dyn Error>>`: Returns `LightClientUpdate` struct for the given `period`. It uses the following arguments
      * `period` - period id for which `LightClientUpdate` is fetched. On Mainnet, one period consists of 256 epochs, and one epoch consists of 32 slots
    * `pub fn get_bootstrap(&self, block_root: String,) -> Result<LightClientSnapshotWithProof, Box<dyn Error>>`: Fetch a bootstrapping state with a proof to a trusted block root. The trusted block root should be fetched with similar means to a weak subjectivity checkpoint. Only block roots for checkpoints are guaranteed to be available.
    * `pub fn get_checkpoint_root(&self) -> Result<String, Box<dyn Error>>`
    * `pub fn get_last_finalized_slot_number(&self) -> Result<types::Slot, Box<dyn Error>>`: Return the last finalized slot in the Beacon chain
    * `pub fn get_last_slot_number(&self) -> Result<types::Slot, Box<dyn Error>>`: Return the last slot in the Beacon chain
    * `pub fn get_slot_by_beacon_block_root(&self, beacon_block_hash: H256,) -> Result<u64, Box<dyn Error>>`
    * `pub fn get_block_number_for_slot(&self, slot: types::Slot) -> Result<u64, Box<dyn Error>>`
    * `pub fn get_finality_light_client_update(&self) -> Result<LightClientUpdate, Box<dyn Error>>`
    * `pub fn get_finality_light_client_update_with_sync_commity_update(&self,) -> Result<LightClientUpdate, Box<dyn Error>>`
    * `pub fn get_beacon_state(&self, state_id: &str,) -> Result<BeaconState<MainnetEthSpec>, Box<dyn Error>>`
    * `pub fn is_syncing(&self) -> Result<bool, Box<dyn Error>>`
    * `fn get_json_from_client(client: &Client, url: &str) -> Result<String, Box<dyn Error>>`
    * `fn get_json_from_raw_request(&self, url: &str) -> Result<String, Box<dyn Error>>`
    * `fn get_body_json_from_rpc_result(block_json_str: &str,) -> Result<std::string::String, Box<dyn Error>>`
    * `fn get_header_json_from_rpc_result(json_str: &str,) -> Result<std::string::String, Box<dyn Error>>`
    * `fn get_attested_header_from_light_client_update_json_str(light_client_update_json_str: &str,) -> Result<BeaconBlockHeader, Box<dyn Error>>`
    * `fn get_sync_aggregate_from_light_client_update_json_str(light_client_update_json_str: &str,) -> Result<SyncAggregate, Box<dyn Error>>`
    * `fn get_signature_slot(&self, light_client_update_json_str: &str,) -> Result<Slot, Box<dyn Error>>`: `signature_slot` is not provided in the current API. The slot is brute-forced until `SyncAggregate` in `BeconBlockBody` in the current slot is equal to `SyncAggregate` in `LightClientUpdate`
    * `fn get_finality_update_from_light_client_update_json_str(&self, light_client_update_json_str: &str,) -> Result<FinalizedHeaderUpdate, Box<dyn Error>>`
    * `fn get_sync_committee_update_from_light_client_update_json_str(light_client_update_json_str: &str,) -> Result<SyncCommitteeUpdate, Box<dyn Error>>`
    * `pub fn get_period_for_slot(slot: u64) -> u64`
    * `pub fn get_non_empty_beacon_block_header(&self, start_slot: u64,) -> Result<types::BeaconBlockHeader, Box<dyn Error>>`
    * `fn check_block_found_for_slot(&self, json_str: &str) -> Result<(), Box<dyn Error>>`
  * [hand\_made\_finality\_light\_client\_update.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth_rpc_client/src/hand_made_finality_light_client_update.rs): Has two implementations
    * The first implementation which calls functions in the second
      * `pub fn get_finality_light_client_update(beacon_rpc_client: &BeaconRPCClient, attested_slot: u64, include_next_sync_committee: bool,) -> Result<LightClientUpdate, Box<dyn Error>>`
      * `pub fn get_finality_light_client_update_from_file(beacon_rpc_client: &BeaconRPCClient, file_name: &str,) -> Result<LightClientUpdate, Box<dyn Error>>`
      * `pub fn get_light_client_update_from_file_with_next_sync_committee(beacon_rpc_client: &BeaconRPCClient, attested_state_file_name: &str, finality_state_file_name: &str,) -> Result<LightClientUpdate, Box<dyn Error>>`
    * The second implementation
      * `fn get_attested_slot_with_enough_sync_committee_bits_sum(beacon_rpc_client: &BeaconRPCClient,attested_slot: u64,) -> Result<(u64, u64), Box<dyn Error>>`
      * `fn get_state_from_file(file_name: &str) -> Result<BeaconState<MainnetEthSpec>, Box<dyn Error>>`
      * `fn get_finality_light_client_update_for_state(beacon_rpc_client: &BeaconRPCClient,attested_slot: u64, signature_slot: u64, beacon_state: BeaconState<MainnetEthSpec>, finality_beacon_state: Option<BeaconState<MainnetEthSpec>>,) -> Result<LightClientUpdate, Box<dyn Error>>`
      * `fn get_next_sync_committee(beacon_state: &BeaconState<MainnetEthSpec>,) -> Result<SyncCommitteeUpdate, Box<dyn Error>>`
      * `fn from_lighthouse_beacon_header(beacon_header: &BeaconBlockHeader,) -> eth_types::eth2::BeaconBlockHeader`
      * `fn get_sync_committee_bits(sync_committee_signature: &types::SyncAggregate<MainnetEthSpec>,) -> Result<[u8; 64], Box<dyn Error>>`
      * `fn get_finality_branch(beacon_state: &BeaconState<MainnetEthSpec>,) -> Result<Vec<H256>, Box<dyn Error>>`
      * `fn get_finality_update(finality_header: &BeaconBlockHeader, beacon_state: &BeaconState<MainnetEthSpec>, finalized_block_body: &BeaconBlockBody<MainnetEthSpec>,) -> Result<FinalizedHeaderUpdate, Box<dyn Error>>`
  * [light\_client\_snapshot\_with\_proof.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth_rpc_client/src/light_client_snapshot_with_proof.rs): contains the structure for `LightClientSnapshotWithProof`

    ```
    pub struct LightClientSnapshotWithProof {
        pub beacon_header: BeaconBlockHeader,
        pub current_sync_committee: SyncCommittee,
        pub current_sync_committee_branch: Vec<H256>,
    }
    ```

* [eth2near-block-relay-rs](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/eth2near-block-relay-rs) includes (but not limited to) the following additional components
  * [config.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/config.rs):
  * [last\_slot\_searcher.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/last_slot_searcher.rs): Implementation of functions for searching last slot on NEAR contract. Supports both binary and linear searches.
    * `pub fn get_last_slot(&mut self, last_eth_slot: u64, beacon_rpc_client: &BeaconRPCClient, eth_client_contract: &Box<dyn EthClientContractTrait>,) -> Result<u64, Box<dyn Error>>`
    * `n binary_slot_search(&self, slot: u64, finalized_slot: u64, last_eth_slot: u64, beacon_rpc_client: &BeaconRPCClient, eth_client_contract: &Box<dyn EthClientContractTrait>,) -> Result<u64, Box<dyn Error>>` : Search for the slot before the first unknown slot on NEAR. Assumptions: (1) start\_slot is known on NEAR (2) last\_slot is unknown on NEAR. Return error in case of problem with network connection.
    * `fn binsearch_slot_forward(&self, slot: u64, max_slot: u64, beacon_rpc_client: &BeaconRPCClient,eth_client_contract: &Box<dyn EthClientContractTrait>,) -> Result<u64, Box<dyn Error>> {`: Search for the slot before the first unknown slot on NEAR. Assumptions: (1) start\_slot is known on NEAR (2) last\_slot is unknown on NEAR. Return error in case of problem with network connection.
    * `fn binsearch_slot_range(&self, start_slot: u64, last_slot: u64, beacon_rpc_client: &BeaconRPCClient, eth_client_contract: &Box<dyn EthClientContractTrait>,) -> Result<u64, Box<dyn Error>>`: Search for the slot before the first unknown slot on NEAR. Assumptions: (1) start\_slot is known on NEAR (2) last\_slot is unknown on NEAR. Return error in case of problem with network connection.
    * `fn linear_slot_search(&self, slot: u64, finalized_slot: u64, last_eth_slot: u64, beacon_rpc_client: &BeaconRPCClient, eth_client_contract: &Box<dyn EthClientContractTrait>,) -> Result<u64, Box<dyn Error>>`: Returns the last slot known with block known on NEAR. `Slot` -- expected last known slot. `finalized_slot` -- last finalized slot on NEAR, assume as known slot. `last_eth_slot` -- head slot on Eth.
    * `fn linear_search_forward(&self, slot: u64, max_slot: u64, beacon_rpc_client: &BeaconRPCClient,eth_client_contract: &Box<dyn EthClientContractTrait>,) -> Result<u64, Box<dyn Error>>`: Returns the slot before the first unknown block on NEAR. The search range is \[slot .. max\_slot). If there is no unknown block in this range max\_slot - 1 will be returned. Assumptions: (1) block for slot is submitted to NEAR. (2) block for max\_slot is not submitted to NEAR.
    * `fn linear_search_backward(&self, start_slot: u64, last_slot: u64, beacon_rpc_client: &BeaconRPCClient, eth_client_contract: &Box<dyn EthClientContractTrait>,) -> Result<u64, Box<dyn Error>>`: Returns the slot before the first unknown block on NEAR. The search range is \[last\_slot .. start\_slot). If no such block are found the start\_slot will be returned. Assumptions: (1) block for start\_slot is submitted to NEAR (2) block for last\_slot + 1 is not submitted to NEAR.
    * `fn find_left_non_error_slot(&self, left_slot: u64, right_slot: u64, step: i8, beacon_rpc_client: &BeaconRPCClient, eth_client_contract: &Box<dyn EthClientContractTrait>,) -> (u64, bool)`: Find the leftmost non-empty slot. Search range: \[left\_slot, right\_slot). Returns pair: (1) slot\_id and (2) is this block already known on Eth client on NEAR. Assume that right\_slot is non-empty and it's block were submitted to NEAR, so if non correspondent block is found we return (right\_slot, false).
    * `fn block_known_on_near( &self, slot: u64, beacon_rpc_client: &BeaconRPCClient,eth_client_contract: &Box<dyn EthClientContractTrait>,) -> Result<bool, Box<dyn Error>>`: Check if the block for current slot in Eth2 already were submitted to NEAR. Returns Error if slot doesn't contain any block.
  * [main.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/main.rs): [Command Line Argument Parser](https://docs.rs/clap/latest/clap/) used to run the Ethereum to Near Block Relay. It contains the following functions
    * `fn get_eth_contract_wrapper(config: &Config) -> Box<dyn ContractWrapper>`
    * `fn get_dao_contract_wrapper(config: &Config) -> Box<dyn ContractWrapper>`
    * `fn get_eth_client_contract(config: &Config) -> Box<dyn EthClientContractTrait>`
    * `fn init_log(args: &Arguments, config: &Config)`
    * `fn main() -> Result<(), Box<dyn std::error::Error>>`
  * [near\_rpc\_client.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/near_rpc_client.rs)
    * `pub fn new(endpoint_url: &str) -> Self`
    * `pub fn check_account_exists(&self, account_id: &str) -> Result<bool, Box<dyn Error>>`
    * `pub fn is_syncing(&self) -> Result<bool, Box<dyn Error>>`

##### Ethereum Light Client Finality Update Verify Components

[finality-update-verify](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/finality-update-verify) is called from [fn verify\_bls\_signature\_for\_finality\_update](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/eth2near_relay.rs#L422) to verify signatures as part of light\_client updates. It relies heavily on the [lighthouse](https://github.com/aurora-is-near/lighthouse) codebase for it's consensus and cryptogrphic primitives. See [Cryptographic Primitives](#cryptographic-primitives) for more information.

* Dependencies in [Cargo.toml](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/finality-update-verify/Cargo.toml)
  * `eth-types = { path ="../../contracts/near/eth-types/", features = ["eip1559"]}`
  * `bls = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }`
  * `eth2-utility  = { path ="../../contracts/near/eth2-utility"}`
  * `tree_hash = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }`
  * `types =  { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }`
  * `bitvec = "1.0.0"`

* Functions in [lib.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/finality-update-verify/src/lib.rs)
  * `fn h256_to_hash256(hash: H256) -> Hash256`
  * `fn tree_hash_h256_to_eth_type_h256(hash: tree_hash::Hash256) -> eth_types::H256`
  * `fn to_lighthouse_beacon_block_header(bridge_beacon_block_header: &BeaconBlockHeader,) -> types::BeaconBlockHeader`
  * `pub fn is_correct_finality_update(ethereum_network: &str, light_client_update: &LightClientUpdate,   sync_committee: SyncCommittee,) -> Result<bool, Box<dyn Error>>`

##### Cryptographic Primitives

Following are cryptographic primitives used in the [eth2-client contract](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/near/eth2-client) and [finality-update-verify](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/finality-update-verify). Many are from the [lighthouse](https://github.com/aurora-is-near/lighthouse) codebase. Specifically [consensus](https://github.com/aurora-is-near/lighthouse/tree/stable/consensus) and [crypto](https://github.com/aurora-is-near/lighthouse/tree/stable/crypto) functions.

Some common primitives

* [bitvec](https://docs.rs/bitvec/1.0.1/bitvec/): Addresses memory by bits, for packed collections and bitfields
* [eth2\_serde\_utils](https://docs.rs/eth2_serde_utils/0.1.0/eth2_serde_utils/): Serialization and deserialization utilities useful for JSON representations of Ethereum 2.0 types.
* [eth2\_hashing](https://docs.rs/eth2_hashing/0.2.0/eth2_hashing/): Hashing primitives used in Ethereum 2.0
* [blst](https://docs.rs/blst/0.3.10/blst/): The blst crate provides a rust interface to the blst BLS12-381 signature library.
* [tree\_hash](https://docs.rs/tree_hash/0.4.0/tree_hash/): Efficient Merkle-hashing as used in Ethereum 2.0
* [eth2\_ssz\_types](https://docs.rs/eth2_ssz_types/0.2.1/ssz_types/): Provides types with unique properties required for SSZ serialization and Merklization.

Some Primitives from Lighthouse

* [bls](https://github.com/aurora-is-near/lighthouse/tree/stable/crypto/bls): [Boneh–Lynn–Shacham](https://en.wikipedia.org/wiki/BLS_digital_signature) digital signature support
  * [impls](https://github.com/aurora-is-near/lighthouse/tree/stable/crypto/bls/src/impls): Implementations
    * [blst](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/impls/blst.rs)
    * [fake\_crypto](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/impls/fake_crypto.rs)
    * [milagro](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/impls/milagro.rs): support for [Apache Milagro](https://milagro.apache.org/docs/milagro-intro/)
    * [functionality](https://github.com/aurora-is-near/lighthouse/tree/stable/crypto/bls/src)
      * [generic\_aggregate\_public\_key](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_aggregate_public_key.rs)
      * [generic\_aggregate\_signature](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_aggregate_signature.rs)
      * [generic\_keypair](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_keypair.rs)
      * [generic\_public\_key](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_public_key.rs)
      * [generic\_public\_key\_bytes](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_public_key_bytes.rs)
      * [generic\_secret\_key](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_secret_key.rs)
      * [generic\_signature](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_signature.rs)
      * [generic\_signature\_bytes](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_signature_bytes.rs)
      * [generic\_signature\_set](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/generic_signature_set.rs)
      * [get\_withdrawal\_credentials](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/get_withdrawal_credentials.rs)
      * [zeroize\_hash](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/zeroize_hash.rs)
* [merkle\_proof](https://github.com/aurora-is-near/lighthouse/tree/stable/consensus/merkle_proof)
* [tree\_hash](https://github.com/aurora-is-near/lighthouse/tree/stable/consensus/tree_hash)
* [types](https://github.com/aurora-is-near/lighthouse/tree/stable/consensus/types/src): Implements Ethereum 2.0 types including but not limited to
  * [attestation](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/attestation.rs)
  * [beacon\_block](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/beacon_block.rs)
  * [beacon\_committee](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/beacon_committee.rs)
  * [beacon\_state](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/beacon_state.rs)
  * [builder\_bid](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/builder_bid.rs)
  * [chain\_spec](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/chain_spec.rs)
  * [checkpoint](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/checkpoint.rs)
  * [contribution\_and\_proof](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/contribution_and_proof.rs): A Validators aggregate sync committee contribution and selection proof.
  * [deposit](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/deposit.rs): A deposit to potentially become a beacon chain validator.
  * [enr\_fork\_id](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/enr_fork_id.rs): Specifies a fork which allows nodes to identify each other on the network. This fork is used in a nodes local ENR.
  * [eth\_spec](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/eth_spec.rs): Ethereum Foundation specifications.
  * [execution\_block\_hash](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/execution_block_hash.rs)
  * [execution\_payload](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/execution_payload.rs)
  * [fork](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/fork.rs): Specifies a fork of the `BeaconChain`, to prevent replay attacks.
  * [free\_attestation](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/free_attestation.rs): Note: this object does not actually exist in the spec. We use it for managing attestations that have not been aggregated.
  * [payload](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/payload.rs)
  * [signed\_aggregate\_and\_proof](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/signed_aggregate_and_proof.rs): A Validators signed aggregate proof to publish on the `beacon_aggregate_and_proof` gossipsub topic.
  * [signed\_beacon\_block](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/signed_beacon_block.rs): A `BeaconBlock` and a signature from its proposer.
  * [slot\_data](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/slot_data.rs): A trait providing a `Slot` getter for messages that are related to a single slot. Useful in making parts of attestation and sync committee processing generic.
  * [slot\_epoch](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/slot_epoch.rs): The `Slot` and `Epoch` types are defined as new types over u64 to enforce type-safety between the two types. Note: Time on Ethereum 2.0 Proof of Stake is divided into slots and epochs. One slot is 12 seconds. One epoch is 6.4 minutes, consisting of 32 slots. One block can be created for each slot.
  * [sync\_aggregate](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/sync_aggregate.rs): Create a `SyncAggregate` from a slice of `SyncCommitteeContribution`s. Equivalent to `process_sync_committee_contributions` from the spec.
  * [sync\_committee](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/sync_committee.rs)
  * [tree\_hash\_impls](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/tree_hash_impls.rs): contains custom implementations of `CachedTreeHash` for ETH2-specific types. It makes some assumptions about the layouts and update patterns of other structs in this crate, and should be updated carefully whenever those structs are changed.
  * [validator](https://github.com/aurora-is-near/lighthouse/blob/stable/consensus/types/src/validator.rs): Information about a `BeaconChain` validator.

Some Smart Contracts deployed on Ethereum

* [nearprover](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearprover)
  * [ProofDecoder.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearprover/contracts/ProofDecoder.sol)
  * [NearProver.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearprover/contracts/NearProver.sol)
* [nearbridge](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearbridge/contracts)
  * [NearDecoder.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/NearDecoder.sol): handles decoing of Public Keys, Signatures, BlockProducers and LightClientBlocks using `Borsh.sol`
  * [Utils.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Utils.sol): handles reading and writing to memory, memoryToBytes and has functions such as `keccak256Raw` and `sha256Raw`
  * [Borsh.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Borsh.sol): [Borsh](https://borsh.io/): Binary Object Representation Serializer for Hashing. It is meant to be used in security-critical projects as it prioritizes consistency, safety, speed; and comes with a strict specification.
  * [Ed25519.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Ed25519.sol): [Ed25519](https://ed25519.cr.yp.to/) high-speed high-security signatures

Some Primitives from NEAR Rainbow Bridge

* [eth-types](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/near/eth-types): utilities to serialize and encode eth2 types using [borsh](https://borsh.io/) and [rlp](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp).
* [eth2-utility](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/near/eth2-utility): Utility functions used for Ethereum 2.0 Consensus. Functions include
  * `fn from_str(input: &str) -> Result<Network, Self::Err>`
  * `pub fn new(network: &Network) -> Self`
  * `pub fn compute_fork_version(&self, epoch: Epoch) -> Option<ForkVersion>`
  * `pub fn compute_fork_version_by_slot(&self, slot: Slot) -> Option<ForkVersion>`
  * `pub const fn compute_epoch_at_slot(slot: Slot) -> u64`
  * `pub const fn compute_sync_committee_period(slot: Slot) -> u64`
  * `pub const fn floorlog2(x: u32) -> u32`: Compute floor of log2 of a u32.
  * `pub const fn get_subtree_index(generalized_index: u32) -> u32`
  * `pub fn compute_domain(domain_constant: DomainType, fork_version: ForkVersion, genesis_validators_root: H256,) -> H256`
  * `pub fn compute_signing_root(object_root: H256, domain: H256) -> H256`
  * `pub fn get_participant_pubkeys(public_keys: &[PublicKeyBytes], sync_committee_bits: &BitVec<u8, Lsb0>,) -> Vec<PublicKeyBytes>`
  * `pub fn convert_branch(branch: &[H256]) -> Vec<ethereum_types::H256>`
  * `pub fn validate_beacon_block_header_update(header_update: &HeaderUpdate) -> bool`
  * `pub fn calculate_min_storage_balance_for_submitter(max_submitted_blocks_by_account: u32,) -> Balance`

#### Near Rainbow Bridge Near Light Client Walkthrough

The following is a walkthrough of how a transaction executed on NEAR is propogated to Ethereum's [nearbridge](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearbridge). See [nearbridge Cryptographic Primitives](#nearbridge-cryptographic-primitives) for more information on the cryptography used.

**NearOnEthClient Overview**

*The following is an excerpt from a blog by near on [eth-near-rainbow-bridge](https://near.org/blog/eth-near-rainbow-bridge/)*

> NearOnEthClient is an implementation of the NEAR light client in Solidity as an Ethereum contract. Unlike EthOnNearClient it does not need to verify every single NEAR header and can skip most of them as long as it verifies at least one header per NEAR epoch, which is about 43k blocks and lasts about half a day. As a result, NearOnEthClient can memorize hashes of all submitted NEAR headers in history, so if you are making a transfer from NEAR to Ethereum and it gets interrupted you don’t need to worry and you can resume it any time, even months later. Another useful property of the NEAR light client is that every NEAR header contains a root of the merkle tree computed from all headers before it. As a result, if you have one NEAR header you can efficiently verify any event that happened in any header before it.
>
> Another useful property of the NEAR light client is that it only accepts final blocks, and final blocks cannot leave the canonical chain in NEAR. This means that NearOnEthClient does not need to worry about forks.
>
> However, unfortunately, NEAR uses [Ed25519](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-665.mdx) to sign messages of the validators who approve the blocks, and this signature is not available as an EVM precompile. It makes verification of all signatures of a single NEAR header prohibitively expensive. So technically, we cannot verify one NEAR header within one contract call to NearOnEthClient. Therefore we adopt the [optimistic approach](https://medium.com/@deaneigenmann/optimistic-contracts-fb75efa7ca84) where NearOnEthClient verifies everything in the NEAR header except the signatures. Then anyone can challenge a signature in a submitted header within a 4-hour challenge window. The challenge requires verification of a single Ed25519 signature which would cost about 500k Ethereum gas (expensive, but possible). The user submitting the NEAR header would have to post a bond in Ethereum tokens, and a successful challenge would burn half of the bond and return the other half to the challenger. The bond should be large enough to pay for the gas even if the gas price increases exponentially during the 4 hours. For instance, a 20 ETH bond would cover gas price hikes up to 20000 Gwei. This optimistic approach requires having a watchdog service that monitors submitted NEAR headers and challenges any headers with invalid signatures. For added security, independent users can run several watchdog services.
>
> Once EIP665 is accepted, Ethereum will have the Ed25519 signature available as an EVM precompile. This will make watchdog services and the 4-hour challenge window unnecessary.
>
> At its bare minimum, Rainbow Bridge consists of EthOnNearClient and NearOnEthClient contracts, and three services: Eth2NearRelay, Near2EthRelay, and the Watchdog. We might argue that this already constitutes a bridge since we have established a cryptographic link between two blockchains, but practically speaking it requires a large portion of additional code to make application developers even consider using the Rainbow Bridge for their applications.

*The following information on sending assets from NEAR back to Ethereum is an excerpt from [https://near.org/bridge/](https://near.org/bridge/).*

> Sending assets from NEAR back to Ethereum currently takes a maximum of sixteen hours (due to Ethereum finality times) and costs around $60 (due to ETH gas costs and at current ETH price). These costs and speeds will improve in the near future.

##### NEAR to Ethereum block propagation costing

The following links provide the production Ethereum addresses and blockexplorer views for NearBridge.sol and the ERC20 Locker

* [Ethereum Mainnet Bridge addresses and parameters](https://github.com/aurora-is-near/rainbow-bridge-client/tree/main/packages/client#ethereum-mainnet-bridge-addresses-and-parameters)
* [NearBridge.sol on Ethereum Block Explorer](https://etherscan.io/address/0x3fefc5a4b1c02f21cbc8d3613643ba0635b9a873)
  * [Sample `addLightClientBlock(bytes data)` function call](https://etherscan.io/tx/0xa0fbf1405747dbc1c1bda1227e46bc7c5feac36c0eeaab051022cfdb268e60cc/advanced)
* [NEAR ERC20Locker on Ethereum Block Explorer](https://etherscan.io/address/0x23ddd3e3692d1861ed57ede224608875809e127f#code)

At time of writing (Oct 26th, 2022).

* NEAR Light Client Blocks are propogated every `4 hours`
* Sample Transaction fee `0.061600109576901025 Ether ($96.56)`
* Daily Transaction fees cost approximately `$600`
* *Note: Infrastructure costs for running relayer, watchdog, etc are not included.*

##### NEAR to Ethereum block propagation flow

[NEAR Light Client Documentation](https://nomicon.io/ChainSpec/LightClient) gives an overview of how light clients work. At a high level the light client needs to fetch at least one block per [epoch](https://docs.near.org/concepts/basics/epoch) i.e. every 42,200 blocks or approxmiately 12 hours. Also Having the LightClientBlockView for block B is sufficient to be able to verify any statement about state or outcomes in any block in the ancestry of B (including B itself).

The current scripts and codebase indicates that a block would be fetched every 30 seconds with a max delay of 10 seconds. It feels that this would be expensive to update Ethereum so frequently. [NEAR's bridge documentation](https://near.org/bridge/) states *Sending assets from NEAR back to Ethereum currently takes a maximum of sixteen hours (due to Ethereum finality times)*. This seems to align with sending light client updates once per NEAR epoch. The block fetch period is configurable in the relayer.

> The RPC returns the LightClientBlock for the block as far into the future from the last known hash as possible for the light client to still accept it. Specifically, it either returns the last final block of the next epoch, or the last final known block. If there's no newer final block than the one the light client knows about, the RPC returns an empty result.
>
> A standalone light client would bootstrap by requesting next blocks until it receives an empty result, and then periodically request the next light client block.
>
> A smart contract-based light client that enables a bridge to NEAR on a different blockchain naturally cannot request blocks itself. Instead external oracles query the next light client block from one of the full nodes, and submit it to the light client smart contract. The smart contract-based light client performs the same checks described above, so the oracle doesn't need to be trusted.

Block Submitters stake ETH to be allowed to submit blocks which get's slashed if the watchdog identifies blocks with invalid signatures.

*Note: Have not identified how the block submitters are rewarded for submitting blocks. Currently have only identified them locking ETH to be able to submit blocks and being slashed if they submit blocks with invalid signatures.*

* [Light Clients are deployed on Ethereum](https://github.com/aurora-is-near/rainbow-bridge/blob/master/cli/index.js#L518) via the CLI using [eth-contracts.js](https://github.com/aurora-is-near/rainbow-bridge/blob/master/cli/init/eth-contracts.js)
  * [init-eth-ed25519](https://github.com/aurora-is-near/rainbow-bridge/blob/master/cli/index.js#L505): Deploys `Ed25519.sol` see more information under [nearbridge Cryptographic Primitives](#nearbridge-cryptographic-primitives)
  * [init-eth-client](https://github.com/aurora-is-near/rainbow-bridge/blob/master/cli/index.js#L520): Deploys `NearBridge.sol` see more information under [NEAR to Ethereum block propagation components](#near-to-ethereum-block-propagation-components). It takes the following arguments
    * `ethEd25519Address`: The address of the ECDSA signature checker using Ed25519 curve (see [here](https://nbeguier.medium.com/a-real-world-comparison-of-the-ssh-key-algorithms-b26b0b31bfd9))
    * `lockEthAmount`: The amount that `BLOCK_PRODUCERS` need to deposit (in wei)to be able to provide blocks. This amount will be slashed if the block is challenged and proven not to have a valid signature. Default value is 100000000000000000000 WEI = 100 ETH.
    * `lockDuration` : 30 seconds
    * `replaceDuration`: 60 seconds it is passed in nanoseconds, because it is a difference between NEAR timestamps.
    * `ethAdminAddress`: Bridge Administrator Address
    * `0` : Indicates nothing is paused `UNPAUSE_ALL`
  * [init-eth-prover](https://github.com/aurora-is-near/rainbow-bridge/blob/master/cli/index.js#L538): Deploys `NearProver.sol` see more information under [NEAR to Ethereum block propagation components](#near-to-ethereum-block-propagation-components). It takes the following arguments
    * `ethClientAddress`: Interface to `NearBridge.sol`
    * `ethAdminAddress`: Administrator address
    * `0`: paused indicator defaults to `UNPAUSE_ALL = 0`

* [Relayer is Started](https://github.com/aurora-is-near/rainbow-bridge/blob/master/cli/commands/start/near2eth-relay.js)
  * Relayer is started using the following command

    ```
    cli/index.js start near2eth-relay \
    --eth-node-url http://127.0.0.1:8545/ \
    --eth-master-sk 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 \
    --near-node-url https://rpc.testnet.near.org/ \
    --near-network-id testnet \
    --eth-client-address 0xe7f1725e7734ce288f8367e1bb143e90bb3f0512 \
    --eth-use-eip-1559 true \
    --near2eth-relay-max-delay 10 \
    --near2eth-relay-block-select-duration 30 \
    --near2eth-relay-after-submit-delay-ms 1000 \
    --log-verbose true \
    --daemon false
    ```

* [Relayer Logic](https://github.com/aurora-is-near/rainbow-bridge/blob/master/near2eth/near2eth-block-relay/index.js)
  * Loops `while (true)`
    * Get the bridge state (including `currentHeight`, `nextTimestamp`, `nextValidAt`, `numBlockProducers` )
    * Get the `currentBlockHash` the hash of the current untrursted block based on `lastValidAt`
    * Gets the `lastBlock` by calling the NEAR rpc `next_light_client_block` using the hash of last untrusted block `bs58.encode(currentBlockHash)`
    * Get's the `replaceDuration` by `clientContract.methods.replaceDuration().call()` this will be 60 seconds if we deployed `NearBridge.sol` with the default values above
    * Sets `nextValidAt` from the bridge state `web3.utils.toBN(bridgeState.nextValidAt)`
    * Sets `replaceDelay` to 0 then updates it to the `nextTimestamp` + `replaceDuration` - `lastBlock.inner_lite.timestamp` i.e. The new block has to be at least 60 seconds after the current block stored on the light client.
    * Checks the height of the `currentHeight` of the bridge is less than the `lastblock` from the near light client `(bridgeState.currentHeight < lastBlock.inner_lite.height)`
    * Serializes the `lastBlock` using Borsh and check that the block is suitable
    * Checks that the `replaceDelay` has been met, if not sleeps until it has
    * Checks that the Master Account (the one submitting the block) has enough locked ETH (if not tries to deposit more). So that it can be slashed if the block proposed is invalid.
    * Adds the light client block `await clientContract.methods.addLightClientBlock(nextBlockSelection.borshBlock).send`
      * Checks `NearBridge.sol` (the light client) has been initialized
      * Checks `balanceOf[msg.sender] >= lockEthAmount` that the sender has locked enough Eth to allow them to submit blocks
      * Decodes the nearBlock using `Borsh.from(data)` and `borsh.decodeLightClientBlock()`
      * Commis the previous block, or make sure that it is OK to replace it using
        * `lastValidAt = 0;`
        * `blockHashes_[curHeight] = untrustedHash;`
        * `blockMerkleRoots_[curHeight] = untrustedMerkleRoot;`
      * Check that the new block's height is greater than the current one's. `nearBlock.inner_lite.height > curHeight`
      * Check that the new block is from the same epoch as the current one, or from the next one.
      * Check that the new block is signed by more than 2/3 of the validators.
      * If the block is from the next epoch, make sure that the Block producers `next_bps` are supplied and have a correct hash.
      * Add the Block to the Light client
        * Updates untrusted information to this block including `untrustedHeight`, `untrustedTimestamp`, `untrustedHash`, `untrustedMerkleRoot`, `untrustedNextHash`, `untrustedSignatureSet`, `untrustedNextEpoch`
        * If `fromNextEpoch` also update the Block Producers
        * Updates the `lastSubmitter` and `lastValidAt`
    * Cleans up the selected block to prevent submitting the same block again `await sleep(afterSubmitDelayMs)`
    * Sets the HeightGauuges to the correct block height
      * `clientHeightGauge.set(Number(BigInt(bridgeState.currentHeight))`
      * `chainHeightGauge.set(Number(BigInt(lastBlock.inner_lite.height)))`
    * Sleeps for delay calculated from the maximum of the relayer days (10 seconds) and differnce between the current and next block time stamps and `await sleep(1000 * delay)`

##### NEAR to Ethereum watchdog

The [watchdog](https://github.com/aurora-is-near/rainbow-bridge/blob/master/near2eth/watchdog/index.js) runs every 10 seconds and validates blocks on `NearBridge.sol` challenging blocks with incorrect signatures. *Note: It uses [heep-prometheus](https://github.com/aurora-is-near/rainbow-bridge/blob/master/utils/http-prometheus.js) for monitoring and storing block and producer information using `gauges` and `counters`.*

* [watchdog is started](https://github.com/aurora-is-near/rainbow-bridge/blob/master/cli/commands/start/watchdog.js) from the CLI
* [watchdog logic](https://github.com/aurora-is-near/rainbow-bridge/blob/master/near2eth/watchdog/index.js)
  * Initializes monitoring information on `Prometheus`
    * `const httpPrometheus = new HttpPrometheus(this.metricsPort, 'near_bridge_watchdog_')`
    * `const lastBlockVerified = httpPrometheus.gauge('last_block_verified', 'last block that was already verified')`
    * `const totBlockProducers = httpPrometheus.gauge('block_producers', 'number of block producers for current block')`
    * `const incorrectBlocks = httpPrometheus.counter('incorrect_blocks', 'number of incorrect blocks found')`
    * `const challengesSubmitted = httpPrometheus.counter('challenges_submitted', 'number of blocks challenged')`
  * Loops `while (true)`
    * Gets the `bridgeState`
    * Loops through all blockProducers checking their signatures
    * `for (let i = 0; i < numBlockProducers; i++)`
      * Check each signature `this.clientContract.methods.checkBlockProducerSignatureInHead(i).call()`
      * If invalid challenge the signature: `this.clientContract.methods.challenge(this.ethMasterAccount, i).encodeABI()` calls [challenge function](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/NearBridge.sol#L93)
        * `function challenge(address payable receiver, uint signatureIndex) external override pausable(PAUSED_CHALLENGE)`
          * checks block.timestamp is less than lastValidAt `block.timestamp < lastValidAt,`
          * Check if the signature is valid `!checkBlockProducerSignatureInHead(signatureIndex)`
          * slashes the last submitter `balanceOf[lastSubmitter] = balanceOf[lastSubmitter] - lockEthAmount;`
          * resets lastValidAt `lastValidAt = 0;`
          * Refunds half of the funds to the watchdog account `receiver.call{value: lockEthAmount / 2}("");`
      * Sleeps for watchdog Delay seconds `await sleep(watchdogDelay * 1000)`

##### NEAR to Ethereum block propagation components

* [eth2near-relay](https://github.com/aurora-is-near/rainbow-bridge/blob/master/cli/commands/start/eth2near-relay.js): Command to start the NEAR to Ethereum relay. See sample invocation [here](https://github.com/aurora-is-near/rainbow-bridge/blob/master/docs/development.md#near2eth-relay)
* [near2eth-block-relay](https://github.com/aurora-is-near/rainbow-bridge/tree/master/near2eth/near2eth-block-relay) is written in javascript
  * Has [dependencies](https://github.com/aurora-is-near/rainbow-bridge/blob/master/near2eth/near2eth-block-relay/package.json) including [rainbow-bridge-utils](https://github.com/aurora-is-near/rainbow-bridge/tree/master/utils) see [here](near-rainbow-bridge-utils) for more information. It's other dependencies are also included in `rainbow-bridge-utils`.
    * [ethereumjs-util](https://www.npmjs.com/package/ethereumjs-util): A collection of utility functions for Ethereum.
  * Has the following functions and classes
    * `class Near2EthRelay`
      * `async initialize ({nearNodeUrl, nearNetworkId, ethNodeUrl, ethMasterSk, ethClientArtifactPath, ethClientAddress, ethGasMultiplier, metricsPort })`
      * `async withdraw ({ethGasMultiplier})`
      * `async runInternal ({submitInvalidBlock, near2ethRelayMinDelay, near2ethRelayMaxDelay, near2ethRelayErrorDelay, near2ethRelayBlockSelectDuration, near2ethRelayNextBlockSelectDelayMs, near2ethRelayAfterSubmitDelayMs, ethGasMultiplier, ethUseEip1559, logVerbose})`
      * `run (options) {return this.runInternal({...options, submitInvalidBlock: false}) }`
* [NearBridge.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/NearBridge.sol): Is the NEAR light client deployed on ethereum.
  * It imports the following contracts (see [nearbridge cryptographic primitives](#nearbridge-cryptographic-primitives))
    * `import "./AdminControlled.sol";`
    * `import "./INearBridge.sol";`
    * `import "./NearDecoder.sol";`
    * `import "./Ed25519.sol";`
  * It provides the following structure for Bridge State. If there is currently no unconfirmed block, the last three fields are zero.
    * `uint currentHeight;`: Height of the current confirmed block
    * `uint nextTimestamp;`: Timestamp of the current unconfirmed block
    * `uint nextValidAt;`: Timestamp when the current unconfirmed block will be confirmed
    * `uint numBlockProducers;`: Number of block producers for the current unconfirmed block
  * It provides the following storage
    * `uint constant MAX_BLOCK_PRODUCERS = 100;`: Assumed to be even and to not exceed 256.
    * `struct Epoch {bytes32 epochId; uint numBPs; bytes [MAX_BLOCK_PRODUCERS] keys; bytes32[MAX_BLOCK_PRODUCERS / 2] packedStakes; uint256 stakeThreshold;}`
    * `uint256 public lockEthAmount;`
    * `uint256 public lockDuration;`: lockDuration and replaceDuration shouldn't be extremely big, so adding them to an uint64 timestamp should not overflow uint256.
    * `uint256 public replaceDuration;`: replaceDuration is in nanoseconds, because it is a difference between NEAR timestamps.
    * `Ed25519 immutable edwards;`
    * `uint256 public lastValidAt;`: End of challenge period. If zero, *`untrusted`* fields and `lastSubmitter` are not meaningful.
    * `uint64 curHeight;`
    * `uint64 untrustedHeight;`: The most recently added block. May still be in its challenge period, so should not be trusted.
    * `address lastSubmitter;`: Address of the account which submitted the last block.
    * `bool public initialized;`: Whether the contract was initialized.
    * `bool untrustedNextEpoch;`
    * `bytes32 untrustedHash;`
    * `bytes32 untrustedMerkleRoot;`
    * `bytes32 untrustedNextHash;`
    * `uint256 untrustedTimestamp;`
    * `uint256 untrustedSignatureSet;`
    * `NearDecoder.Signature[MAX_BLOCK_PRODUCERS] untrustedSignatures;`
    * `Epoch[3] epochs;`
    * `uint256 curEpoch;`
    * `mapping(uint64 => bytes32) blockHashes_;`
    * `mapping(uint64 => bytes32) blockMerkleRoots_;`
    * `mapping(address => uint256) public override balanceOf;`
  * It provides the following functions
    * `constructor(Ed25519 ed, uint256 lockEthAmount_, uint256 lockDuration_, uint256 replaceDuration_, address admin_, uint256 pausedFlags_)`: \_Note: require the `lockDuration` (in seconds) to be at least one second less than the `replaceDuration` (in nanoseconds) `require(replaceDuration* > lockDuration* _ 1000000000);`
      * `ethEd25519Address`: The address of the ECDSA signature checker using Ed25519 curve (see [here](https://nbeguier.medium.com/a-real-world-comparison-of-the-ssh-key-algorithms-b26b0b31bfd9))
      * `lockEthAmount`: The amount that `BLOCK_PRODUCERS` need to deposit (in wei)to be able to provide blocks. This amount will be slashed if the block is challenged and proven not to have a valid signature. Default value is 100000000000000000000 WEI = 100 ETH.
      * `lockDuration` : 30 seconds
      * `replaceDuration`: 60 seconds it is passed in nanoseconds, because it is a difference between NEAR timestamps.
      * `ethAdminAddress`: Bridge Administrator Address
      * `0` : Indicates nothing is paused `UNPAUSE_ALL`
    * `function deposit() public payable override pausable(PAUSED_DEPOSIT)`
    * `function withdraw() public override pausable(PAUSED_WITHDRAW)`
    * `function challenge(address payable receiver, uint signatureIndex) external override pausable(PAUSED_CHALLENGE`
    * `function checkBlockProducerSignatureInHead(uint signatureIndex) public view override returns (bool)`
    * `function initWithValidators(bytes memory data) public override onlyAdmin`: The first part of initialization -- setting the validators of the current epoch.
    * `function initWithBlock(bytes memory data) public override onlyAdmin`: The second part of the initialization -- setting the current head.
    * `function bridgeState() public view returns (BridgeState memory res)`
    * `function bridgeState() public view returns (BridgeState memory res)`
    * `function addLightClientBlock(bytes memory data) public override pausable(PAUSED_ADD_BLOCK)`
    * `function setBlockProducers(NearDecoder.BlockProducer[] memory src, Epoch storage epoch) internal`
    * `function blockHashes(uint64 height) public view override pausable(PAUSED_VERIFY) returns (bytes32 res)`
    * `function blockMerkleRoots(uint64 height) public view override pausable(PAUSED_VERIFY) returns (bytes32 res)`
* [NearProver.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearprover/contracts/NearProver.sol): Is used to prove the validity of NEAR blocks on Ethereum.
  * It imports the following contracts (see [nearbridge cryptographic primitives](#nearbridge-cryptographic-primitives))
    * `import "rainbow-bridge-sol/nearbridge/contracts/NearDecoder.sol";`
    * `import "./ProofDecoder.sol";`
  * It has the following functions
    * `constructor(INearBridge _bridge, address _admin, uint _pausedFlags)`
      * `_bridge`: Interface to `NearBridge.sol`
      * `_admin`: Administrator address
      * `_pausedFlags`: paused indicator defaults to `UNPAUSE_ALL = 0`
    * `function proveOutcome(bytes memory proofData, uint64 blockHeight)`
    * `function _computeRoot(bytes32 node, ProofDecoder.MerklePath memory proof) internal pure returns (bytes32 hash)`

##### NEAR Rainbow Bridge Utils

[rainbow-bridge-utils](https://github.com/aurora-is-near/rainbow-bridge/tree/master/utils) provides a set of utilities for the near rainbow bridge written in javascript.

* It has the following [dependencies](https://github.com/aurora-is-near/rainbow-bridge/blob/master/utils/package.json)
  * [bn.js](https://www.npmjs.com/package/bn.js): Big number implementation in pure javascript
  * [bsert](https://www.npmjs.com/package/bsert): Minimal assert with type checking.
  * [bs58](https://www.npmjs.com/package/bs58): JavaScript component to compute base 58 encoding
  * [change-case](https://www.npmjs.com/package/change-case): Transform a string between camelCase, PascalCase, Capital Case, snake\_case, param-case, CONSTANT\_CASE and others.
  * [configstore](https://www.npmjs.com/package/configstore): Easily load and save config without having to think about where and how
  * [eth-object](https://github.com/near/eth-object#383b6ea68c7050bea4cab6950c1d5a7fa553e72b): re-usable and composable objects that you can just call Object.from to ingest new data to serialize Ethereum Trie / LevelDB data from hex, buffers and rpc into the same format.
  * [eth-util-lite](https://github.com/near/eth-util-lite): a low-dependency utility for Ethereum. It replaces a small subset of the ethereumjs-util and ethjs-util APIs.
  * [lodash](https://www.npmjs.com/package/lodash): A set of utilities for working with arrays, numbers, objects, strings, etc.
  * [near-api-js](https://www.npmjs.com/package/near-api-js): JavaScript library to interact with NEAR Protocol via RPC API
  * [web3](https://www.npmjs.com/package/web3): Ethereum JavaScript API
* It provides the following functions
  * [address-watcher](https://github.com/aurora-is-near/rainbow-bridge/blob/master/utils/address-watcher.js): Watches a group of near and ethereum acccounts polling NEAR and Ethereum every second and updating `nearAccount.balanceGauge`, `nearAccount.stateStorageGauge` and `ethereumAccount.balanceGauge`.
  * [borsh](https://github.com/aurora-is-near/rainbow-bridge/blob/master/utils/borsh.js): provides the following functions for Binary Object Representation Serializer for Hashing [borsh](https://borsh.io/)
    * `function serializeField (schema, value, fieldType, writer)`
    * `function deserializeField (schema, fieldType, reader)`
    * `function serialize (schema, fieldType, obj)`: Serialize given object using schema of the form: `{ class_name -> [ [field_name, field_type], .. ], .. }`
    * `class BinaryReader`: Includes utilities to read numbers, strings arrays and burggers
    * `function deserialize (schema, fieldType, buffer)`
    * `const signAndSendTransactionAsync = async (accessKey, account, receiverId,actions) =>`
    * `const txnStatus = async (account, txHash, retries = RETRY_TX_STATUS, wait = 1000) =>`
    * `function getBorshTransactionLastResult (txResult)`
    * `class BorshContract {`
      * `constructor (borshSchema, account, contractId, options)`
      * `async accessKeyInit ()`
    * `function borshify (block)`
    * `function borshifyInitialValidators (initialValidators)`
    * `const hexToBuffer = (hex) =>`
    * `const readerToHex = (len) =>`
  * [borshify-proof](https://github.com/aurora-is-near/rainbow-bridge/blob/master/utils/borshify-proof.js)
    * `function borshifyOutcomeProof (proof)`
  * [robust](https://github.com/aurora-is-near/rainbow-bridge/blob/master/utils/robust.js): his module gives a few utils for robust error handling, and wrap web3 with error handling and retry
  * [utils](https://github.com/aurora-is-near/rainbow-bridge/blob/master/utils/utils.js)
    * `async function setupNear (config)`
    * `async function setupEth (config)`
    * `async function setupEthNear (config)`: Setup connection to NEAR and Ethereum from given configuration.
    * `function remove0x (value)`: Remove 0x if prepended
    * `function normalizeHex (value)`
    * `async function accountExists (connection, accountId)`
    * `async function createLocalKeyStore (networkId, keyPath)`
    * `function getWeb3 (config)`
    * `function getEthContract (web3, path, address)`
    * `function addSecretKey (web3, secretKey)`
    * `async function ethCallContract (contract, methodName, args)`: Wrap pure calls to Web3 contract to handle errors/reverts/gas usage.

##### nearbridge Cryptographic Primitives

* [Ed25519.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Ed25519.sol): Solidity implementation of the [Ed25519](https://en.wikipedia.org/wiki/EdDSA) which is the EdDSA signature scheme using SHA-512 (SHA-2) and Curve25519 (see [here](https://nbeguier.medium.com/a-real-world-comparison-of-the-ssh-key-algorithms-b26b0b31bfd9)). It has the following functions
  * `function pow22501(uint256 v) private pure returns (uint256 p22501, uint256 p11)` : Computes (v^(2^250-1), v^11) mod p
  * `function check(bytes32 k, bytes32 r, bytes32 s, bytes32 m1, bytes9 m2)` : has the following steps
    * Step 1: compute SHA-512(R, A, M)
    * Step 2: unpack k
    * Step 3: compute multiples of k
    * Step 4: compute s*G - h*A
    * Step 5: compare the points
* [Utils.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Utils.sol): A set of utilty functions for byte manipulation, memory updates and [keccak](https://keccak.team/keccak_specs_summary.html) functions.
  * `function swapBytes2(uint16 v) internal pure returns (uint16)`
  * `function swapBytes4(uint32 v) internal pure returns (uint32)`
  * `function swapBytes8(uint64 v) internal pure returns (uint64)`
  * `function swapBytes16(uint128 v) internal pure returns (uint128)`
  * `function swapBytes32(uint256 v) internal pure returns (uint256)`
  * `function readMemory(uint ptr) internal pure returns (uint res)`
  * `function writeMemory(uint ptr, uint value) internal pure`
  * `function memoryToBytes(uint ptr, uint length) internal pure returns (bytes memory res)`
  * `function keccak256Raw(uint ptr, uint length) internal pure returns (bytes32 res)`
  * `function sha256Raw(uint ptr, uint length) internal view returns (bytes32 res)`
* [Borsh.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Borsh.sol) provides Binary Object Representation Serializer for Hashing [borsh](https://borsh.io/) functionality and imports `Utils.sols`. Structures and functions include
  * `struct Data {uint ptr; uint end;}`
  * `function from(bytes memory data) internal pure returns (Data memory res)`
  * `function requireSpace(Data memory data, uint length) internal pure`: This function assumes that length is reasonably small, so that data.ptr + length will not overflow. In the current code, length is always less than 2^32.
  * `function read(Data memory data, uint length) internal pure returns (bytes32 res)`
  * `function done(Data memory data) internal pure`
  * `function peekKeccak256(Data memory data, uint length) internal pure returns (bytes32)`: Same considerations as for requireSpace.
  * `function peekSha256(Data memory data, uint length) internal view returns (bytes32)`: Same considerations as for requireSpace.
  * `function decodeU8(Data memory data) internal pure returns (uint8)`
  * `function decodeU16(Data memory data) internal pure returns (uint16)`
  * `function decodeU32(Data memory data) internal pure returns (uint32)`
  * `function decodeU64(Data memory data) internal pure returns (uint64)`
  * `function decodeU128(Data memory data) internal pure returns (uint128)`
  * `function decodeU256(Data memory data) internal pure returns (uint256)`
  * `function decodeBytes20(Data memory data) internal pure returns (bytes20)`
  * `function decodeBytes32(Data memory data) internal pure returns (bytes32)`
  * `function decodeBool(Data memory data) internal pure returns (bool)`
  * `function skipBytes(Data memory data) internal pure`
  * `function decodeBytes(Data memory data) internal pure returns (bytes memory res)`
* [NearDecoder.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/NearDecoder.sol): Imports `Borsh.sol` and has utilities for decoding Public Keys, Signatures, Block Producers, Block Headers and Light Client Blocks.
  * `function decodePublicKey(Borsh.Data memory data) internal pure returns (PublicKey memory res)`
  * `function decodeSignature(Borsh.Data memory data) internal pure returns (Signature memory res)`
  * `function decodeBlockProducer(Borsh.Data memory data) internal pure returns (BlockProducer memory res)`
  * `function decodeBlockProducers(Borsh.Data memory data) internal pure returns (BlockProducer[] memory res)`
  * `function decodeOptionalBlockProducers(Borsh.Data memory data) internal view returns (OptionalBlockProducers memory res)`
  * `function decodeOptionalSignature(Borsh.Data memory data) internal pure returns (OptionalSignature memory res)`
  * `function decodeBlockHeaderInnerLite(Borsh.Data memory data) internal view returns (BlockHeaderInnerLite memory res)`
  * `function decodeLightClientBlock(Borsh.Data memory data) internal view returns (LightClientBlock memory res)`
* [ProofDecoder.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearprover/contracts/ProofDecoder.sol): Imports `Borsh.sol` and `NearDecoder.sol` and has utilities for decoding Proofs, BlockHeader, ExecutionStatus, ExecutionOutcome and MerklePaths. Structures and functions include
  * `struct FullOutcomeProof {ExecutionOutcomeWithIdAndProof outcome_proof; MerklePath outcome_root_proof; BlockHeaderLight block_header_lite; MerklePath block_proof;}`
  * `function decodeFullOutcomeProof(Borsh.Data memory data) internal view returns (FullOutcomeProof memory proof)`
  * `struct BlockHeaderLight {bytes32 prev_block_hash; bytes32 inner_rest_hash; NearDecoder.BlockHeaderInnerLite inner_lite; bytes32 hash;}`
  * `function decodeBlockHeaderLight(Borsh.Data memory data) internal view returns (BlockHeaderLight memory header)`
  * `struct ExecutionStatus {uint8 enumIndex; bool unknown; bool failed; bytes successValue; bytes32 successReceiptId;}`
    * `successValue` indicates if the final action succeeded and returned some value or an empty vec.
    * `successReceiptId` is the final action of the receipt returned a promise or the signed transaction was converted to a receipt. Contains the receipt\_id of the generated receipt.
  * `function decodeExecutionStatus(Borsh.Data memory data) internal pure returns (ExecutionStatus memory executionStatus)`
  * `struct ExecutionOutcome {bytes[] logs; bytes32[] receipt_ids; uint64 gas_burnt; uint128 tokens_burnt; bytes executor_id; ExecutionStatus status; bytes32[] merkelization_hashes;}`
    * `bytes[] logs;`: Logs from this transaction or receipt.
    * `bytes32[] receipt_ids;`: Receipt IDs generated by this transaction or receipt.
    * `uint64 gas_burnt;`: The amount of the gas burnt by the given transaction or receipt.
    * `uint128 tokens_burnt;`: The total number of the tokens burnt by the given transaction or receipt.
    * `bytes executor_id;`: Hash of the transaction or receipt id that produced this outcome.
    * `ExecutionStatus status`: Execution status. Contains the result in case of successful execution.
    * `bytes32[] merkelization_hashes;`
  * `function decodeExecutionOutcome(Borsh.Data memory data) internal view returns (ExecutionOutcome memory outcome)`
  * `struct ExecutionOutcomeWithId {bytes32 id; ExecutionOutcome outcome; bytes32 hash;}`
    * `bytes32 id`: is the transaction hash or the receipt ID.
  * `function decodeExecutionOutcomeWithId(Borsh.Data memory data) internal view returns (ExecutionOutcomeWithId memory outcome)`
  * `struct MerklePathItem {bytes32 hash; uint8 direction;}`
    * `uint8 direction`: where 0 = left, 1 = right
  * `function decodeMerklePathItem(Borsh.Data memory data) internal pure returns (MerklePathItem memory item)`
  * `struct MerklePath {MerklePathItem[] items;}`
  * `function decodeMerklePath(Borsh.Data memory data) internal pure returns (MerklePath memory path)`
  * `struct ExecutionOutcomeWithIdAndProof {MerklePath proof; bytes32 block_hash; ExecutionOutcomeWithId outcome_with_id;}`
  * `function decodeExecutionOutcomeWithIdAndProof(Borsh.Data memory data)internal view returns (ExecutionOutcomeWithIdAndProof memory outcome)`

#### Token Transfer Process Flow

The [NEAR Rainbow Bridge](https://near.org/bridge/) uses ERC-20 connectors which are developed in [rainbow-token-connector](https://github.com/aurora-is-near/rainbow-token-connector) and [rainbow-bridge-client](https://github.com/aurora-is-near/rainbow-bridge-client). Also see [eth2near-fun-transfer.md](https://github.com/aurora-is-near/rainbow-bridge/blob/master/docs/workflows/eth2near-fun-transfer.mdx).

Following is an overview of timing and anticipated costs

* Once on NEAR, transactions will confirm in 1-2 seconds and cost well under $1 in most cases.
* Since the Bridge requires transactions on Ethereum for NEAR and Ethereum, the following costs are expected.
* Sending assets from Ethereum to NEAR takes about six minutes (20 blocks) and for ERC-20 costs about $10 on average.
* Sending assets from NEAR back to Ethereum currently takes a maximum of sixteen hours (due to Ethereum finality times) and costs around $60 (due to ETH gas costs and at current ETH price). These costs and speeds will improve in the near future.

*Note: This uses Ethreum [ERC20](https://eips.ethereum.org/EIPS/eip-20) and NEAR [NEP-141](https://nomicon.io/Standards/Tokens/FungibleToken/Core) initally developed for [NEP-21](https://github.com/near/NEPs/pull/21)*

**[Generic ERC-20/NEP-141 connector for Rainbow Bridge](https://github.com/aurora-is-near/rainbow-token-connector/blob/master/README.mdx)**

**Specification**

**Ethereum's side**

```solidity
contract ERC20Locker {
  constructor(bytes memory nearTokenFactory, INearProver prover) public;
  function lockToken(IERC20 token, uint256 amount, string memory accountId) public;
  function unlockToken(bytes memory proofData, uint64 proofBlockHeader) public;
}
```

**NEAR's side**

```rust
struct BridgeTokenFactory {
    /// The account of the prover that we can use to prove
    pub prover_account: AccountId,
    /// Address of the Ethereum locker contract.
    pub locker_address: [u8; 20],
    /// Hashes of the events that were already used.
    pub used_events: UnorderedSet<Vec<u8>>,
    /// Mapping from Ethereum tokens to NEAR tokens.
    pub tokens: UnorderedMap<EvmAddress, AccountId>;
}

impl BridgeTokenFactory {
    /// Initializes the contract.
    /// `prover_account`: NEAR account of the Near Prover contract;
    /// `locker_address`: Ethereum address of the locker contract, in hex.
    #[init]
    pub fn new(prover_account: AccountId, locker_address: String) -> Self;

    /// Relays the lock event from Ethereum.
    /// Uses prover to validate that proof is correct and relies on a canonical Ethereum chain.
    /// Send `mint` action to the token that is specified in the proof.
    #[payable]
    pub fn deposit(&mut self, proof: Proof);

    /// A callback from BridgeToken contract deployed under this factory.
    /// Is called after tokens are burned there to create an receipt result `(amount, token_address, recipient_address)` for Ethereum to unlock the token.
    pub fn finish_withdraw(token_account: AccountId, amount: Balance, recipient: EvmAddress);

    /// Transfers given NEP-21 token from `predecessor_id` to factory to lock.
    /// On success, leaves a receipt result `(amount, token_address, recipient_address)`.
    #[payable]
    pub fn lock(&mut self, token: AccountId, amount: Balance, recipient: String);

    /// Relays the unlock event from Ethereum.
    /// Uses prover to validate that proof is correct and relies on a canonical Ethereum chain.
    /// Uses NEP-21 `transfer` action to move funds to `recipient` account.
    #[payable]
    pub fn unlock(&mut self, proof: Proof);

    /// Deploys BridgeToken contract for the given EVM address in hex code.
    /// The name of new NEP21 compatible contract will be <hex(evm_address)>.<current_id>.
    /// Expects ~35N attached to cover storage for BridgeToken.
    #[payable]
    pub fn deploy_bridge_token(address: String);

    /// Checks if Bridge Token has been successfully deployed with `deploy_bridge_token`.
    /// On success, returns the name of NEP21 contract associated with given address (<hex(evm_address)>.<current_id>).
    /// Otherwise, returns "token do not exists" error.
    pub fn get_bridge_token_account_id(&self, address: String) -> AccountId;
}

struct BridgeToken {
   controller: AccountId,
   token: Token, // uses https://github.com/ilblackdragon/balancer-near/tree/master/near-lib-rs
}

impl BridgeToken {
    /// Setup the Token contract with given factory/controller.
    pub fn new(controller: AccountId) -> Self;

    /// Mint tokens to given user. Only can be called by the controller.
    pub fn mint(&mut self, account_id: AccountId, amount: Balance);

    /// Withdraw tokens from this contract.
    /// Burns sender's tokens and calls controller to create event for relaying.
    pub fn withdraw(&mut self, amount: U128, recipient: String) -> Promise;
}

impl FungibleToken for BridgeToken {
   // see example https://github.com/ilblackdragon/balancer-near/blob/master/balancer-pool/src/lib.rs#L329
}
```

**Setup new ERC-20 on NEAR**

To setup token contract on NEAR side, anyone can call `<bridge_token_factory>.deploy_bridge_token(<erc20>)` where `<erc20>` is the address of the token.
With this call must attach the amount of $NEAR to cover storage for (at least 30 $NEAR currently).

This will create `<<hex(erc20)>.<bridge_token_factory>>` NEP141-compatible contract.

**Usage flow Ethereum -> NEAR**

1. User sends `<erc20>.approve(<erc20locker>, <amount>)` Ethereum transaction.
2. User sends `<erc20locker>.lock(<erc20>, <amount>, <destination>)` Ethereum transaction. This transaction will create `Locked` event.
3. Relayers will be sending Ethereum blocks to the `EthClient` on NEAR side.
4. After sufficient number of confirmations on top of the mined Ethereum block that contain the `lock` transaction, user or relayer can call `BridgeTokenFactory.deposit(proof)`. Proof is the extracted information from the event on Ethereum side.
5. `BridgeTokenFactory.deposit` function will call `EthProver` and verify that proof is correct and relies on a block with sufficient number of confirmations.
6. `EthProver` will return callback to `BridgeTokenFactory` confirming that proof is correct.
7. `BridgeTokenFactory` will call `<<hex(erc20)>.<bridge_token_factory>>.mint(<near_account_id>, <amount>)`.
8. User can use `<<hex(erc20)>.<bridge_token_factory>>` token in other applications now on NEAR.

**Usage flow NEAR -> Ethereum**

1. `token-locker` locks NEP141 tokens on NEAR side.

To deposit funds into the locker, call `ft_transfer_call` where `msg` contains Ethereum address the funds should arrive to.
This will emit `<token: String, amount: u128, recipient address: EthAddress>` (which arrives to `deposit` on Ethereum side).

Accepts `Unlock(token: String, sender_id: EthAddress, amount: u256, recipient: String)` event from Ethereum side with a proof, verifies its correctness.
If `recipient` contains ':' will split it into `<recipient, msg>` and do `ft_transfer_call(recipient, amount, None, msg)`. Otherwise will `ft_transfer` to `recipient`.

To get metadata of token to Ethereum, need to call `log_metadata`, which will create a result `<token: String, name: String, symbol: String, decimals: u8, blockHeight: u64>`.

2. `erc20-bridge-token` - `BridgeTokenFactory` and `BridgeToken` Ethereum contracts.

`BridgeTokenFactory` creates new `BridgeToken` that correspond to specific token account id on NEAR side.

`BridgeTokenFactory` receives `deposit` with proof from NEAR, verify them and mint appropriate amounts on recipient addresses.

Calling `withdraw` will burn tokens of this user and will generate event `<token: String, sender_id: EthAddress, amount: u256, recipient: String>` that can be relayed to `token-factory`.

**Caveats**

Generally, this connector allows any account to call `ft_transfer_call` opening for potential malicious tokens to be bridged to Ethereum.
The expectation here is that on Ethereum side, the token lists will handle this, as it's the same attack model as malicious tokens on Uniswap and other DEXs.

Using Ethereum `BridgeTokenFactory` contract can always resolve Ethereum address of a contract back to NEAR one to check that it is indeed bridging token from NEAR and is created by this factory.

**Testing**

Testing Ethereum side

```
cd erc20-connector
yarn
yarn run test
```

Testing NEAR side

```
make res/bridge_token_factory.wasm
cargo test --all
```

##### Token Transfer Components

*Note: This uses Ethreum [ERC20](https://eips.ethereum.org/EIPS/eip-20) and NEAR [NEP-141](https://nomicon.io/Standards/Tokens/FungibleToken/Core) initally developed for [NEP-21](https://github.com/near/NEPs/pull/21)*

* [rainbow-token-connector](https://github.com/aurora-is-near/rainbow-token-connector)
  * NEAR rust based contracts
    * [bridge-common](https://github.com/aurora-is-near/rainbow-token-connector/tree/master/bridge-common): Common functions for NEAR, currently only `pub fn parse_recipient(recipient: String) -> Recipient`
    * [bridge-token-factory](https://github.com/aurora-is-near/rainbow-token-connector/tree/master/bridge-token-factory): Functions for managing tokens on NEAR including but not limited to `update_metadata`, `deposit`, `get_tokens`, `finish_updating_metadata`, `finish_updating_metadata`, `finish_withdraw`, `deploy_bridge_token`, `get_bridge_token_account_id`, `is_used_proof`, `record_proof`
    * [bridge-token](https://github.com/aurora-is-near/rainbow-token-connector/tree/master/bridge-token): Token functions on NEAR including but not limited to `mint` and `withdraw`
    * [token-locker](https://github.com/aurora-is-near/rainbow-token-connector/tree/master/token-locker): Token Locker functions on NEAR including but not limited to `withdraw`, `finish_deposit`, `is_used_proof`
  * Ethereum solidity based contracts
    * [erc20-bridge-token](https://github.com/aurora-is-near/rainbow-token-connector/tree/master/erc20-bridge-token): Ethereum Bridge token contracts including but not limited to
      * [BridgeToken.sol](https://github.com/aurora-is-near/rainbow-token-connector/blob/master/erc20-bridge-token/contracts/BridgeToken.sol)
      * [BridgeTokenFactory.sol](https://github.com/aurora-is-near/rainbow-token-connector/blob/master/erc20-bridge-token/contracts/BridgeTokenFactory.sol)
      * [BridgeTokenProxy.sol](https://github.com/aurora-is-near/rainbow-token-connector/blob/master/erc20-bridge-token/contracts/BridgeTokenProxy.sol)
      * [ProofConsumer.sol](https://github.com/aurora-is-near/rainbow-token-connector/blob/master/erc20-bridge-token/contracts/ProofConsumer.sol)
      * [ResultsDecoder](https://github.com/aurora-is-near/rainbow-token-connector/blob/master/erc20-bridge-token/contracts/ResultsDecoder.sol)
    * [erc20-connector](https://github.com/aurora-is-near/rainbow-token-connector/tree/master/erc20-connector): has [ERC20Locker.sol](https://github.com/aurora-is-near/rainbow-token-connector/blob/master/erc20-connector/contracts/ERC20Locker.sol) which is used to lock and unlock tokens. It is linked to the bridge token factory on NEAR side. It also links to the prover that it uses to unlock the tokens. (see [here](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearbridge/contracts))

##### References

* [Lighthouse Documentation](https://lighthouse-book.sigmaprime.io/): ETH 2.0 Consensus Client Lighthouse documentation

* [Lighthouse Github](https://github.com/sigp/lighthouse): ETH 2.0 Consensus Client Lighthouse Github

* [Lighthouse: Blog](https://lighthouse-blog.sigmaprime.io/): ETH 2.0 Consensus Client Lighthouse Blog

* [eth2near-block-relay-rs](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/eth2near-block-relay-rs)

* [nearbridge contracts](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearbridge)

* [nearprover contracts](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearprover)

#### Prysm Light Client

##### References

* [Prysm: Light-client (WORK IN PROGRESS)](https://github.com/jinfwhuang/prysm/pull/5):

* [Prysm: Light-client Client WIP](https://github.com/jinfwhuang/prysm/tree/jin-light/cmd/light-client#light-client-client): An independent light client client

* [Prysm: light-client server PR](https://github.com/prysmaticlabs/prysm/pull/10034): a feature PR that implements the basic production level changes to Prysm to comply as a light-client server to begin serving light client requests

### Harmony Merkle Mount Range

* Harmony [MMR PR Review](https://github.com/harmony-one/harmony/pull/3872) and [latest PR](https://github.com/harmony-one/harmony/pull/4198/files) uses Merkle Mountain Ranges to facilitate light client development against Harmony's sharded Proof of Stake Chain

### Near Rainbow Bridge Review

The [NEAR Rainbow bridge](https://near.org/bridge/) is in [this github repository](https://github.com/aurora-is-near/rainbow-bridge) and is supported by [Aurora-labs](https://github.com/aurora-is-near).

It recently provided support for ETH 2.0 in this [Pull Request (762)](https://github.com/aurora-is-near/rainbow-bridge/pull/762).

It interacts [lighthouse](https://github.com/aurora-is-near/lighthouse) for Ethereum 2.0 Consensus and tree\_hash functions as well as bls signatures.

High Level their architecture is similar to the Horizon Bridge but with some key differences, including but not limited to

* interacting with the beacon chain now for finality `is_correct_finality_update` [see finality-update-verify](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/finality-update-verify/src/lib.rs#L36)
* Updated execution block proof to use the BEACONRPCClient and with an updated merkle tree
  * Design can be found in [PR-762](https://github.com/aurora-is-near/rainbow-bridge/pull/762)

#### NEAR Rainbow Bridge: Component Overview

The following smart contracts are deployed on NEAR and work in conjunction with eth2near bridging functionality to propogate blocks from Ethereum to NEAR.

**\*Note** here we will focus on the `eth2-client` for ETH 2.0 Proof of Stake Bridging however if interested in however there is also an `eth-client` which was used for ETH 1.0 Proof of Work Integration using [rust-ethhash](https://github.com/nearprotocol/rust-ethash).\*

* [Smart Contracts Deployed on NEAR](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/near)
  * [eth2-client](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/near/eth2-client) implements the Ethereum Light Client on Near
    * it provides functions including but not limited to:
      * validate the light client
      * verify the finality branch
      * verify bls signatures
      * update finalized headers
      * updates the submittes
      * prune finalized blocks.
    * It interacts with the beach chain, uses [Borsh](https://borsh.io/) for serialization and [lighthouse](https://github.com/aurora-is-near/lighthouse) for Ethereum 2.0 Consensus and tree\_hash functions as well as bls signatures. See [here](https://lighthouse-book.sigmaprime.io/) for more information on lighthouse. Below is a list of dependencies from [eth2-client/Cargo.toml](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/near/eth2-client/Cargo.toml)

      ```
      [dependencies]
      ethereum-types = "0.9.2"
      eth-types =  { path = "../eth-types" }
      eth2-utility =  { path = "../eth2-utility" }
      tree_hash = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
      merkle_proof = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
      bls = { git = "https://github.com/aurora-is-near/lighthouse.git", optional = true, rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec", default-features = false, features = ["milagro"]}
      admin-controlled =  { path = "../admin-controlled" }
      near-sdk = "4.0.0"
      borsh = "0.9.3"
      bitvec = "1.0.0"
      ```

* [eth2near](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near) supports the relaying of blocks and the verification of finality between etherum and Near. It has the following components
  * [contract\_wrapper](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/contract_wrapper): provides rust wrappers for interacting with the [solidity contracts on near](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/near)
    * Contracts include (from [`lib.rs`](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/contract_wrapper/src/lib.rs))

      ```
      pub mod contract_wrapper_trait;
      pub mod dao_contract;
      pub mod dao_eth_client_contract;
      pub mod dao_types;
      pub mod errors;
      pub mod eth_client_contract;
      pub mod eth_client_contract_trait;
      pub mod file_eth_client_contract;
      pub mod near_contract_wrapper;
      pub mod sandbox_contract_wrapper;
      pub mod utils;
      ```

    * Dependencies include (from [contract\_wrapper/Cargo.toml](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/contract_wrapper/Cargo.toml))

      ```
      [dependencies]
      borsh = "0.9.3"
      futures = "0.3.21"
      async-std = "1.12.0"
      near-sdk = "4.0.0"
      near-jsonrpc-client = "=0.4.0-beta.0"
      near-crypto = "0.14.0"
      near-primitives = "0.14.0"
      near-chain-configs = "0.14.0"
      near-jsonrpc-primitives = "0.14.0"
      tokio = { version = "1.1", features = ["rt", "macros"] }
      reqwest = { version = "0.11", features = ["blocking"] }
      serde_json = "1.0.74"
      serde = { version = "1.0", features = ["derive"] }
      eth-types = { path = "../../contracts/near/eth-types/", features = ["eip1559"]}
      workspaces = "0.5.0"
      anyhow = "1.0"
      ```

  * [eth2near-block-relay-rs](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/eth2near-block-relay-rs) is built in rust and integrates with the Ethereum 2.0 lgihthouse consensus client to propogate blocks to near.
    * Functionality includes (from [lib.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/src/lib.rs))

      ```
      pub mod beacon_block_body_merkle_tree;
      pub mod beacon_rpc_client;
      pub mod config;
      pub mod eth1_rpc_client;
      pub mod eth2near_relay;
      pub mod execution_block_proof;
      pub mod hand_made_finality_light_client_update;
      pub mod init_contract;
      pub mod last_slot_searcher;
      pub mod light_client_snapshot_with_proof;
      pub mod logger;
      pub mod near_rpc_client;
      pub mod prometheus_metrics;
      pub mod relay_errors;
      ```

    * Dependencies include (from [eth2near-block-relay-rs/Cargo.toml](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay-rs/Cargo.toml))

      ```
      types =  { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
      tree_hash = { git = "https://github.com/aurora-is-near/lighthouse.git",  rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
      merkle_proof = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
      eth2_hashing = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
      eth2_ssz = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }

      eth-types = { path = "../../contracts/near/eth-types/", features = ["eip1559"]}
      eth2-utility  = { path = "../../contracts/near/eth2-utility" }

      contract_wrapper = { path = "../contract_wrapper" }
      finality-update-verify = { path = "../finality-update-verify" }

      log = { version = "0.4", features = ["std", "serde"] }
      serde_json = "1.0.74"
      serde = { version = "1.0", features = ["derive"] }
      ethereum-types = "0.9.2"
      reqwest = { version = "0.11", features = ["blocking"] }
      clap = { version = "3.1.6", features = ["derive"] }
      tokio = { version = "1.1", features = ["macros", "rt", "time"] }
      env_logger = "0.9.0"
      borsh = "0.9.3"
      near-sdk = "4.0.0"
      futures = { version = "0.3.21", default-features = false }
      async-std = "1.12.0"
      hex = "*"
      toml = "0.5.9"
      atomic_refcell = "0.1.8"
      bitvec = "*"
      primitive-types = "0.7.3"

      near-jsonrpc-client = "=0.4.0-beta.0"
      near-crypto = "0.14.0"
      near-primitives = "0.14.0"
      near-chain-configs = "0.14.0"
      near-jsonrpc-primitives = "0.14.0"

      prometheus = { version = "0.9", features = ["process"] }
      lazy_static = "1.4"
      warp = "0.2"
      thread = "*"

      ```

  * [eth2near-block-relay](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/eth2near-block-relay) is built using javascript and supports ETH 1.0 Proof of Work (`ethhash`) using merkle patrica trees.
    * key classes from [index.js](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay/index.js) include
      * `Ethashproof` : which has functions to `getParseBlock` and `calculateNextEpoch`
      * `Eth2NearRelay` : which interacts with the `ethClientContract` and has a `run()` function which loops through relaying blocks and includes additional functions such as `getParseBlock` , `submitBlock`
    * Dependencies include (from [package.json](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/eth2near-block-relay/package.json))

      ```
      "dependencies": {
          "bn.js": "^5.1.3",
          "eth-object": "https://github.com/near/eth-object#383b6ea68c7050bea4cab6950c1d5a7fa553e72b",
          "eth-util-lite": "near/eth-util-lite#master",
          "@ethereumjs/block": "^3.4.0",
          "merkle-patricia-tree": "^2.1.2",
          "prom-client": "^12.0.0",
          "promisfy": "^1.2.0",
          "rainbow-bridge-utils": "1.0.0",
          "got": "^11.8.5"
      },
      ```

  * [ethhashproof](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/ethashproof): is a commandline to calculate proof data for an ethash POW, it is used by project `SmartPool` and a decentralizedbridge between Etherum and EOS developed by Kyber Network team. It is written in `GO`.
    * Features Include 1. Calculate merkle root of the ethash dag dataset with given epoch 2. Calculate merkle proof of the pow (dataset elements and their merkle proofs) given the pow submission with given block header 3. Generate dag datase
    * Dependencies include (from [ethahsproof/go.mod](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/ethashproof/go.mod))

      ```
      require (
       github.com/deckarep/golang-set v1.7.1
          github.com/edsrzf/mmap-go v1.0.0
          github.com/ethereum/go-ethereum v1.10.4
          github.com/hashicorp/golang-lru v0.5.5-0.20210104140557-80c98217689d
          golang.org/x/crypto v0.0.0-20210322153248-0c34fe9e7dc2
      )
      ```

  * [finality-update-verify](https://github.com/aurora-is-near/rainbow-bridge/tree/master/eth2near/finality-update-verify) checks and updates finality using the lighthouse beacon blocks.
    * Functions include (from [lib.rs](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/finality-update-verify/src/lib.rs))
      * `fn h256_to_hash256(hash: H256) -> Hash256`
      * `fn tree_hash_h256_to_eth_type_h256(hash: tree_hash::Hash256) -> eth_types::H256`
      * `fn to_lighthouse_beacon_block_header(bridge_beacon_block_header: &BeaconBlockHeader,) -> types::BeaconBlockHeader {types::BeaconBlockHeader`
      * `pub fn is_correct_finality_update(ethereum_network: &str, light_client_update: &LightClientUpdate, sync_committee: SyncCommittee, ) -> Result<bool, Box<dyn Error>>`
    * Dependencies include (from [finality-update-verify/Cargo.toml](https://github.com/aurora-is-near/rainbow-bridge/blob/master/eth2near/finality-update-verify/Cargo.toml))

      ```
      [dependencies]
          eth-types = { path ="../../contracts/near/eth-types/", features = ["eip1559"]}
          bls = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
          eth2-utility  = { path ="../../contracts/near/eth2-utility"}
          tree_hash = { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
          types =  { git = "https://github.com/aurora-is-near/lighthouse.git", rev = "b624c3f0d3c5bc9ea46faa14c9cb2d90ee1e1dec" }
          bitvec = "1.0.0"

          [dev-dependencies]
          eth2_to_near_relay = { path = "../eth2near-block-relay-rs"}
          serde_json = "1.0.74"
          serde = { version = "1.0", features = ["derive"] }
          toml = "0.5.9"
      ```

The following smart contracts are deployed on Ethereum and used for propogating blocks from NEAR to Ethereum.

* [Smart Contracts deployed on Ethereum](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth) including
  * [Near Bridge Contracts](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearbridge/contracts) including [NearBridge.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/NearBridge.sol) which the interface [INearBridge.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/INearBridge.sol)

  * Interface Overview

    ```
    interface INearBridge {
        event BlockHashAdded(uint64 indexed height, bytes32 blockHash);
        event BlockHashReverted(uint64 indexed height, bytes32 blockHash);
        function blockHashes(uint64 blockNumber) external view returns (bytes32);
        function blockMerkleRoots(uint64 blockNumber) external view returns (bytes32);
        function balanceOf(address wallet) external view returns (uint256);
        function deposit() external payable;
        function withdraw() external;
        function initWithValidators(bytes calldata initialValidators) external;
        function initWithBlock(bytes calldata data) external;
        function addLightClientBlock(bytes calldata data) external;
        function challenge(address payable receiver, uint256 signatureIndex) external;
        function checkBlockProducerSignatureInHead(uint256 signatureIndex) external view returns (bool);
    }
    ```

  * Key Storage items for epoch and block information

    ```
        Epoch[3] epochs;
        uint256 curEpoch;

        mapping(uint64 => bytes32) blockHashes_;
        mapping(uint64 => bytes32) blockMerkleRoots_;
        mapping(address => uint256) public override balanceOf;
    ```

  * Signing and Serializing Primitives
    * [NearDecoder.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/NearDecoder.sol): handles decoing of Public Keys, Signatures, BlockProducers and LightClientBlocks using `Borsh.sol`
    * [Utils.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Utils.sol): handles reading and writing to memory, memoryToBytes and has functions such as `keccak256Raw` and `sha256Raw`
    * [Borsh.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Borsh.sol): [Borsh](https://borsh.io/): Binary Object Representation Serializer for Hashing. It is meant to be used in security-critical projects as it prioritizes consistency, safety, speed; and comes with a strict specification.
    * [Ed25519.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Ed25519.sol): [Ed25519](https://ed25519.cr.yp.to/) high-speed high-security signatures

  * [Near Prover Contracts](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/eth/nearprover/contracts)
    * [NearProver.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearprover/contracts/NearProver.sol): Has a `proveOutcome` which validates the outcome merkle proof and the block proof is valid using `_computeRoot` which is passed in a `bytes32 node, ProofDecoder.MerklePath memory proof`
    * [ProofDecoder.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearprover/contracts/ProofDecoder.sol): Uses MerklePaths to provide decoding functions such as `decodeExecutionStatus`, `decodeExecutionOutcome`, `decodeExecutionOutcomeWithId`, `decodeMerklePathItem`, `decodeMerklePath` and `decodeExecutionOutcomeWithIdAndProof`. It relies on the primitives `Borsh.sol` and `NearDecoder.sol` above.


## Ethereum Code

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

With the Introduction of Ethereum 2.0<sup>[1](#bp1)</sup> <sup>[2](#bp2)</sup> <sup>[3](#bp3)</sup> block production and consensus were separated<sup>[4](#bp4)</sup> into execution clients<sup>[5](#bp5)</sup> and consensus clients<sup>[6](#ts6)</sup> <sup>[7](#bp7)</sup>.

The execution chain implemented a simplified Proof of Work<sup>[1](#bp1)</sup> reducing difficutly to zero and removing the need for omners (uncles) which would now be handled by the beacon chain<sup>[3](#bp3)</sup> which is responsible for providing consensus <sup>[2](#bp2)</sup>.

Light Clients<sup>[11](#ts11)</sup> were also introduced. To facilate this
a sync committee of 512 current validators is elected every 255 epochs, approximately every 27 hours (see [sample sync comittee data](#sync-committee-latest)), they are responsible for signing each block.

As at December 11th, 2022 Ethereum has 487,920 validators<sup>[8](#bp8)</sup> with a sample epoch ([166581](https://beaconcha.in/epoch/166581)) and slot ([5,330,592](https://beaconcha.in/slot/5330592)) having [139 transactions](https://beaconcha.in/slot/5330592#transactions) with [19,227 votes](https://beaconcha.in/slot/5330592#votes) from 63 committees and [126 aggregated committe attestations](https://beaconcha.in/slot/5330592#attestations).

### Abstract

This research follows on from What to build next in Zero Knowledge<sup>[1](#ov1)</sup>, Crosschain Future<sup>[2](#ov2)</sup> and Technical Problems Overview<sup>[3](#ov3)</sup>.

Here we propose an approach for building a trustless bridging infrastructure between Ethereum and Multiple Chains, complete with costing information for storage, proof generation and verification across multiple chains.

We review technical approaches for Trustless Bridge Design using Zero Knowledge Proofs including storage and validation of block headers, verification of ethereum events on other chains and asset bridging functionality.

For completenes we include a technical review of Ethereum 2.0 block production, consensus, signature schemes and light client functionality.

### Trustless Bridge Design

#### High level Approach

1. Define logic flow for bridging data (ERC20 initially) between Etheruem and a target chain.
2. Identify Key Data Points which Need to be Synched and Frequency
   1. Active Validators (Sync Committee<sup>[10](#ts10)</sup>) : every 255 epochs, approximately 27 hours.
   2. Epoch Committee Verification: every epoch (32 slots), approx 6.4 minutes.
   3. Block Headers: every epoch (32 slots), approx 6.4 minutes.
   4. Bridge Transactions: as Needed.
3. Identify Proving Mechanisms for Data Points
   1. Sync Committee: SSZ Proof
   2. Epoch Comittees
   3. Block Headers: Aggregated BLS Signature Verification Proof, Patricia Merkle
   4. Bridge Transactions: Transaction Proofs
4. Use Zero Knowledge Proofs where possible to reduce storage and compute costing
   1. Sync Committee: SSZ Proof
   2. Epoch Comittees:
   3. Block Headers: Aggregated BLS Signature Verification Proof, Patricia Merkle
   4. Bridge Transactions: Transaction Proofs
5. Relayer and Proving Infrastructure
   1. Relayer operational and verification costs and incentives
   2. Proving infrastructure and proof generation costs (proofs can be used for multiple chains)
   3. Bridging assets infrastructure, incentives and transactional costs

Reference design articles include Succinct<sup>[1](#tb1)</sup> and [Appendix B](#appendix-b-proving-and-verification-mechanisms) includes codebases for proving and verification mechanisms.

#### Logic Flow

**Consensus**

1. Active Validator Set is retrieved
2. Sync Committee is Validated (27 hours)
3. Finality Checkpoint is Validated (per epoch)
4. Block (headers) are relayed
5. Block (headers) are validated: BLS Signatures on Block and Block is in the canonical chain.

**Transaction**

1. Ethereum: A transaction to bridge 100 ISO Tokens is sent
2. Relayer: Picks up Transaction (via event listening) and forwards to Target Light Client.
3. Light Client Verifies Transaction is in a valid block.
   1. Transaction is in Block
   2. Block is in Cannonical Chain
   3. Block has been signed correctly by valid committee
   4. Committe is valid based on the committe allocated to the slot
   5. Sync Committee signed the Comittee Allocation

#### Key Data Points and Storage

* Sync Committe Validator Set Change (Every 255 epochs approx 27 hours)

* Epoch Committee Verification (Every Epoch (32 slots) approx 6.4 minutes)

* Block Verification (Every slot appox 12 seconds)

* Transaction Verifications (As Needed)

#### Proving Logic and Costs

* Sync committee proof

* Epoch comittees proof

* Block proofs

* Transaction proofs

#### ZKP Proving and Verification Costs ZKP Comparison

#### Relayer and Prover Infrastructure

#### Bridging Assets

* Asset Lockers
* Mint and Burn Process
* Utilization of Locked Assets

### Ethereum 2.0 Technical Overview

#### Block Production

Validators run both an Ethereum 1 client (e.g. geth) and a Beacon Chain Client (e.g. prysm). The geth client recieves transactions and places them into blocks. For additional details see the Ethereum Builder Specs<sup>[12](#ts12)</sup>. The following diagrams give an overview of how blocks are proposed and how MEV Boost<sup>[13](#ts13)</sup> could be integrated. For simplification we can replace mev\_boost and relay with geth in the block proposal diagram as the majority of validators simply run a geth node.

![Block Proposal](/assets/research/block-proposal.png "Block Proposal")

#### Slots and Epochs <sup>[6](#ts6)</sup>

> The Beacon Chain provides the heartbeat to Ethereum’s consensus. Each slot is 12 seconds and an epoch is 32 slots: 6.4 minutes.

![Slots and Epochs](/assets/research/Beacon-Chain-Slots-and-Epochs.png.webp "Slots and Epochs")

#### Block Proposals

When a validator is nominated as a proposer for a slot in an Epoch they propose a block gathered from there Ethereum 1 client.

This proposed block is attested to by other validators who have been assigned as committe members for this slot<sup>[6](#ts6)</sup>.

> A block proposer is a validator that has been pseudorandomly selected to build a block.
>
> Most of the time, validators are attesters that vote on blocks. These votes are recorded in the Beacon Chain and determine the head of the Beacon Chain.

![Validators and Attestations](/assets/research/Beacon-Chain-Validators.png "Validators and Attestations")

#### Committees

> A committee is a group of validators. For security, each slot has committees of at least 128 validators. An attacker has less than a one in a trillion probability of controlling ⅔ of a committee.
>
> The concept of a randomness beacon that emits random numbers for the public, lends its name to the Ethereum Beacon Chain. The Beacon Chain enforces consensus on a pseudorandom process called RANDAO.

![Committees](/assets/research/Beacon-Chain-RANDAO.png "Committees")

#### Attestations

The attestation lifecyle<sup>[9](#ts9)</sup> involves

1. Generation of the proposed Block
2. Propagation of the block to committee members to vote on and sign
3. Aggregation of the votes (signatures) of the committee members by Aggregators
4. Propagation of the aggregated attestations back to the block Proposer
5. Inclusion of the block in the Beaconchain

![Attestation Life Cycle](/assets/research/AttestationLifeCycle.png "Attestation Life Cycle")

#### Checkpoints and Finality<sup>[6b](#ts6b)</sup>

> When an epoch ends, if its checkpoint has garnered a ⅔ supermajority, the checkpoint gets justified.

![Checkpoints](/assets/research/Beacon-Chain-Checkpoints.jpg "Checkpoints")

> If a checkpoint B is justified and the checkpoint in the immediate next epoch becomes justified, then B becomes finalized. Typically, a checkpoint is finalized in two epochs, 12.8 minutes.

![Finality](/assets/research/Beacon-Chain-Justification-and-Finalization.png "Finality")

#### Sync Committee <sup>[10](#ts10)</sup>

A sync committee of 512 current validators is elected every 255 epochs, approximately every 27 hours (see [sample sync comittee data](#sync-committee-latest)).
They are responsible for signing each block which records which sync committee members (validtors) signed the block, held in `syncaggregate_bits`, and creates a bls aggregate signature held in `syncaggregate_signature` (see [block-data](#block-data-for-slot-5330592)).

```
    "syncaggregate_bits": "0xdffffffffffffffffffffffffffffff7fffffffffffffffffffffffffffffffffffffffffffffffffffffffdfffffffffffffffdffffffffffffffffffffffff",
    "syncaggregate_participation": 0.9921875,
    "syncaggregate_signature": "0x95332c55790018eed3d17eada01cb4045348d09137505bc8697eeedaa3800a830ee2c138251850a9577f62a5488419ef0a722579156a177fb3a147017f1077af5d778f46a4cdf815fc450129d135fe5286e16df68333592e4aa45821bde780dd",
```

This is used in Altair Light Client -- Sync Protocol<sup>[11](#ts11)</sup> which enables the beacon chain to be light client friendly for constrained environments to access Ethereum.

#### Validator Lifecycle

Following is an overview of statuses for validators in Ethereum 2.0 phase 0 <sup>[14](#ts14)</sup>.

> 1. **Deposited**: the validator has made a deposit and has registered in BeaconState.
> 2. **Eligible to be activated (Pending)**: the validator is eligible to be activated.
> 3. **Activated**: the validator is activated
>    * *Note that the validator may be “eligible to be activated, but has not been activated yet”.*
> 4. **Slashed**: the validator has been slashed
> 5. **Exited**: the validator is exited
> 6. **Withdrawable**: the validator is withdrawable
>    * *Note that the validator will be able to withdraw to EEs in phase 2*
>
> *Note that in some cases, a validator can be in multiple statuses at the same time, e.g., an active validator may be “activated and slashed”.*

![Validator Status Transition](/assets/research/ValidatorStateTransition.png "Validator Status Transition")

### Ethreum 2.0 Technical Deep Dive

#### Block Production

**Process Flow**

* Transactions are placed in [txpool](https://github.com/ethereum/go-ethereum/tree/master/core/txpool)
* The transaction pool is read and [blocks](https://github.com/ethereum/go-ethereum/blob/release/1.9/core/types/block.go#L169) are produced by the [miner](https://github.com/ethereum/go-ethereum/blob/master/miner/miner.go)
* Blocks Headers get forwarded to the Beacon chain once they pass [beacon consensus](https://github.com/ethereum/go-ethereum/blob/master/consensus/beacon/consensus.go)
* The Beacon chain embeds the EthChain Header into a [BeaconBlock](https://github.com/prysmaticlabs/prysm/blob/develop/consensus-types/blocks/types.go#L43)

#### Consensus and Finality

Attestation Process Flow

* Proposing Block
* Signing Blocks
* Aggregated Attestation generation
* Block Proposal and Inclusion of Attestation
* The [SignedBeaconBlock](https://github.com/prysmaticlabs/prysm/blob/develop/consensus-types/blocks/types.go#L72) is added to the chain

Attestations Block(LMD Ghost Vote) and Epoch Checkpoints (FFG Votes)

* The validators in the committee attest to the validity of the block (LMD Ghost Vote)
* The validators in the comittee attest to the first block in the Epoch (FFG Vote)

From [Attestations, ethereum.org](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/attestations)

> Every epoch (6.4 minutes) a validator proposes an attestation to the network. The attestation is for a specific slot in the epoch. The purpose of the attestation is to vote in favor of the validator's view of the chain, in particular the most recent justified block and the first block in the current epoch (known as source and target checkpoints). This information is combined for all participating validators, enabling the network to reach consensus about the state of the blockchain.
>
> The attestation contains the following components:
>
> * aggregation\_bits: a bitlist of validators where the position maps to the validator index in their committee; the value (0/1) indicates whether the validator signed the data (i.e. whether they are active and agree with the block proposer)
> * data: details relating to the attestation, as defined below
> * signature: a BLS signature that aggregates the signatures of individual validators
>
> The first task for an attesting validator is to build the data. The data contains the following information:
>
> * slot: The slot number that the attestation refers to
> * index: A number that identifies which committee the validator belongs to in a given slot
> * beacon\_block\_root: Root hash of the block the validator sees at the head of the chain (the result of applying the fork-choice algorithm)
> * source: Part of the finality vote indicating what the validators see as the most recent justified block
> * target: Part of the finality vote indicating what the validators see as the first block in the current epoch
>
> Once the data is built, the validator can flip the bit in aggregation\_bits corresponding to their own validator index from 0 to 1 to show that they participated.
>
> Finally, the validator signs the attestation and broadcasts it to the network.

**Technical Details**

Following is an overview of the state structure and logic for generating committees and aggregating attestations. For data structures, please see [Beacon State Data Structures from Prysm](#beacon-state-data-structures-from-prysm) and [web3signer\_types from prysm](#web3signer_types-from-prysm).

[BeaconState](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/state#BeaconState) contains both a [ReadOnlyBeaconState](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/state#ReadOnlyBeaconState) and a [WriteOnlyBeaconState](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/state#WriteOnlyBeaconState) wich contain [ReadOnlyValidators](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/state#ReadOnlyValidators) and [ReadOnlyRandaoMixes](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/state#ReadOnlyRandaoMixes) and [WriteOnlyValidators](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/state#WriteOnlyValidators) and [WriteOnlyRandaoMixes](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/state#WriteOnlyRandaoMixes) respectively.

At the beginning of each epoch [func ProcessRandaoMixesReset](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/epoch#ProcessRandaoMixesReset) processes the final updates to RANDAO mix during epoch processing. This calls [RandaoMix](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#RandaoMix) which returns the randao mix (xor'ed seed) of a given slot. It is used to shuffle validators.

Following are sample mixes generated from [func TestRandaoMix\_OK](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/core/helpers/randao_test.go#L16) by adding the statement `fmt.Printf("mix: %v\n", mix)`

```
mix: [10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
mix: [40 9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
mix: [159 134 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
```

The shuffle functions consist of

* [func ShuffleList](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#ShuffleList): returns list of shuffled indexes in a pseudorandom permutation `p` of `0...list_size - 1` with “seed“ as entropy. We utilize 'swap or not' shuffling in this implementation; we are allocating the memory with the seed that stays constant between iterations instead of reallocating it each iteration as in the spec. This implementation is based on the original implementation from protolambda, [https://github.com/protolambda/eth2-shuffle](https://github.com/protolambda/eth2-shuffle)

  Following is an example of a shuffled list generated from [TestShuffleList\_OK](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/core/helpers/shuffle_test.go#L25)

  ```
  list1: [0 1 2 3 4 5 6 7 8 9]
  seed1: [1 128 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
  shuffledList1: [0 7 8 6 3 9 4 5 2 1]
  ```

* [func ShuffleIndex](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#ShuffledIndex): returns `p(index)` in a pseudorandom permutation `p` of `0...list_size - 1` with “seed“ as entropy. We utilize 'swap or not' shuffling in this implementation; we are allocating the memory with the seed that stays constant between iterations instead of reallocating it each iteration as in the spec. This implementation is based on the original implementation from protolambda, [https://github.com/protolambda/eth2-shuffle](https://github.com/protolambda/eth2-shuffle)

* [func ShuffleIndices](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#ShuffledIndices): ShuffledIndices uses input beacon state and returns the shuffled indices of the input epoch, the shuffled indices then can be used to break up into committees.

Committes are formed using functions from [beacon\_comittee.go](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/core/helpers/beacon_committee.go)

* [func BeaconComittee](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#BeaconCommittee): returns the beacon committee of a given slot and committee index. The validator indices and seed are provided as an argument rather than an imported implementation from the spec definition. Having them as an argument allows for cheaper computation run time. (This is an optomized version of [func BeaconComitteFromState](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#BeaconCommitteeFromState))

  Following is an example of a `beaconComittee` generated by adding the following lines to [TestBeaconCommitteeFromState\_UpdateCacheForPreviousEpoch](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/core/helpers/beacon_committee_test.go#L574):

```
var beaconCommittee []types.ValidatorIndex
beaconCommittee, err = BeaconCommitteeFromState(context.Background(), state, 1 /_previous epoch_/, 0)
fmt.Printf("beaconComittee: %+v\n", beaconCommittee)
```

Result

```
beaconComittee: [160 338 313 307 320 324 45 469 196 303 23 14 97 312 126 488]
```

* [func CommitteeAssignments](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#CommitteeAssignments): is a map of validator indices pointing to the appropriate committee assignment for the given epoch.

1. Determine the proposer validator index for each slot.
2. Compute all committees.
3. Determine the attesting slot for each committee.
4. Construct a map of validator indices pointing to the respective committees.

Following is an example of `commitees` generated by adding the following lines to [TestComputeCommittee\_WithoutCache](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/core/helpers/beacon_committee_test.go#L23)

```
committees, err := computeCommittee(indices, seed, 0, 1 /_ Total committee_/)
fmt.Printf("committees: %+v\n", committees)
```

<details>
  <summary>result</summary>

  ```
  committees: [799 45 913 1 631 654 417 244 1270 918 798 719 426 164 1171 863 848 522 828 359 713 972 284 680 203 832 453 75 979 468 667 540 180 729 1137 156 624 434 655 974 108 321 641 750 1150 356 933 870 650 984 869 95 975 510 563 1002 821 819 599 597 593 635 982 915 693 910 1030 845 461 887 936 354 1075 1253 1238 1011 395 773 670 54 389 765 1183 912 866 1230 1279 521 898 598 1038 814 377 1209 1226 19 1087 775 820 401 640 1028 673 174 493 857 931 288 475 1115 139 429 353 295 412 1136 1166 1191 496 677 1039 629 826 528 769 289 856 147 1227 243 731 297 924 89 644 557 1027 1239 1109 447 323 716 764 669 903 612 350 1046 392 768 1257 1083 216 294 606 971 103 902 1015 801 674 1099 49 484 995 1012 146 879 1156 548 1081 844 873 1246 1107 115 121 1018 387 751 941 1259 183 916 937 71 163 287 706 421 304 247 310 113 1032 776 502 1276 274 1214 418 271 307 1224 332 1222 240 657 1060 479 874 14 1147 627 122 448 1082 458 371 214 64 487 1263 34 172 497 880 555 1091 839 507 530 1170 498 999 727 950 317 1266 423 134 364 1092 1128 155 362 419 1219 1019 379 1163 483 917 318 804 336 985 463 584 210 1255 26 583 850 365 723 433 1073 1141 735 922 1035 893 774 1114 256 358 1044 997 546 679 1024 699 1096 663 1066 499 366 1256 883 566 17 717 393 422 622 795 1181 554 1212 736 1064 106 1050 72 1153 1210 198 943 818 518 309 101 471 0 38 688 107 718 1077 1021 648 1236 891 969 39 481 1159 660 686 450 990 1045 1213 756 900 849 355 119 1135 623 878 44 596 262 553 1013 290 269 691 18 207 454 620 221 983 852 430 843 1272 209 526 1100 865 402 437 278 976 1185 784 128 906 536 608 683 1205 574 1251 562 344 930 440 758 472 239 369 73 1235 478 724 373 399 1142 375 490 966 1203 1093 403 74 65 1247 579 145 1090 143 80 190 187 449 1160 194 959 533 671 442 136 158 665 79 253 226 1076 572 1130 227 909 940 275 43 342 182 126 967 700 267 1070 171 1000 658 876 1120 424 141 1164 328 1277 1220 1245 314 335 886 249 638 836 104 527 1057 1179 1111 551 334 749 754 237 1232 495 549 672 250 547 1132 427 346 935 515 452 184 739 77 689 744 831 281 76 48 2 327 542 351 47 1079 661 585 746 709 260 486 1242 932 303 435 1061 282 1217 390 996 457 470 40 592 785 1065 24 160 991 920 858 978 616 934 586 601 939 730 501 859 482 1207 386 1037 78 1184 947 861 643 231 22 397 1126 1215 265 1145 864 942 809 398 715 890 385 559 232 777 185 410 131 112 192 632 1124 302 1025 904 1047 94 1175 516 474 1122 568 617 894 733 1074 1252 264 263 851 124 1258 1023 1121 283 901 1225 923 464 193 1140 810 604 1108 740 1157 368 853 199 270 8 752 529 973 90 246 896 11 960 6 734 285 299 1042 152 732 965 469 161 609 1234 467 1084 780 1069 466 816 588 50 1194 1127 5 1010 31 712 766 1049 813 157 27 259 1055 343 793 1005 127 558 1036 794 1006 1178 767 1168 537 254 1218 590 361 531 186 567 605 4 255 618 37 1216 1134 337 223 811 962 67 587 1001 1187 842 455 1228 1248 1056 300 613 396 1152 830 329 61 1155 439 1188 807 1182 268 662 1101 1026 82 847 755 757 148 1244 778 664 1059 1197 301 1117 1274 743 840 316 123 634 272 1237 326 1041 1068 372 1003 1190 1243 630 298 215 166 445 513 838 363 1085 854 639 503 129 1029 1196 219 325 1161 70 165 564 1206 111 1078 1233 970 444 12 400 211 742 191 41 760 506 196 988 1173 125 177 420 805 957 862 1088 1144 1267 1265 994 380 1250 505 235 1089 451 120 762 867 1167 117 675 16 711 575 1009 85 577 550 1116 895 438 822 138 308 13 349 233 197 404 142 1123 589 614 251 411 1007 228 151 911 105 1162 738 140 892 1110 607 511 802 580 459 293 619 927 488 378 60 1020 236 212 279 980 322 1052 29 720 173 812 1043 882 797 159 926 1261 58 726 492 494 242 3 725 800 524 1062 1195 504 1016 808 168 436 682 383 952 615 179 57 921 370 394 945 489 1254 154 938 789 1229 339 684 806 525 539 787 1268 698 1008 621 225 408 32 964 357 188 477 114 581 144 745 701 110 391 460 381 181 1231 63 206 1264 480 538 561 591 1113 1202 825 348 704 33 625 783 681 1063 1080 1240 217 28 1176 928 582 914 229 252 1102 552 280 728 594 1017 35 406 137 175 162 1118 176 66 296 837 56 508 786 602 102 443 1095 868 696 899 692 1086 1223 907 834 1241 1172 118 1221 855 266 556 1098 384 948 55 340 178 1249 150 781 642 514 771 291 877 519 100 919 224 376 1125 987 645 1169 305 1133 319 201 611 956 42 189 238 908 703 88 981 954 1139 1174 881 576 1105 1186 1201 414 545 741 407 313 23 653 1051 509 872 195 649 1208 1165 1014 595 222 697 1112 1033 234 748 823 570 476 1198 1180 1154 248 257 905 306 1269 676 116 135 51 208 68 202 646 1177 312 86 388 1200 833 779 791 153 347 230 1158 565 543 261 986 875 1193 415 889 273 20 258 600 860 573 636 149 759 374 1072 1053 610 286 656 1119 1260 500 637 702 97 951 628 170 491 944 747 99 714 1278 721 69 571 83 520 473 569 989 98 245 929 1106 961 431 955 1004 884 998 446 544 949 220 535 1031 311 93 1262 871 763 1273 485 647 352 803 205 652 1034 687 958 888 753 792 456 782 59 462 441 796 708 1192 360 96 1148 678 428 277 1189 1071 633 1151 1103 25 993 835 241 1211 320 968 788 338 925 7 9 668 84 330 204 690 133 405 1094 1138 1097 1275 761 1104 10 897 315 517 694 416 685 560 62 772 382 977 87 651 532 659 827 1204 737 841 331 213 1040 132 846 963 695 130 292 91 1022 324 81 992 1199 770 790 465 523 425 1146 21 1054 815 345 829 666 603 1067 109 167 722 432 1149 953 512 413 707 1058 885 218 626 341 409 824 30 705 1048 578 367 710 946 36 1131 46 200 534 15 92 1129 276 817 169 53 52 541 333 1143 1271]
  ```
</details>

Attestations are managed using functions from [attestation.go](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/core/helpers/attestation.go)

* [func ValidateNilAttestation](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#ValidateNilAttestation): checks if any composite field of input attestation is nil. Access to these nil fields will result in run time panic, it is recommended to run these checks as first line of defense.
* [func ValidateSlotTargetEpoch](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#ValidateSlotTargetEpoch): ValidateSlotTargetEpoch checks if attestation data's epoch matches target checkpoint's epoch. It is recommended to run `ValidateNilAttestation` first to ensure `data.Target` can't be nil.
* [func IsAggregator](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#IsAggregator): IsAggregator returns true if the signature is from the input validator. The committee count is provided as an argument rather than imported implementation from spec. Having committee count as an argument allows cheaper computation at run time.
* [func AggregateSignature](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#AggregateSignature): returns the aggregated signature of the input attestations.

  Spec pseudocode definition:

```
def get_aggregate_signature(attestations: Sequence[Attestation]) -> BLSSignature:
signatures = [attestation.signature for attestation in attestations]
return bls.Aggregate(signatures)
```

Following is an example aggregrated signature by adding the following lines to [TestAttestation\_AggregateSignature](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/core/helpers/attestation_test.go#L48)

```
aggSig, err := helpers.AggregateSignature(atts)
```

fmt.Printf("aggSig: %+v\n", aggSig)

Result

```
    aggSig: &{s:0xc0003fe000}
```

* [func IsAggregated](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#IsAggregated): IsAggregated returns true if the attestation is an aggregated attestation, false otherwise.

* [func ComputeSubnetForAttestation](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#ComputeSubnetForAttestation): returns the subnet for which the provided attestation will be broadcasted to.This differs from the spec definition by instead passing in the active validators indices in the attestation's given epoch.

Spec pseudocode definition:

```
def compute_subnet_for_attestation(committees_per_slot: uint64, slot: Slot, committee_index: CommitteeIndex) -> uint64:

"""
Compute the correct subnet for an attestation for Phase 0.
Note, this mimics expected future behavior where attestations will be mapped to their shard subnet.
"""
slots_since_epoch_start = uint64(slot % SLOTS_PER_EPOCH)
committees_since_epoch_start = committees_per_slot \* slots_since_epoch_start

return uint64((committees_since_epoch_start + committee_index) % ATTESTATION_SUBNET_COUNT)
```

* [func ComputeSubnetFromCommitteeAndSlot](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#ComputeSubnetFromCommitteeAndSlot): is a flattened version of ComputeSubnetForAttestation where we only pass in the relevant fields from the attestation as function arguments.

Spec pseudocode definition:

```

def compute_subnet_for_attestation(committees_per_slot: uint64, slot: Slot, committee_index: CommitteeIndex) -> uint64:

"""
Compute the correct subnet for an attestation for Phase 0.
Note, this mimics expected future behavior where attestations will be mapped to their shard subnet.
"""
slots_since_epoch_start = uint64(slot % SLOTS_PER_EPOCH)
committees_since_epoch_start = committees_per_slot \* slots_since_epoch_start

return uint64((committees_since_epoch_start + committee_index) % ATTESTATION_SUBNET_COUNT)

```

* [func ValidateAttestationTime](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#ValidateAttestationTime): Validates that the incoming attestation is in the desired time range.
  An attestation is valid only if received within the last ATTESTATION\_PROPAGATION\_SLOT\_RANGE slots.

Example:

```

ATTESTATION_PROPAGATION_SLOT_RANGE = 5
clockDisparity = 24 seconds
current_slot = 100
invalid_attestation_slot = 92
invalid_attestation_slot = 103
valid_attestation_slot = 98
valid_attestation_slot = 101

```

In the attestation must be within the range of 95 to 102 in the example above.

* [func VerifyCheckpointEpoch](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#VerifyCheckpointEpoch): VerifyCheckpointEpoch is within current epoch and previous epoch with respect to current time. Returns true if it's within, false if it's not.

*Note: Sample command for running tests in Prysm: `bazel test //beacon-chain/core/helpers:go_default_test --test_output=streamed --test_filter=TestAttestation_AggregateSignature`.*

**Consensus Committee Selection**

* [func ProcessRandoa](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/blocks#ProcessRandao): checks the block proposer's randao commitment and generates a new randao mix to update in the beacon state's latest randao mixes slice.
* [func randaoSigningData](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/core/blocks/signature.go#L157): retrieves the randao related signing data from the state.
  * [func (b \*BeaconState) PubkeyAtIndex(idx types.ValidatorIndex) \[fieldparams.BLSPubkeyLength\]byte ](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/state/state-native/getters_validator.go#L135): returns the pubkey at the given validator index.

#### Light Client Support

#### Signature Schemes Review

* Execution Chain Block Signing

* Vote Signing

* Aggregated Attestations Signing

* Synch Committee Signing

### Ethereum 2.0 Light Client

#### Key Concepts

* Syncing to Current state

* Advancing Blocks

* Communication can be either via

* RPC to the [Eth BEACON Node API](https://ethereum.github.io/beacon-APIs/#/Beacon)

* [Networking Gossip Topics](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/p2p-interface.md#global-topics)
  * [light\_client\_finality\_update](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/p2p-interface.md#light_client_finality_update): This topic is used to propagate the latest `LightClientFinalityUpdate` to light clients, allowing them to keep track of the latest `finalized_header`.
  * [light\_client\_optimistic\_update](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/p2p-interface.md#light_client_optimistic_update): This topic is used to propagate the latest`LightClientOptimisticUpdate` to light clients, allowing them to keep track of the latest `optimistic_header`.

*Note: Time on Ethereum 2.0 Proof of Stake is divided into slots and epochs. One slot is 12 seconds. One epoch is 6.4 minutes, consisting of 32 slots. One block can be created for each slot.*

#### Altair Light Client -- Sync Protocol

* [Altair Light Client -- Sync Protocol](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.mdx): The beacon chain is designed to be light client friendly for constrained environments to access Ethereum with reasonable safety and liveness.

Such environments include resource-constrained devices (e.g. phones for trust-minimized wallets)and metered VMs (e.g. blockchain VMs for cross-chain bridges).

This document suggests a minimal light client design for the beacon chain thatuses sync committees introduced in [this beacon chain extension](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/beacon-chain.mdx).

Additional documents describe how the light client sync protocol can be used:

* [Full node](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/full-node.mdx)

* [Light client](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/light-client.mdx)

* [Networking](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/p2p-interface.mdx)

* [Light client sync process](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/light-client.mdx): explains how light clients MAY obtain light client data to sync with the network.

1. The light client MUST be configured out-of-band with a spec/preset (including fork schedule), with `genesis_state` (including `genesis_time` and `genesis_validators_root`), and with a trusted block root. The trusted block SHOULD be within the weak subjectivity period, and its root SHOULD be from a finalized `Checkpoint`.
2. The local clock is initialized based on the configured `genesis_time`, and the current fork digest is determined to browse for and connect to relevant light client data providers.
3. The light client fetches a [`LightClientBootstrap`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/light-client.mdx) object for the configured trusted block root. The `bootstrap` object is passed to [`initialize_light_client_store`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#initialize_light_client_store) to obtain a local [`LightClientStore`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#lightclientstore).
4. The light client tracks the sync committee periods `finalized_period` from `store.finalized_header.slot`, `optimistic_period` from `store.optimistic_header.slot`, and `current_period` from `current_slot` based on the local clock.
   1. When `finalized_period == optimistic_period` and [`is_next_sync_committee_known`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#is_next_sync_committee_known) indicates `False`, the light client fetches a [`LightClientUpdate`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#lightclientupdate) for `finalized_period`. If `finalized_period == current_period`, this fetch SHOULD be scheduled at a random time before `current_period` advances.
   2. When `finalized_period + 1 < current_period`, the light client fetches a `LightClientUpdate` for each sync committee period in range `[finalized_period + 1, current_period)` (current period excluded)
   3. When `finalized_period + 1 >= current_period`, the light client keeps observing [`LightClientFinalityUpdate`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#lightclientfinalityupdate) and [`LightClientOptimisticUpdate`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#lightclientoptimisticupdate). Received objects are passed to [`process_light_client_finality_update`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#process_light_client_finality_update) and [`process_light_client_optimistic_update`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#process_light_client_optimistic_update). This ensures that `finalized_header` and `optimistic_header` reflect the latest blocks.
5. [`process_light_client_store_force_update`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#process_light_client_store_force_update) MAY be called based on use case dependent heuristics if light client sync appears stuck. If available, falling back to an alternative syncing mechanism to cover the affected sync committee period is preferred.

#### The Portal Network

* [The Portal Network](https://github.com/ethereum/portal-network-specs): The Portal Network is an in progess effort to enable lightweight protocol access by resource constrained devices. The term *"portal"* is used to indicate that these networks provide a *view* into the protocol but are not critical to the operation of the core Ethereum protocol.

The Portal Network is comprised of multiple peer-to-peer networks which together provide the data and functionality necessary to expose the standard [JSON-RPC API](https://eth.wiki/json-rpc/API). These networks are specially designed to ensure that clients participating in these networks can do so with minimal expenditure of networking bandwidth, CPU, RAM, and HDD resources.

The term 'Portal Client' describes a piece of software which participates in these networks. Portal Clients typically expose the standard JSON-RPC API.

* Motivation: The Portal Network is focused on delivering reliable, lightweight, and decentralized access to the Ethereum protocol.

* Prior Work on the "Light Ethereum Subprotocol" (LES): The term "light client" has historically refered to a client of the existing [DevP2P](https://github.com/ethereum/devp2p/blob/master/rlpx.mdx) based [LES](https://github.com/ethereum/devp2p/blob/master/caps/les.mdx) network. This network is designed using a client/server architecture. The LES network has a total capacity dictated by the number of "servers" on the network. In order for this network to scale, the "server" capacity has to increase. This also means that at any point in time the network has some total capacity which if exceeded will cause service degradation across the network. Because of this the LES network is unreliable when operating near capacity.

* Block Relay

* [Beacon State](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/beacon-state-network.md#dht-overview): A client has a trusted beacon state root, and it wants to access some parts of the state. Each of the access request corresponds to some leave nodes of the beacon state. The request is a content lookup on a DHT. The response is a Merkle proof.

  A Distributed Hash Table (DHT) allows network participants to have retrieve data on-demand based on a content

* [Syncing Block Headers](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/sync-gossip.mdx): A beacon chain client could sync committee to perform state updates. The data object LightClientSkipSyncUpdate allows a client to quickly sync to a recent header with the appropriate sync committee. Once the client establishes a recent header, it could sync to other headers by processing LightClientUpdates. These two data types allow a client to stay up-to-date with the beacon chain.
  * [Sync State](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/skip-sync-network.mdx): A client uses SkipSyncUpdate to skip sync from a known header to a recent header. A client with a trusted but outdated header cannot use the messages in the gossip channel bc-light-client-update to update. The client's sync-committee in the stored snapshot is too old and not connected to any update messages. The client look for the appropriate SkipSyncUpdate to skip sync its header.
  * [Advance Block Headers](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/sync-gossip.mdx): A beacon chain client could sync committee to perform [state updates](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/sync-protocol.mdx). The data object [LightClientSkipSyncUpdate](skip-sync-network) allows a client to quickly sync to a recent header with the appropriate sync committee. Once the client establishes a recent header, it could sync to other headers by processing [LightClientUpdates](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/sync-protocol.md#lightclientupdate). These two data types allow a client to stay up-to-date with the beacon chain.

    These two data types are placed into separate sub-networks. A light client make find-content requests on `skip-sync-network` at start of the sync to get a header with the same `SyncCommittee` object as in the current sync period. The client uses messages in the gossip topic `bc-light-client-update` to advance its header.

    The gossip topics described in this document is part of a [proposal](https://ethresear.ch/t/a-beacon-chain-light-client-proposal/11064) for a beacon chain light client.

#### Transaction Proofs

* [Retrieving Beacon State](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/beacon-state-network.mdx): A client has a trusted beacon state root, and it wants to access some parts of the state. Each of the access request corresponds to some leave nodes of the beacon state. The request is a content lookup on a DHT. The response is a Merkle proof.

A Distributed Hash Table (DHT) allows network participants to have retrieve data on-demand based on a content key. A portal-network DHT is different than a traditional one in that each participant could selectively limit its workload by choosing a small interest radius r. A participants only process messages that are within its chosen radius boundary.

* [Wire Protocol](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/beacon-state-network.md#wire-protocol): For a subprotocol, we need to further define the following to be able to instantiate the wire format of each message type. 1. `content_key` 2. `content_id` 3. `payload`

  The content of the message is a Merkle proof contains multiple leave nodes for a [BeaconState](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/beacon-chain.md#beaconstate).

  Finally, we define the necessary encodings. A light client only knows the root of the beacon state. The client wants to know the details of some leave nodes. The client has to be able to construct the `content_key` only knowing the root and which leave nodes it wants see. The `content_key` is the ssz serialization of the paths. The paths represent the part of the beacon state that one wants to know about. The paths are represented by generalized indices. Note that `hash_tree_root` and `serialize` are the same as those defined in [sync-gossip](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/sync-gossip.mdx).

* TODO: Review of Retrieving a transaction proof not just retrieving data on-demand

#### Further Information

* Ethereum 2.0 Specifications
* [Beacon Chain Specification](https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.mdx)
* [Extended light client protocol](https://notes.ethereum.org/@vbuterin/extended_light_client_protocol)
* [Altair Light Client -- Light Client](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/light-client.mdx)
* [Altair Light Client -- Sync Protocol](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.mdx)
* [Beacon Chain Fork Choice](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/fork-choice.mdx)
* [The Portal Network Specification](https://github.com/ethereum/portal-network-specs): an in progess effort to enable lightweight protocol access by resource constrained devices.
* [Light Ethereum Subprotocol (LES)](https://github.com/ethereum/devp2p/blob/master/caps/les.mdx): the protocol used by "light" clients, which only download block headers as they appear and fetch other parts of the blockchain on-demand.
* [BlockDaemon: Ethereum Altair Hard Folk: Light Clients & Sync Committees](https://blockdaemon.com/blog/ethereum-altair-hard-folk-light-clients-sync-committees/)
* [Efficient algorithms for CBC Casper](https://docs.google.com/presentation/d/1oc_zdywOsHxz3zez1ILAgrerS7RkaF1hHoW0FLtp0Gw/edit#slide=id.p): Review of LMD GHOST (Latest Message Driven, Greediest Heaviest Observed Sub-Tree)
* [SSZ: Simple Serialize](https://ethereum.org/en/developers/docs/data-structures-and-encoding/ssz/): Overview of Simple serialize (SSZ) is the serialization method used on the Beacon Chain. (including merkalization and multiproofs)
* [The Noise Protocol Framework](https://noiseprotocol.org/noise.html): Noise is a framework for crypto protocols based on Diffie-Hellman key agreement.
* [Flashbots for Ethereum Consensus Clients](https://hackmd.io/QoLwVQf3QK6EiVt15YOYqQ?view)
* [Optimistic Sync Specification](https://github.com/ethereum/consensus-specs/blob/dev/sync/optimistic.mdx): Optimistic Sync is a stop-gap measure to allow execution nodes to sync via established methods until future Ethereum roadmap items are implemented (e.g., statelessness).
* [Consensus Light Client Server Implementation Notes](https://hackmd.io/hsCz1G3BTyiwwJtjT4pe2Q?view): How Lodestar beacon node was tweaked to serve light clients
* [beacon chain light client design doc](https://notes.ethereum.org/@ralexstokes/HJxDMi8vY): notes about the design/implementation of a beacon chain light client using standard APIs and protocol features
* [A Beacon Chain Light Client Proposal](https://ethresear.ch/t/a-beacon-chain-light-client-proposal/11064): proposing a light client implementation that goes a step further than the minimum light client described in the altair consensus-spec. The proposed client aims to allow queries into the beacon state.
* [Distributed Hash Table (DHT) Overview](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/beacon-state-network.md#dht-overview): allows network participants to have retrieve data on-demand based on a content key.
* [(WIP) Light client p2p interface Specification](https://github.com/ethereum/consensus-specs/pull/2786): a PR to get the conversation going about a p2p approach.
  Here we cover two approaches which may be combined

### References

**References Overview**

<a name="ov1">\[1]</a> [Part I: What to build next in Zero
Knowledge?](https://delendum.xyz/2022/11/22/what-to-build-next-in-zero-knowledge.html):
What are the problems that haven’t been solved in blockchain and how can we
leverage zero-knowledge proof as a tool to solve these problems?

<a name="ov1">\[2]</a> [Crosschain
Future](https://github.com/isolab-gg/isomorph/blob/main/docs/blog/crosschain-future.mdx):
A review of the growing blockchain ecosystem and the role of zkp in building
trustless bridges.

<a name="ov2">\[3]</a> [Technical Problems
Overview](https://github.com/isolab-gg/isomorph/blob/main/docs/problems/technical-problems-part-1.mdx):
Trustless Bridging Technical Problems - PART 1: Problem Overview, Consensus
Protocols, Signature Schemes.

**Reference Trustless Bridge Design**

<a name="tb1">\[1]</a> [Succinct: Proof of Consensus Bridging between Ethereum
and Gnosis Chain](https://blog.succinct.xyz/blog/proof-of-consensus/): gas
efficient on-chain light client for Ethereum PoS, powered by succinct
zero-knowledge proofs (zkSNARKs), allowing for arbitrary, trust-minimized
cross-chain communication between Ethereum and Gnosis Chain.

**References Block Production**

<a name="bp1">\[1]</a> [EIP-3675: Upgrade consensus to
Proof-of-Stake](https://eips.ethereum.org/EIPS/eip-3675#pow-block-processing):
Specification of the consensus mechanism upgrade on Ethereum Mainnet that
introduces Proof-of-Stake.

<a name="bp2">\[2]</a> [EIP-2982: Serenity Phase
0](https://eips.ethereum.org/EIPS/eip-2982): Phase 0 of the release schedule of
Serenity, a series of updates to Ethereum a scalable, proof-of-stake consensus.

<a name="bp3">\[3]</a> [Ethreum Consensus Specs Phase
0](https://github.com/ethereum/consensus-specs/tree/dev/specs/phase0):
Specifications for Ethereum 2.0 Phase 0 including
[beacon-chain](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.mdx),
[deposit-contract](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/deposit-contract.mdx),
[fork-choice](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/fork-choice.mdx),
[p2p-interface](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/p2p-interface.mdx),
[validator](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/validator.mdx)
and
[weak-subjectivity](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/weak-subjectivity.mdx)

<a name="bp4">\[6]</a> [Ethereum Consensus and Execution Client
Distribution](https://clientdiversity.org/#distribution): Percentages of nodes
running client types for both Consensus (Prysm, Lighthours, Nimbus, Teku) and
Execution (Geth, Erigon, Besu, Nethermind) clients.

<a name="bp5">\[5]</a> [go-ethereum go
documentation](https://pkg.go.dev/github.com/ethereum/go-ethereum@v1.10.26):
Documentation for Go Ethereum, Official Golang implementation of the Ethereum
protocol. Which is an execution chain implementation.

<a name="bp6">\[6]</a> [prysm go
documentation](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2):
Documentation for prysm, An Ethereum Consensus Implementation Written in Go. A
beacon-chain immplementation. Also see [Prysm
Documentation](https://docs.prylabs.network/docs/getting-started)

<a name="bp7">\[7]</a> [lighthouse
documentation](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2):
Documentation for lighthouse, written in Rust. A beacon-chain immplementation.

<a name="bp8">\[8]</a> [Etherum 2.0 Validators
Overview](https://beaconcha.in/validators): Live Monitoring of Ethreum 2.0
Validators from beachoncha.in

**References Technical Summary**

<a name="ts1">\[1]</a> [Ethereum EVM
illustrated](https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf):
A technical overview of Ethereum including state, accounts, transactions and
messages as well as the EVM. [Appendix E](#appendix-e-data-structures) has links
to type definitions for blocks, transactions, state etc in geth.

<a name="ts2">\[2]</a> [Blocks](https://ethereum.org/en/developers/docs/blocks/):
Block data definitions including attestations from ethereum.org

<a name="ts3">\[3]</a> [eth1 block
proposal](https://hackmd.io/@flashbots/mev-in-eth2#eth1-block-proposal):
Technical walkthrough of how blocks are proposed and potential MEV opportunities
from FlashBots.

<a name="ts4">\[4]</a> [Assemble
Block](https://github.com/ethereum/rayonism/blob/master/specs/merge.md#assemble-block):
Ethereum Specification for block Assembly as part of Rayonism -- The Merge spec.

<a name="ts5">\[5]</a> [Prysm running a
node](https://docs.prylabs.network/docs/install/install-with-script):
Operational procedures for Validators by Prysm. Note validators run both the
beacon chain(consensus) and a geth node(execution)

<a name="ts6">\[6]</a>[The Beacon Chain Ethereum 2.0 explainer you need to read
first](https://ethos.dev/beacon-chain): Detailed walk through og Ethereum 2.0
block production including slots, epochs, validators, commitees and finality.

<a name="ts6b">\[6]</a>[The Beacon Chain Ethereum 2.0 explainer you need to read
first](https://ethos.dev/beacon-chain): Detailed walk through og Ethereum 2.0
block production including slots, epochs, validators, commitees and finality.

<a name="ts7">\[7]</a> [Etherum 2.0 Validators
Overview](https://beaconcha.in/validators): Live Monitoring of Ethreum 2.0
Validators from beachoncha.in

<a name="ts8">\[8]</a>[BLS
Signatures](https://eth2book.info/bellatrix/part2/building_blocks/signatures/):
Detailed walkthrough of BLS Signatures and how they can be used in aggregation.

<a name="ts9">\[8]</a>[Attestation Inclusion
Lifecycle](https://kb.beaconcha.in/attestation#attestation-inclusion-lifecycle):
High Level overview of the attestation life cycle including geeration,
propogation, aggregation and inclusion.Attest

<a name="ts10">\[ts10]</a> [Beacon Chain Proposal: Sync
Comittees](https://notes.ethereum.org/@vbuterin/HF1_proposal#Sync-committees):
For each period (\~27 hours), 1024 validators are randomly selected to be part of
the sync committee during that period. Validators in the sync committee would
publish signatures attesting to the current head. These signatures would be
broadcasted as part of a LightClientUpdate object that could help light clients
find the head, and would be included in the beacon chain to be rewarded.

<a name="ts11">\[ts11]</a> [Altair Light Client -- Sync
Protocol](https://notes.ethereum.org/@vbuterin/HF1_proposal#Sync-committees):
This document suggests a minimal light client design for the beacon chain that
uses sync committees.

<a name="ts12">\[ts12]</a> [Ethereum Builder Specifications: Honest
Validator](https://github.com/ethereum/builder-specs/blob/main/specs/validator.mdx):
explains the way in which a beacon chain validator is expected to use the
Builder spec to participate in an external builder network.

<a name="ts13">\[ts13]</a> [Flashbots:
mev-boost](https://github.com/flashbots/mev-boost): open source middleware run
by validators to access a competitive block-building market.

<a name="ts14">\[ts14]</a> [A note on Ethereum 2.0 phase 0 validator
lifecycle](https://notes.ethereum.org/7CFxjwMgQSWOHIxLgJP2Bw#A-note-on-Ethereum-20-phase-0-validator-lifecycle):
describes the concept of validator status epochs and the cases of validator
lifecycle in the view of “validator status transition” in phase 0.

### Appendices

#### Appendix A: Signing Libraries

#### Appendix B: Proving and Verification Mechanisms

##### [eth-proof-of-consensus](https://github.com/succinctlabs/eth-proof-of-consensus): Proof of Consensus for Ethereum by succinctlabs

Circuits

* [aggregate\_bls\_verify.circom](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/circuits/circuits/aggregate_bls_verify.circom): Computes an aggregate BLS12-381 public key over a set of public keys and a bitmask
* [assert\_valid\_signed\_header.circom](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/circuits/circuits/assert_valid_signed_header.circom)
* [pubkey\_poseidon.circom](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/circuits/circuits/pubkey_poseidon.circom): Computes the Poseidon merkle root of a list of field elements
* [sha256\_bytes.circom](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/circuits/circuits/sha256_bytes.circom): Wrapper around SHA256 to support bytes as input instead of bits
* [simple\_serialize.circom](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/circuits/circuits/simple_serialize.circom): Helper function to implement SSZArray
* [sync\_committee\_committments.circom](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/circuits/circuits/sync_committee_committments.circom): Asserts that the byte representation of a BLS12-381 public key's x-coordinate matches the BigInt representation

Verification

* [AMB](https://github.com/succinctlabs/eth-proof-of-consensus/tree/main/contracts/src/amb): Arbitrary Message Passing
* [TrustlessAMB.sol](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/amb/TrustlessAMB.sol): sends and executes messages
* [TrustlessAMBStorage.sol](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/amb/TrustlessAMBStorage.sol): Storage for messages between two chains
* [bridge](https://github.com/succinctlabs/eth-proof-of-consensus/tree/main/contracts/src/bridge): Allows for the deposit and withdrawal of ERC20 tokens
* [Bridge.sol](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/bridge/Bridge.sol): Deposit and withdraw functionality
* [Token.sol](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/bridge/Tokens.sol): ERC20 bridge token definitions
* [lightclient](https://github.com/succinctlabs/eth-proof-of-consensus/tree/main/contracts/src/lightclient)
* [BLSAggregatedSignatureVerifier.sol](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BLSAggregatedSignatureVerifier.sol): Verifies BLS aggregated signature proofs
* [BeaconLightClient.sol](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BeaconLightClient.sol): Beacon Light Client Functionality including
  * [step(LightClientUpdate memory update)](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BeaconLightClient.sol#L86): Updates the head given a finalized light client update.
  * [function updateSyncCommittee(LightClientUpdate memory update, bytes32 nextSyncCommitteePoseidon, Groth16Proof memory commitmentMappingProof)](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BeaconLightClient.sol#L102): Set the sync committee validator set root for the next sync commitee period.
  * [function forceUpdate()](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BeaconLightClient.sol#L131): Finalizes the optimistic update and sets the next sync committee if no finalized updates have been received for a period.
  * [function processLightClientUpdate(LightClientUpdate memory update)](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BeaconLightClient.sol#L131): Implements shared logic for processing light client updates.
  * [function zkMapSSZToPoseidon(bytes32 sszCommitment, bytes32 poseidonCommitment, Groth16Proof memory proof)](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BeaconLightClient.sol#L190): Maps a simple serialize merkle root to a poseidon merkle root with a zkSNARK. The proof asserts that: SimpleSerialize(syncCommittee) == Poseidon(syncCommittee).
  * [function zkBLSVerify(bytes32 signingRoot, bytes32 syncCommitteeRoot, uint256 claimedParticipation, Groth16Proof memory proof)](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BeaconLightClient.sol#L208): Does an aggregated BLS signature verification with a zkSNARK.
* [scripts](https://github.com/succinctlabs/eth-proof-of-consensus/tree/main/contracts/src/scripts): A collection of [forge-scripts](https://book.getfoundry.sh/reference/forge/forge-script) for contract deployment.

#### Appendix C: Topics

Beacon Chain Topics [Prysm](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/p2p/topics.go)

package p2p

const (
// GossipProtocolAndDigest represents the protocol and fork digest prefix in a gossip topic.
GossipProtocolAndDigest = "/eth2/%x/"

// Message Types
//
// GossipAttestationMessage is the name for the attestation message type. It is
// specially extracted so as to determine the correct message type from an attestation
// subnet.
GossipAttestationMessage = "beacon\_attestation"
// GossipSyncCommitteeMessage is the name for the sync committee message type. It is
// specially extracted so as to determine the correct message type from a sync committee
// subnet.
GossipSyncCommitteeMessage = "sync\_committee"
// GossipBlockMessage is the name for the block message type.
GossipBlockMessage = "beacon\_block"
// GossipExitMessage is the name for the voluntary exit message type.
GossipExitMessage = "voluntary\_exit"
// GossipProposerSlashingMessage is the name for the proposer slashing message type.
GossipProposerSlashingMessage = "proposer\_slashing"
// GossipAttesterSlashingMessage is the name for the attester slashing message type.
GossipAttesterSlashingMessage = "attester\_slashing"
// GossipAggregateAndProofMessage is the name for the attestation aggregate and proof message type.
GossipAggregateAndProofMessage = "beacon\_aggregate\_and\_proof"
// GossipContributionAndProofMessage is the name for the sync contribution and proof message type.
GossipContributionAndProofMessage = "sync\_committee\_contribution\_and\_proof"
// GossipBlsToExecutionChangeMessage is the name for the bls to execution change message type.
GossipBlsToExecutionChangeMessage = "bls\_to\_execution\_change"

// Topic Formats
//
// AttestationSubnetTopicFormat is the topic format for the attestation subnet.
AttestationSubnetTopicFormat = GossipProtocolAndDigest + GossipAttestationMessage + "*%d"
// SyncCommitteeSubnetTopicFormat is the topic format for the sync committee subnet.
SyncCommitteeSubnetTopicFormat = GossipProtocolAndDigest + GossipSyncCommitteeMessage + "*%d"
// BlockSubnetTopicFormat is the topic format for the block subnet.
BlockSubnetTopicFormat = GossipProtocolAndDigest + GossipBlockMessage
// ExitSubnetTopicFormat is the topic format for the voluntary exit subnet.
ExitSubnetTopicFormat = GossipProtocolAndDigest + GossipExitMessage
// ProposerSlashingSubnetTopicFormat is the topic format for the proposer slashing subnet.
ProposerSlashingSubnetTopicFormat = GossipProtocolAndDigest + GossipProposerSlashingMessage
// AttesterSlashingSubnetTopicFormat is the topic format for the attester slashing subnet.
AttesterSlashingSubnetTopicFormat = GossipProtocolAndDigest + GossipAttesterSlashingMessage
// AggregateAndProofSubnetTopicFormat is the topic format for the aggregate and proof subnet.
AggregateAndProofSubnetTopicFormat = GossipProtocolAndDigest + GossipAggregateAndProofMessage
// SyncContributionAndProofSubnetTopicFormat is the topic format for the sync aggregate and proof subnet.
SyncContributionAndProofSubnetTopicFormat = GossipProtocolAndDigest + GossipContributionAndProofMessage
// BlsToExecutionChangeSubnetTopicFormat is the topic format for the bls to execution change subnet.
BlsToExecutionChangeSubnetTopicFormat = GossipProtocolAndDigest + GossipBlsToExecutionChangeMessage
)

#### Appendix D: gRPC and API's

[Beaconcha.in ETH2 API](https://beaconcha.in/api/v1/docs/index.html)

#### Appendix E: Data Structures

* Block Structure from [go-ethereum](https://github.com/ethereum/go-ethereum/blob/release/1.9/consensus/ethash/consensus.go)

```

// SealHash returns the hash of a block prior to it being sealed.
func (ethash *Ethash) SealHash(header *types.Header) (hash common.Hash) {
hasher := sha3.NewLegacyKeccak256()

rlp.Encode(hasher, []interface{}{
header.ParentHash,
header.UncleHash,
header.Coinbase,
header.Root,
header.TxHash,
header.ReceiptHash,
header.Bloom,
header.Difficulty,
header.Number,
header.GasLimit,
header.GasUsed,
header.Time,
header.Extra,
})
hasher.Sum(hash[:0])
return hash
}

```

* Blocks Headers get forwarded to the Beacon chain once they pass [beacon consensus](https://github.com/ethereum/go-ethereum/blob/master/consensus/beacon/consensus.go)
* The Beacon chain embeds the EthChain Header into a [BeaconBlock](https://github.com/prysmaticlabs/prysm/blob/develop/consensus-types/blocks/types.go#L43)

BeaconBlockBody from [prysm](https://github.com/prysmaticlabs/prysm/blob/develop/consensus-types/blocks/types.go) (golang)

```

// BeaconBlockBody is the main beacon block body structure. It can represent any block type.
type BeaconBlockBody struct {
version int
isBlinded bool
randaoReveal [field_params.BLSSignatureLength]byte
eth1Data *eth.Eth1Data
graffiti [field_params.RootLength]byte
proposerSlashings []*eth.ProposerSlashing
attesterSlashings []*eth.AttesterSlashing
attestations []*eth.Attestation
deposits []*eth.Deposit
voluntaryExits []*eth.SignedVoluntaryExit
syncAggregate *eth.SyncAggregate
executionPayload *engine.ExecutionPayload
executionPayloadHeader \*engine.ExecutionPayloadHeader
}

// BeaconBlock is the main beacon block structure. It can represent any block type.
type BeaconBlock struct {
version int
slot types.Slot
proposerIndex types.ValidatorIndex
parentRoot [field_params.RootLength]byte
stateRoot [field_params.RootLength]byte
body \*BeaconBlockBody
}

// SignedBeaconBlock is the main signed beacon block structure. It can represent any block type.
type SignedBeaconBlock struct {
version int
block \*BeaconBlock
signature [field_params.BLSSignatureLength]byte
}

```

Eth1Data from [prysm](https://github.com/prysmaticlabs/prysm/blob/develop/proto/prysm/v1alpha1/powchain.pb.go#L24) (golang)

```

type ETH1ChainData struct {
state protoimpl.MessageState
sizeCache protoimpl.SizeCache
unknownFields protoimpl.UnknownFields

CurrentEth1Data *LatestETH1Data `protobuf:"bytes,1,opt,name=current_eth1_data,json=currentEth1Data,proto3" json:"current_eth1_data,omitempty"`
ChainstartData *ChainStartData `protobuf:"bytes,2,opt,name=chainstart_data,json=chainstartData,proto3" json:"chainstart_data,omitempty"`
BeaconState *BeaconState `protobuf:"bytes,3,opt,name=beacon_state,json=beaconState,proto3" json:"beacon_state,omitempty"`
Trie *SparseMerkleTrie `protobuf:"bytes,4,opt,name=trie,proto3" json:"trie,omitempty"`
DepositContainers []\*DepositContainer `protobuf:"bytes,5,rep,name=deposit_containers,json=depositContainers,proto3" json:"deposit_containers,omitempty"`
}

type LatestETH1Data struct {
state protoimpl.MessageState
sizeCache protoimpl.SizeCache
unknownFields protoimpl.UnknownFields

BlockHeight uint64 `protobuf:"varint,2,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
BlockTime uint64 `protobuf:"varint,3,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
BlockHash []byte `protobuf:"bytes,4,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
LastRequestedBlock uint64 `protobuf:"varint,5,opt,name=last_requested_block,json=lastRequestedBlock,proto3" json:"last_requested_block,omitempty"`
}

```

BeaconBlockAltair from [lighthouse](https://github.com/sigp/lighthouse/blob/stable/consensus/types/src/beacon_block.rs#L407) rust

```

    /// Return an Altair block where the block has maximum size.
    pub fn full(spec: &ChainSpec) -> Self {
        let base_block: BeaconBlockBase<_, Payload> = BeaconBlockBase::full(spec);
        let sync_aggregate = SyncAggregate {
            sync_committee_signature: AggregateSignature::empty(),
            sync_committee_bits: BitVector::default(),
        };
        BeaconBlockAltair {
            slot: spec.genesis_slot,
            proposer_index: 0,
            parent_root: Hash256::zero(),
            state_root: Hash256::zero(),
            body: BeaconBlockBodyAltair {
                proposer_slashings: base_block.body.proposer_slashings,
                attester_slashings: base_block.body.attester_slashings,
                attestations: base_block.body.attestations,
                deposits: base_block.body.deposits,
                voluntary_exits: base_block.body.voluntary_exits,
                sync_aggregate,
                randao_reveal: Signature::empty(),
                eth1_data: Eth1Data {
                    deposit_root: Hash256::zero(),
                    block_hash: Hash256::zero(),
                    deposit_count: 0,
                },
                graffiti: Graffiti::default(),
                _phantom: PhantomData,
            },
        }
    }

}

```

##### Beacon State Data Structures from Prysm

```

type BeaconState interface {
SpecParametersProvider
ReadOnlyBeaconState
WriteOnlyBeaconState
Copy() BeaconState
HashTreeRoot(ctx context.Context) ([32]byte, error)
FutureForkStub
StateProver
}

```

```

type ReadOnlyBeaconState interface {
ReadOnlyBlockRoots
ReadOnlyStateRoots
ReadOnlyRandaoMixes
ReadOnlyEth1Data
ReadOnlyValidators
ReadOnlyBalances
ReadOnlyCheckpoint
ReadOnlyAttestations
ToProtoUnsafe() interface{}
ToProto() interface{}
GenesisTime() uint64
GenesisValidatorsRoot() []byte
Slot() types.Slot
Fork() *ethpb.Fork
LatestBlockHeader() *ethpb.BeaconBlockHeader
HistoricalRoots() [][]byte
Slashings() []uint64
FieldReferencesCount() map[string]uint64
MarshalSSZ() ([]byte, error)
IsNil() bool
Version() int
LatestExecutionPayloadHeader() (interfaces.ExecutionData, error)
}

```

```

type ReadOnlyValidators interface {
Validators() []*ethpb.Validator
ValidatorAtIndex(idx types.ValidatorIndex) (*ethpb.Validator, error)
ValidatorAtIndexReadOnly(idx types.ValidatorIndex) (ReadOnlyValidator, error)
ValidatorIndexByPubkey(key [fieldparams.BLSPubkeyLength]byte) (types.ValidatorIndex, bool)
PubkeyAtIndex(idx types.ValidatorIndex) [fieldparams.BLSPubkeyLength]byte
NumValidators() int
ReadFromEveryValidator(f func(idx int, val ReadOnlyValidator) error) error
}

```

```

type ReadOnlyRandaoMixes interface {
RandaoMixes() [][]byte
RandaoMixAtIndex(idx uint64) ([]byte, error)
RandaoMixesLength() int
}

```

```

type WriteOnlyBeaconState interface {
WriteOnlyBlockRoots
WriteOnlyStateRoots
WriteOnlyRandaoMixes
WriteOnlyEth1Data
WriteOnlyValidators
WriteOnlyBalances
WriteOnlyCheckpoint
WriteOnlyAttestations
SetGenesisTime(val uint64) error
SetGenesisValidatorsRoot(val []byte) error
SetSlot(val types.Slot) error
SetFork(val *ethpb.Fork) error
SetLatestBlockHeader(val *ethpb.BeaconBlockHeader) error
SetHistoricalRoots(val [][]byte) error
SetSlashings(val []uint64) error
UpdateSlashingsAtIndex(idx, val uint64) error
AppendHistoricalRoots(root [32]byte) error
SetLatestExecutionPayloadHeader(payload interfaces.ExecutionData) error
SetWithdrawalQueue(val []*enginev1.Withdrawal) error
AppendWithdrawal(val *enginev1.Withdrawal) error
SetNextWithdrawalIndex(i uint64) error
SetNextPartialWithdrawalValidatorIndex(i types.ValidatorIndex) error
}

```

```

type WriteOnlyValidators interface {
SetValidators(val []*ethpb.Validator) error
ApplyToEveryValidator(f func(idx int, val *ethpb.Validator) (bool, *ethpb.Validator, error)) error
UpdateValidatorAtIndex(idx types.ValidatorIndex, val *ethpb.Validator) error
AppendValidator(val \*ethpb.Validator) error
}

```

```

type WriteOnlyRandaoMixes interface {
SetRandaoMixes(val [][]byte) error
UpdateRandaoMixesAtIndex(idx uint64, val []byte) error
}

```

[Validator](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/proto/prysm/v1alpha1#Validator) information

```

type Validator struct {
PublicKey []byte `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty" spec-name:"pubkey" ssz-size:"48"`
WithdrawalCredentials []byte ``/* 138-byte string literal not displayed */
 EffectiveBalance           uint64                                                             `protobuf:"varint,3,opt,name=effective_balance,json=effectiveBalance,proto3" json:"effective_balance,omitempty"`
 Slashed                    bool                                                               `protobuf:"varint,4,opt,name=slashed,proto3" json:"slashed,omitempty"`
 ActivationEligibilityEpoch github_com_prysmaticlabs_prysm_v3_consensus_types_primitives.Epoch`` /_ 221-byte string literal not displayed _/
ActivationEpoch github*com_prysmaticlabs_prysm_v3_consensus_types_primitives.Epoch `/* 186-byte string literal not displayed _/
ExitEpoch github_com_prysmaticlabs_prysm_v3_consensus_types_primitives.Epoch` /_ 168-byte string literal not displayed _/
WithdrawableEpoch github_com_prysmaticlabs_prysm_v3_consensus_types_primitives.Epoch `` /_ 192-byte string literal not displayed \_/
// contains filtered or unexported fields
}

```

##### [web3signer\_types from prysm](https://github.com/prysmaticlabs/prysm/blob/develop/validator/keymanager/remote-web3signer/v1/web3signer_types.go#L107)

```

////////////////////////////////////////////////////////////////////////////////
// sub properties of Sign Requests /////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// ForkInfo a sub property object of the Sign request
type ForkInfo struct {
Fork \*Fork `json:"fork"`
GenesisValidatorsRoot hexutil.Bytes `json:"genesis_validators_root"`
}

// Fork a sub property of ForkInfo.
type Fork struct {
PreviousVersion hexutil.Bytes `json:"previous_version"`
CurrentVersion hexutil.Bytes `json:"current_version"`
Epoch string `json:"epoch"` /_uint64_/
}

// AggregationSlot a sub property of AggregationSlotSignRequest.
type AggregationSlot struct {
Slot string `json:"slot"`
}

// AggregateAndProof a sub property of AggregateAndProofSignRequest.
type AggregateAndProof struct {
AggregatorIndex string `json:"aggregator_index"` /_ uint64 _/
Aggregate _Attestation `json:"aggregate"`
SelectionProof hexutil.Bytes `json:"selection_proof"` /_ 96 bytes _/
}

// Attestation a sub property of AggregateAndProofSignRequest.
type Attestation struct {
AggregationBits hexutil.Bytes `json:"aggregation_bits"` /_hex bitlist_/
Data \*AttestationData `json:"data"`
Signature hexutil.Bytes `json:"signature"`
}

// AttestationData a sub property of Attestation.
type AttestationData struct {
Slot string `json:"slot"` /_ uint64 _/
Index string `json:"index"` /_ uint64 _/ // Prysm uses CommitteeIndex but web3signer uses index.
BeaconBlockRoot hexutil.Bytes `json:"beacon_block_root"`
Source *Checkpoint `json:"source"`
Target *Checkpoint `json:"target"`
}

// Checkpoint a sub property of AttestationData.
type Checkpoint struct {
Epoch string `json:"epoch"`
Root string `json:"root"`
}

```

[attestation.proto from prysm (Message Structure)](https://github.com/prysmaticlabs/prysm/blob/develop/proto/prysm/v1alpha1/attestation.proto)

```

message AttestationData {
// Attestation data includes information on Casper the Friendly Finality Gadget's votes
// See: https://arxiv.org/pdf/1710.09437.pdf

    // Slot of the attestation attesting for.
    uint64 slot = 1 [(ethereum.eth.ext.cast_type) = "github.com/prysmaticlabs/prysm/v3/consensus-types/primitives.Slot"];

    // The committee index that submitted this attestation.
    uint64 committee_index = 2  [(ethereum.eth.ext.cast_type) = "github.com/prysmaticlabs/prysm/v3/consensus-types/primitives.CommitteeIndex"];

    // 32 byte root of the LMD GHOST block vote.
    bytes beacon_block_root = 3 [(ethereum.eth.ext.ssz_size) = "32"];

    // The most recent justified checkpoint in the beacon state
    Checkpoint source = 4;

    // The checkpoint attempting to be justified for the current epoch and its epoch boundary block
    Checkpoint target = 5;

}

```

#### Appendix F: Sample Data

##### Epoch Data for 167040

Following is the Epoch Data for 167040
It can be retrieved from [here](https://beaconcha.in/api/v1/docs/index.html#/Epoch/get_api_v1_epoch__epoch_) or by using this curl command

`curl -X 'GET' \
  'https://beaconcha.in/api/v1/epoch/167040' \
  -H 'accept: application/json'`

Response

```

{
"status": "OK",
"data": {
"attestationscount": 3457,
"attesterslashingscount": 0,
"averagevalidatorbalance": 33899775551,
"blockscount": 32,
"depositscount": 0,
"eligibleether": 15596542000000000,
"epoch": 167040,
"finalized": true,
"globalparticipationrate": 0.9963188171386719,
"missedblocks": 0,
"orphanedblocks": 0,
"proposedblocks": 32,
"proposerslashingscount": 0,
"scheduledblocks": 0,
"totalvalidatorbalance": 16522615004645864,
"validatorscount": 487396,
"voluntaryexitscount": 0,
"votedether": 15539128000000000
}
}

```

##### Block Data for Slot 5,330,592

Following is the Block Data for Slot 5,330,592
It can be retrieved from [here](https://beaconcha.in/api/v1/docs/index.html#/Block/get_api_v1_block__slotOrHash_) or by using this curl command

`curl -X 'GET' 'https://beaconcha.in/api/v1/block/5330592' -H 'accept: application/json'`

Response

```

{
"status": "OK",
"data": {
"attestationscount": 126,
"attesterslashingscount": 0,
"blockroot": "0xaebe891086c79ab79b325f474dc1150f1223e567337bff815cc318f14c64c233",
"depositscount": 0,
"epoch": 166581,
"eth1data_blockhash": "0xd346f84ffe7c600b7714d6411c8bea988d9d64dbdb432f26db58e72946337954",
"eth1data_depositcount": 498785,
"eth1data_depositroot": "0x9a5603a34aa60f299384679bf4bfc267e99b68278a81f343bde8cb5650bf1d60",
"exec_base_fee_per_gas": 12376913565,
"exec_block_hash": "0x26239efe09f51b24bdf7c518b1aa925a3b0b6453682408ec8a5c906d5038a6e7",
"exec_block_number": 16163905,
"exec_extra_data": "0x496c6c756d696e61746520446d6f63726174697a6520447374726962757465",
"exec_fee_recipient": "0xdafea492d9c6733ae3d56b7ed1adb60692c98bc5",
"exec_gas_limit": 30000000,
"exec_gas_used": 9901267,
"exec_logs_bloom": "0x8c21554815843b4084a999b2901917a52c58004a82a8440d94919a77f9241181388a0c404f000a8c0321ab024800bf899610e60ec801fb4b0352e34f147626192648619065381ded6b9d92bcd0861120adc1ec01064e7a016ea91c478d01b81316462d2d622a60010bc0139f6fb8ccf200499c0e211a85c042047d1601aa0c2ea2833902a2a3091528492dad09f6dc064529c455d328413b78c680c4699815ac9a91610f19e66542edca45a10518ee65b02cf02241a124232d5958b6004cd0a5846c5703d00b5e4d8353221015f7d38c1429074e34aaa11f3804f933082860c401152088251479918297a1a9237d9ac35539f6d069cca07a005819494a653913",
"exec_parent_hash": "0x06746d5ff105e96a1b8961c2490c0261b474604fbcbf934e86295c0030e26ce2",
"exec_random": "0xc2861c72cf4d34b37ec73519dbc20b690742b5cc119ed3738f1dd67d8ca52723",
"exec_receipts_root": "0x33cdf5c6e03dd341f282d02d3c354c2361a6212692b2a3c06b520397045313f4",
"exec_state_root": "0x517304bade8d83337c9a52f8ceeb13f924b64486b3b8033f7c348c176922104a",
"exec_timestamp": 1670791127,
"exec_transactions_count": 139,
"graffiti": "0x0000000000000000000000000000000000000000000000000000000000000000",
"graffiti_text": "",
"parentroot": "0x0cab36616bbcbbc67c343ddce00241c27d0df2c367c5fa82fc7c0fdf0ed37405",
"proposer": 4345,
"proposerslashingscount": 0,
"randaoreveal": "0x83950cb64781aff91f4bd14aa6abb0f5fdb7e08e4e81c264f0754c93d7672c4a9615de196491fdb53eafdeb8f49e9cf515f1bd3dc05bb5dc0e2dd8bff5a8d783b503e3385e80b61485f0ddac1caa9361132a863db84e7e234df5815e6908e4e7",
"signature": "0x84865a9480ae6313b0e5fcadfa294b35f5963e06c66ad1c7613dc081e9700c07f82a2583ba4b62b2483b4a1b9d49aafe0690f22fcf4d0072f9f44a5ce3067ef4fda560d171001cc6bf5dc84e09d9055d92894b86b27695c297f25530cd8db7a0",
"slot": 5330592,
"stateroot": "0x9e7e40d844c3b229cd9497d662a6d94276d285945073849995aba93c7e73cfe7",
"status": "1",
"syncaggregate_bits": "0xdffffffffffffffffffffffffffffff7fffffffffffffffffffffffffffffffffffffffffffffffffffffffdfffffffffffffffdffffffffffffffffffffffff",
"syncaggregate_participation": 0.9921875,
"syncaggregate_signature": "0x95332c55790018eed3d17eada01cb4045348d09137505bc8697eeedaa3800a830ee2c138251850a9577f62a5488419ef0a722579156a177fb3a147017f1077af5d778f46a4cdf815fc450129d135fe5286e16df68333592e4aa45821bde780dd",
"voluntaryexitscount": 0,
"votes": 19227
}
}

```

##### Execution Block for 16163905

Following is the execution block data for 16163905
It can be retrieved from [here](https://beaconcha.in/api/v1/docs/index.html#/Execution/get_api_v1_execution_block__blockNumber_) or by using this curl command

`curl -X 'GET' 'https://beaconcha.in/api/v1/execution/block/16163905'  -H 'accept: application/json'`

Result

```

{
"status": "OK",
"data": [
{
"blockHash": "0x26239efe09f51b24bdf7c518b1aa925a3b0b6453682408ec8a5c906d5038a6e7",
"blockNumber": 16163905,
"timestamp": 1670791127,
"blockReward": 37343826945103810,
"blockMevReward": 37083911760238810,
"producerReward": 37083911760238810,
"feeRecipient": "0xdafea492d9c6733ae3d56b7ed1adb60692c98bc5",
"gasLimit": 30000000,
"gasUsed": 9901267,
"baseFee": 12376913565,
"txCount": 139,
"internalTxCount": 54,
"uncleCount": 0,
"parentHash": "0x06746d5ff105e96a1b8961c2490c0261b474604fbcbf934e86295c0030e26ce2",
"uncleHash": "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347",
"difficulty": 0,
"posConsensus": {
"executionBlockNumber": 16163905,
"proposerIndex": 4345,
"slot": 5330592,
"epoch": 166581,
"finalized": true
},
"relay": {
"tag": "flashbots-relay",
"builderPubkey": "0x81beef03aafd3dd33ffd7deb337407142c80fea2690e5b3190cfc01bde5753f28982a7857c96172a75a234cb7bcb994f",
"producerFeeRecipient": "0x60987e0d8b5e0095869ca6f0e642828e3f258bb5"
},
"consensusAlgorithm": "pos"
}
]
}

```

##### Sync Committee (latest)

Following is a sample Sync Committee
It can be retrieved from [here](https://beaconcha.in/api/v1/docs/index.html#/SyncCommittee/get_api_v1_sync_committee__period_) or by using this curl command

`curl -X 'GET' 'https://beaconcha.in/api/v1/sync_committee/latest' -H 'accept: application/json'`

Abbrieviated Result

```

{
"status": "OK",
"data": {
"end_epoch": 167167,
"period": 652,
"start_epoch": 166912,
"validators": [
328781,
184949,
...
]
}
}

```

<details>
  <summary>Full Result</summary>

  ```

  {
  "status": "OK",
  "data": {
  "end_epoch": 167167,
  "period": 652,
  "start_epoch": 166912,
  "validators": [
  328781,
  184949,
  269719,
  484753,
  447707,
  190522,
  222987,
  429436,
  23553,
  353182,
  394935,
  347121,
  3941,
  77287,
  390407,
  41282,
  440380,
  477794,
  13208,
  321552,
  338223,
  414921,
  77542,
  57797,
  471002,
  238719,
  87491,
  85099,
  16484,
  220174,
  256680,
  194973,
  77409,
  150279,
  322042,
  275140,
  393620,
  21206,
  59424,
  308071,
  20736,
  173428,
  365316,
  293687,
  136783,
  459882,
  9048,
  128613,
  132177,
  267018,
  290896,
  236936,
  406218,
  380040,
  481667,
  34410,
  413701,
  158755,
  222721,
  295335,
  106306,
  426104,
  229412,
  377442,
  300381,
  251157,
  2301,
  255801,
  160943,
  417370,
  290905,
  435535,
  164094,
  204304,
  258455,
  366943,
  119808,
  311117,
  79552,
  164660,
  446993,
  347592,
  256827,
  244517,
  277343,
  303208,
  425967,
  216346,
  13359,
  481813,
  142254,
  105339,
  465226,
  200109,
  198691,
  43343,
  32947,
  392889,
  304855,
  452188,
  148690,
  441869,
  15210,
  216221,
  33338,
  124091,
  299153,
  305746,
  230810,
  484937,
  464816,
  474017,
  307185,
  370171,
  430926,
  21371,
  7607,
  209940,
  439052,
  398079,
  238559,
  108372,
  127122,
  62084,
  5906,
  278678,
  404838,
  253340,
  146867,
  437165,
  470827,
  252487,
  430474,
  433777,
  282060,
  221522,
  273826,
  56274,
  359184,
  401626,
  43613,
  287311,
  465536,
  301609,
  21832,
  192551,
  412598,
  186526,
  447005,
  112768,
  404399,
  289582,
  290124,
  191275,
  213003,
  39276,
  200971,
  315798,
  135302,
  121320,
  227480,
  156978,
  98919,
  201671,
  195988,
  186622,
  475967,
  314720,
  58582,
  404742,
  215008,
  306959,
  267381,
  126574,
  73725,
  156317,
  83010,
  375189,
  167000,
  459137,
  294856,
  144931,
  234176,
  371047,
  446790,
  219650,
  26577,
  64091,
  482916,
  203241,
  306809,
  178005,
  380280,
  452614,
  266272,
  264801,
  428464,
  342535,
  310436,
  297012,
  173959,
  384721,
  311372,
  375367,
  304633,
  247177,
  373217,
  43689,
  363227,
  447608,
  203474,
  186229,
  63975,
  189189,
  391682,
  197510,
  423160,
  168160,
  336488,
  11240,
  86706,
  316746,
  272065,
  50516,
  411785,
  25826,
  212663,
  233378,
  186547,
  268142,
  387972,
  275194,
  134600,
  337298,
  51510,
  206067,
  111837,
  461165,
  137209,
  317427,
  153989,
  464678,
  975,
  384374,
  433258,
  62611,
  413087,
  424810,
  449054,
  190150,
  310602,
  336220,
  71740,
  230657,
  453370,
  468144,
  322259,
  283775,
  1606,
  139348,
  352593,
  356482,
  156500,
  157489,
  454159,
  337203,
  63370,
  369541,
  170461,
  99771,
  398154,
  126177,
  281482,
  24217,
  234556,
  251792,
  201614,
  249765,
  130900,
  409074,
  46296,
  172953,
  194464,
  229313,
  120835,
  141417,
  187795,
  169516,
  352531,
  402467,
  433379,
  73331,
  345245,
  167093,
  176171,
  198482,
  486643,
  456439,
  449333,
  221367,
  481580,
  200704,
  197099,
  314035,
  336100,
  146714,
  415630,
  47127,
  287953,
  153548,
  438248,
  2664,
  325723,
  467719,
  408858,
  82963,
  180891,
  192679,
  86617,
  100068,
  2394,
  11764,
  48047,
  127406,
  149052,
  283994,
  342457,
  463547,
  320210,
  293252,
  6540,
  464926,
  265551,
  109109,
  164735,
  381110,
  29080,
  246178,
  355576,
  448267,
  430466,
  444401,
  126905,
  414347,
  451523,
  331926,
  366508,
  480803,
  387850,
  413867,
  17772,
  268744,
  427797,
  163955,
  333814,
  93663,
  338046,
  236013,
  180066,
  68685,
  466537,
  3904,
  277412,
  449845,
  16633,
  62120,
  108501,
  486885,
  60466,
  380719,
  269930,
  365432,
  377380,
  260009,
  300616,
  203897,
  289145,
  249814,
  26558,
  343110,
  48226,
  365643,
  401664,
  7355,
  350107,
  100836,
  99073,
  294093,
  7587,
  169932,
  166154,
  396054,
  108167,
  229069,
  307648,
  148531,
  233563,
  40093,
  44708,
  353913,
  456080,
  176129,
  156427,
  412072,
  154317,
  271015,
  126289,
  345876,
  156388,
  195860,
  25422,
  482057,
  362295,
  466187,
  115725,
  387438,
  170886,
  224753,
  126768,
  421612,
  96187,
  9314,
  194598,
  297360,
  121794,
  422582,
  428474,
  281996,
  211966,
  303980,
  232330,
  314475,
  485,
  146262,
  8780,
  459648,
  88780,
  371355,
  283376,
  480636,
  67695,
  153169,
  205011,
  52231,
  103646,
  432471,
  433747,
  16092,
  78487,
  165644,
  412660,
  451750,
  8088,
  185452,
  192135,
  355751,
  59734,
  341708,
  347491,
  466763,
  446951,
  670,
  392454,
  39840,
  469691,
  329363,
  61899,
  384770,
  317497,
  282776,
  211703,
  427937,
  284122,
  238949,
  417486,
  341081,
  241572,
  67225,
  294159,
  302865,
  227806,
  123006,
  329514,
  449279,
  31448,
  450144,
  485006,
  199737,
  253646,
  117814,
  408604,
  141399,
  121937,
  237632,
  315197,
  10397,
  318494,
  221051,
  444960,
  417643,
  90991,
  153828,
  291638,
  96654,
  280019,
  218632,
  74162,
  119769,
  20024,
  420771,
  219118,
  96325
  ]
  }
  }

  ```
</details>

#### Appendix G: Storing minimal information

##### Minimal footprint

##### Header Checkpoints

##### Inclusion Proof

##### ZKP for Checkpoints

##### Proving

##### Verification

#### Appendix H: Validating Header

##### Tracking Validators

##### ZKP for validator change

##### Verifying Signatures

##### ECDSA

##### RSA

##### EdDSA

##### Pure on-chain implementation and costs

###### ZKP for EdDSA

##### BLS12-381 and variants

###### Pure on-chain implementation and costs

###### ZKP for BLS12-381

#### Appendix I: Cost analysis and benchmark

#### Appendix J: Sync Committe Creation and Retrieval

**Sync Committee Configuration**

`EPOCHS_PER_SYNC_COMMITTEE_PERIOD` is set in [config.go](https://github.com/prysmaticlabs/prysm/blob/develop/config/params/config.go#L185) currently 255 epochs per synch comittee (approx 27 hrs) for Ethreum Mainnet.

**Sync Committee Update Process**

* [beacon-chain/blockchain](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/blockchain)
  * [process\_block.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/blockchain/process_block.go): has function `onBlock` which is called when a gossip block is received. It also has function `handleEpochBoundary` which calls `ProcessSlots` in [beacon-chain/core/transition](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/core/transition) and calls function `UpdateCommitteeCache` in [beacon-chain/core/helpers](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/core/helpers)
* [beacon-chain/core/transition](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/core/transition)
  * [transition.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/core/transition/transition.go): implements the whole state transition function which consists of per slot, per-epoch transitions. function `ProcessSlots` calls `ProcessEpoch` in [beacon-chain/core/altair/transition.go](\(%3Chttps://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/core/altair/transition.go\)%3E)
* [beacon-chain/core/altair](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/core/altair)
  * [transition.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/core/altair/transition.go): includes function `ProcessEpoch` which calls `ProcessSyncCommitteeUpdates` in [epoch\_spec.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/core/altair/epoch_spec.go)
  * [epoch\_spec.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/core/altair/epoch_spec.go): includes function `ProcessSyncCommitteeUpdates` which calls `NextSyncCommittee` it also persists beacon state syncCommittee by calling `beaconState.SetNextSyncCommittee(nextSyncCommittee)` in [setters\_sync\_committee.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/state/state-native/setters_sync_committee.go)
  * [sync\_committee.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/core/altair/sync_committee.go): includes function `NextSyncCommittee` which calls `NextSyncCommittee` to return the sync committee indices, with possible duplicates, for the next sync committee.
  * [block.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/core/altair/block.go): includes function `VerifySyncCommitteeSig`
* [beacon-chain/core/helpers](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/core/helpers)
  * [beacon\_committee.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/core/helpers/beacon_committee.go) has function `UpdateCommitteeCache` which gets called at the beginning of every epoch to cache the committee shuffled indices list with committee index and epoch number. It caches the shuffled indices for current epoch and next epoch. it calls `UpdatePositionsInCommittee` in [sync\_committee.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/cache/sync_committee.go)
* [beacon-chain/cache](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/cache)
  * [sync\_committee.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/cache/sync_committee.go): has function `UpdatePositionsInCommittee` which updates caching of validators position in sync committee in respect to current epoch and next epoch. This should be called when `current_sync_committee` and `next_sync_committee` change and that happens every `EPOCHS_PER_SYNC_COMMITTEE_PERIOD`.

**Sync Committee Retrieval**
gRPC and API methods

* [beacon-chain/rpc](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/rpc)
  * [prysm/v1alpha1](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/rpc/prysm/v1alpha1)
    * [validator](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/rpc/prysm/v1alpha1/validator)
      * [assignments.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/rpc/prysm/v1alpha1/validator/assignments.go): has functions `GetDuties` and `StreamDuties` which calls function `duties` to compute the validator duties from the head state's corresponding epoch for validators public key / indices requested.

which [manages sync committee duties](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/rpc/prysm/v1alpha1/validator/assignments.go#L213) every `EPOCHS_PER_SYNC_COMMITTEE_PERIOD - 1` which is set in [config.go](https://github.com/prysmaticlabs/prysm/blob/develop/config/params/config.go#L185) currently 255 epochs per synch comittee (approx 27 hrs) for Ethreum Mainnet.

[registerSyncSubnetNextPeriod](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/rpc/prysm/v1alpha1/validator/assignments.go#L281)

```

func registerSyncSubnetNextPeriod(s beaconState.BeaconState, epoch types.Epoch, pubKey []byte, status ethpb.ValidatorStatus) error {
committee, err := s.NextSyncCommittee()
if err != nil {
return err
}
syncCommPeriod := slots.SyncCommitteePeriod(epoch)
registerSyncSubnet(epoch, syncCommPeriod+1, pubKey, committee, status)
return nil
}

```

**Sync Committee Storage**

Persistence Mechanism

* [proto](https://github.com/prysmaticlabs/prysm/tree/develop/proto)
  * [eth/v2](https://github.com/prysmaticlabs/prysm/tree/develop/proto/eth/v2)
    * [validator.proto](https://github.com/prysmaticlabs/prysm/blob/develop/proto/eth/v2/validator.proto): messages for validators including `SyncCommitteeDuty`
    * [sync\_committee.proto](https://github.com/prysmaticlabs/prysm/blob/develop/proto/eth/v2/sync_committee.proto): messages for SyncCommittee which serves as committees to facilitate light client syncing to beacon chain.

[beacon\_state\_mainnet.go](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/state/state-native/beacon_state_mainnet.go)

```

// BeaconState defines a struct containing utilities for the Ethereum Beacon Chain state, defining
// getters and setters for its respective values and helpful functions such as HashTreeRoot().
type BeaconState struct {
version int
genesisTime uint64
genesisValidatorsRoot [32]byte
slot eth2types.Slot
fork *ethpb.Fork
latestBlockHeader *ethpb.BeaconBlockHeader
blockRoots *customtypes.BlockRoots
stateRoots *customtypes.StateRoots
historicalRoots customtypes.HistoricalRoots
eth1Data *ethpb.Eth1Data
eth1DataVotes []*ethpb.Eth1Data
eth1DepositIndex uint64
validators []*ethpb.Validator
balances []uint64
randaoMixes *customtypes.RandaoMixes
slashings []uint64
previousEpochAttestations []*ethpb.PendingAttestation
currentEpochAttestations []*ethpb.PendingAttestation
previousEpochParticipation []byte
currentEpochParticipation []byte
justificationBits bitfield.Bitvector4
previousJustifiedCheckpoint *ethpb.Checkpoint
currentJustifiedCheckpoint *ethpb.Checkpoint
finalizedCheckpoint *ethpb.Checkpoint
inactivityScores []uint64
currentSyncCommittee *ethpb.SyncCommittee
nextSyncCommittee *ethpb.SyncCommittee
latestExecutionPayloadHeader *enginev1.ExecutionPayloadHeader
latestExecutionPayloadHeaderCapella \*enginev1.ExecutionPayloadHeaderCapella
nextWithdrawalIndex uint64
nextWithdrawalValidatorIndex eth2types.ValidatorIndex

lock sync.RWMutex
dirtyFields map[nativetypes.FieldIndex]bool
dirtyIndices map[nativetypes.FieldIndex][]uint64
stateFieldLeaves map[nativetypes.FieldIndex]*fieldtrie.FieldTrie
rebuildTrie map[nativetypes.FieldIndex]bool
valMapHandler *stateutil.ValidatorMapHandler
merkleLayers [][][]byte
sharedFieldReferences map[nativetypes.FieldIndex]\*stateutil.Reference
}

```

[beacon\_state.pb.go](https://github.com/prysmaticlabs/prysm/blob/develop/proto/prysm/v1alpha1/beacon_state.pb.go#L962)

```

type SyncCommittee struct {
state protoimpl.MessageState
sizeCache protoimpl.SizeCache
unknownFields protoimpl.UnknownFields

Pubkeys [][]byte `protobuf:"bytes,1,rep,name=pubkeys,proto3" json:"pubkeys,omitempty" ssz-size:"512,48"`
AggregatePubkey []byte `protobuf:"bytes,2,opt,name=aggregate_pubkey,json=aggregatePubkey,proto3" json:"aggregate_pubkey,omitempty" ssz-size:"48"`
}

```

[Interfaces](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/state/interfaces.go)

```

// BeaconState has read and write access to beacon state methods.
type BeaconState interface {
SpecParametersProvider
ReadOnlyBeaconState
ReadOnlyWithdrawals
WriteOnlyBeaconState
Copy() BeaconState
HashTreeRoot(ctx context.Context) ([32]byte, error)
FutureForkStub
StateProver
}

```

```

// StateProver defines the ability to create Merkle proofs for beacon state fields.
type StateProver interface {
FinalizedRootProof(ctx context.Context) ([][]byte, error)
CurrentSyncCommitteeProof(ctx context.Context) ([][]byte, error)
NextSyncCommitteeProof(ctx context.Context) ([][]byte, error)
}

```

```
```

```
```


## Code bases and reviews

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

**Disclaimer: The content in this section are notes I took doing research and design work, primarily around bridging and consensus. Some are incomplete and they lack structure. I have included them here for completeness.**

* [Code bases and reviews](#code-bases-and-reviews)
  * [Overview](#overview)
  * [Functionality](#functionality)
  * [Reference Codebases](#reference-codebases)
    * [Blockchains](#blockchains)
    * [Bridging and Light Clients](#bridging-and-light-clients)
    * [Zero Knowledge](#zero-knowledge)

### Functionality

In this section we list codebases that implement cryptographic functions. We organize by functional areas such as signing, hashing, primitives and consensus. Where possible we provide a link to the algorithms/specifications being implemented followed by reference codebases.

We have summarized the functionality in three areas

* [Signing](../primitives/signatures.mdx)
* [Cryptographic Primitives](../primitives/primitives.mdx)
* [Consensus](../chains/intro.mdx)

### Reference Codebases

#### Blockchains

* [Binance](https://github.com/bnb-chain/bsc) (go)
* [Avalanche](https://github.com/ava-labs/avalanchego) (go)
* [Ethereum](https://clientdiversity.org/#distribution) [roadmap](https://notes.ethereum.org/@domothy/roadmap) [upgrading ethereum](https://eth2book.info/bellatrix/contents/) [consensus-specs](https://github.com/ethereum/consensus-specs)
  * Consensus Clients (Beacon Chain)
    * [prysm](https://github.com/prysmaticlabs/prysm) (go)
    * [lighthouse](https://github.com/sigp/lighthouse/) (rust)
    * [teku](https://github.com/ConsenSys/teku) (java)
    * [nimbus](https://github.com/status-im/nimbus-eth2) ([nim](https://nim-lang.org/))
    * [lodestar](https://github.com/ChainSafe/lodestar) (typescript)
    * [grandine](https://github.com/sifraitech/grandine) (rust) not open source
  * Execution Clients (Execution Chain)
    * [geth](https://github.com/ethereum/go-ethereum) (go)
    * [nethermind](https://github.com/NethermindEth/nethermind) (c#)
    * [Erigon](https://github.com/ledgerwatch/erigon) (go)
    * [Besu](https://github.com/hyperledger/besu) (java)
  * Light Client
    * [helios](https://github.com/a16z/helios) (rust): [article](https://a16zcrypto.com/building-helios-ethereum-light-client/)
    * [near rainbow bridge eth2-client](https://github.com/aurora-is-near/rainbow-bridge/tree/master/contracts/near/eth2-client) (rust)
    * [succinctlabs](https://github.com/succinctlabs/eth-proof-of-consensus/tree/main/contracts/src/lightclient) (solidity)
* [Harmony](https://github.com/harmony-one/harmony)
  * [Harmony MMRHardFork](https://github.com/peekpi/harmony/tree/mmrHardfork)
* [Near](https://github.com/near/nearcore)
* [Polkadot](https://github.com/orgs/paritytech/repositories)
  * [substrate](https://github.com/paritytech/substrate)
  * [cumulus](https://github.com/paritytech/cumulus)
  * [smoldot](https://github.com/smol-dot/smoldot)
  * [open-runtime-module-library](https://github.com/open-web3-stack/open-runtime-module-library)
* [Polygon](https://github.com/maticnetwork)
  * [peppermint](https://github.com/maticnetwork/tendermint/tree/peppermint) (go) fork of tendermint
  * [heimdall](https://github.com/maticnetwork/heimdall) (go)
* [Tendermint](https://github.com/tendermint/tendermint)

#### Bridging and Light Clients

* Light Clients
  * [Harmony MMRHardFork](https://github.com/peekpi/harmony/tree/mmrHardfork)

* Bridging
  * [Harmony Horizon Bridge](./Horizon.mdx): Detailed code review
    * [Horizon](https://github.com/johnwhitton/horizon/tree/refactorV2): javascript, solidity
  * [Near Rainbow Bridge](./ethereum-near.mdx): Detailed code review
    * [Near Rainbow Bridge](https://github.com/aurora-is-near/rainbow-bridge): rust, go, solidity, javascript
    * [Near Rainbow Token Connector](https://github.com/aurora-is-near/rainbow-token-connector): soldity
    * SDK
      * [Near Rainbow Bridge Client](https://github.com/aurora-is-near/rainbow-bridge-client/tree/main/packages/client): typescript
    * Frontend
      * [NEAR Rainbow Bridge Frontend](https://github.com/aurora-is-near/rainbow-bridge-frontend)
  * [Nomad monprepo](https://github.com/nomad-xyz/monorepo): Nomad is a cross-chain communication protocol. This repo contains the following: Smart contracts for the core Nomad protocol, Smart contracts for the Nomad token bridge SDKs for Nomad's core protocol, bridge, and governance systems, Tooling for local environment simulation and Smart contract deployment tooling.
    * [Nomad rust](https://github.com/nomad-xyz/rust): Nomad is a cross-chain communication standard that supports passing messages between blockchains easily and inexpensively. Like IBC light clients and similar systems, Nomad establishes message-passing channels between chains. Once a channel is established, any application on that chain can use it to send messages to others chains.
    * [Nomad gelato-sdk](https://github.com/nomad-xyz/gelato-sdk): This crate reimplements Gelato's Relay SDK in Rust. It simply wraps Gelato Relay requests and responses to/from Gelato endpoints with Rust types and methods.
  * [Succinct labs](../bridge/succinct.mdx): Deep dive on Succinct labs Proof of Consensus for Ethreum.
    * [Proof of Consensus for Ethereum](https://github.com/succinctlabs/eth-proof-of-consensus): contains both the zkSNARK circuits as well as the smart contracts needed for our succinct light client implementation, as well as prototype message passing contracts and bridge contracts.
  * [Datachain lcp](https://github.com/datachainlab:)A proxy for light client verification executed in TEE.
  * [Cosmos ibc-go](https://github.com/cosmos/ibc-go): allows blockchains to talk to each other. This end-to-end, connection-oriented, stateful protocol provides reliable, ordered, and authenticated communication between heterogeneous blockchains.
    * [Cosmos ibc](https://github.com/cosmos/ibc): ibc specification
  * [Cosmos gravity bridge](https://github.com/cosmos/gravity-bridge): Cosmos and Ethereum bridge designed to run on the Cosmos Hub focused on maximum design simplicity and efficiency.
  * [Axelar](https://github.com/axelarnetwork/axelar-core): based on the Cosmos SDK is the main application of the axelar network. [whitepaper](https://axelar.network/axelar_whitepaper.pdf) [docs](https://docs.axelar.dev/)
  * [Celer cBridge-node](https://github.com/celer-network/cBridge-node): Celer cBridge relay node implementation in Golang. ([docs](https://cbridge-docs.celer.network/))
    * [Celer cBridge-contracts](https://github.com/celer-network/cBridge-contracts): Contracts for cBridge, cross-chain liquidity solution powered by Hashed-Timelock Transfers
    * [Celer cBridge-cowa](https://github.com/celer-network/cbridge-cowa): CosmWasm Rust smart contracts for cbridge
  * [Wormhole](https://github.com/wormhole-foundation/wormhole): the reference implementation of the Wormhole protocol. ([docs](https://book.wormhole.com/introduction/introduction.html))
  * [LayerZero Labs LayerZero](https://github.com/LayerZero-Labs/LayerZero): contains the smart contracts for LayerZero Endpoints. ([docs](https://layerzero.gitbook.io/docs/))
  * [Multichain CrossChain-Bridge](https://github.com/anyswap/CrossChain-Bridge): Cross-Chain bridge based on Anyswap MPC network. ([docs](https://docs.multichain.org/getting-started/introduction))
  * [Synapse Protocol](https://github.com/synapsecns): a universal interoperability protocol that enables secure cross-chain communication.( [docs](https://docs.synapseprotocol.com/))
    * [synapse-contracts](https://github.com/synapsecns/synapse-contracts): smart contracts for Synapse Protocol.
  * [Hop Protocol contracts](https://github.com/hop-protocol/contracts): Hop is a scalable rollup-to-rollup general token bridge. Heare are the smart contracts that power the Hop Exchange. ([whitepaper](https://hop.exchange/whitepaper.pdf), [docs](https://docs.hop.exchange/basics/a-short-explainer)).
  * [Router Protocol](https://github.com/orgs/router-protocol/repositories): ([whitepaper](https://docs.routerprotocol.com/whitepaper/introducing-router-protocol), [docs](https://dev.routerprotocol.com/))
  * [Parity Bridges Common](https://github.com/paritytech/parity-bridges-common): a collection of components for building bridges.
  * [Snowfork snowbridge](https://github.com/Snowfork/snowbridge): A trustless bridge between Polkadot and Ethereum. ([docs](https://docs.snowbridge.network/))

#### Zero Knowledge

* Foundational
  * [halo2](https://github.com/zcash/halo2) (rust)
    * [halo2 privacy-scaling-explorations](https://github.com/privacy-scaling-explorations/halo2/commits/main) (rust) fork
    * [junyu0312](https://github.com/junyu0312/halo2) (rust) fork
  * [Circom](https://github.com/iden3/circom) a novel domain-specific language for defining arithmetic circuits that can be used to generate zero-knowledge proofs
  * [Arkworks](https://github.com/arkworks-rs) (rust)
  * [noir](https://github.com/noir-lang/noir) (rust)
  * [StarkWare's Poseidon Hash](https://github.com/starkware-industries/poseidon)
* Applications
  * [halo2ecc-s](https://github.com/DelphinusLab/halo2ecc-s) (rust): ecc circuits with halo2
  * [DarkForest](https://github.com/darkforest-eth) zkSNARK space warfare
  * [Awesome List](https://github.com/snowtigersoft/awesome-darkforest)
* Proof of Consensus/Bridging
  * [succinctlabs](https://github.com/succinctlabs/eth-proof-of-consensus) (circom)


## Avalanche

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

Avalanche is good candidate because it samples from a large number of validators to produce blocks, uses generic methods for signing blocks (RSA on a X.509 certificate), is moving to transition to BLS signatures for validators, and has numerous subnets.

In Avalanche, there are two types of consensus mechanisms (Avalanche, partially ordered, and Snowman, linearly ordered similar to other blockchains). Users can create arbitrary subnets in Avalanche, and any validator is free to participate the consensus for any subnet[^ov-1], besides the mandatory participation of the special subnet - the Primary Network. Each subnet has three types of chains, each with different roles and runs different consensus mechanism and process different transaction types: (1) P-Chain, which defines validator sets and process validator related transactions; (2) X-Chain, for exchanging assets, where blocks are partially ordered; (3) C-Chain, which runs an EVM and handles smart contract interactions [^ov-2].

*Note: On march 23rd, 2023 Avalanche published an article[^ov-18] giving an overviow of the Cortina release, it's move to linearize the X-chain to enable support for WARP messaging.*

We limit our scope to only the **Primary Network**, since any bridging implementation is likely replicable in subnets, and subnets are likely to be interoperable soon. For trustless bridging, only events from **C-Chain** are relevant, since the bridge must be a smart contract and all cross-chain operations can be conveniently wrapped inside contract interactions.

The active Avalanche validator set is unrestricted and permissionless, and has more than 1000 members at this time [^ov-3]. Block proposers are randomly sampled from the active validator set, therefore any validator could potentially sign a block [^ov-4]. The validators use X.509 (TLS)certificate to sign and verify blocks [^ov-5], and the block headers contain both the certificate and the signature [^ov-6]. Neither Avalanche documentation or code specifies the key and signing algorithms for the X.509 certificate, but the certificate auto-generated by the code (invoked via validator command-line tools) creates 4096-bit RSA key by default [^ov-7].

In recent releases[^ov-8] [^ov-9] [^ov-10] [^ov-11] [^ov-12] [^ov-13] of Avalanche, validators may also load or generate an optional BLS key. This is to support Avalanche Warp Messaging (AWM) [^ov-14] [^ov-15] supporting inter-subnet messaging. This suggests the protocol may replace its signature scheme from RSA to BLS in the near future.

*Note that RSA signature can be cheaply verified on-chain, per EIP-198 [^ov-16] . Solidity libraries [^ov-17] are also available for RSA signature verification. In the worst case, even if any validator chooses to use a non-RSA custom-made certificate, most of the signing algorithms (ECDSA, EDDSA) supported by chosen crypto library in Go can also be verified on-chain.*

### Consensus Mechanisms

There are two main consensus algorithms: Avalanche and Snowman. As stated above our focus is bridging from the **C-Chain** (contract(C) Chain) which uses [Snowman Consensus](#snowman-consensus).

#### Avalanche Primary Network

Avalanche is a network of blockchains[^con-1], this diagram gives an overview of the avalanche primiary network.

![Avalanche Primary Network](/assets/research/avalanche-primary-network.png "Avalanche Primary Network")

#### Avalanche Consensus

Following is an excerpt from the Avalanche Consensus Whitepaper [^con-2], it is also recommended reviewing Avalanche Blockchain Consensus Documentation [^con-3].

> This paper introduces a family of leaderless Byzantine fault tolerance protocols, built around a metastable mechanism via network subsampling. These protocols provide a strong probabilistic safety guarantee in the presence of Byzantine adversaries while their concurrent and leaderless nature enables them to achieve high throughput and scalability. Unlike blockchains that rely on proof-of-work, they are quiescent and green. Unlike traditional consensus protocols where one or more nodes typically process linear bits in the number of total nodes per decision, no node processes more than logarithmic bits. It does not require accurate knowledge of all participants and exposes new possible tradeoffs and improvements in safety and liveness for building consensus protocols.
>
> The paper describes the Snow protocol family, analyzes its guarantees, and describes how it can be used to construct the core of an internet-scale electronic payment system called Avalanche, which is evaluated in a large scale deployment. Experiments demonstrate that the system can achieve high throughput (3400 tps), provide low confirmation latency (1.35 sec), and scale well compared to existing systems that deliver similar functionality. For our implementation and setup, the bottleneck of the system is in transaction verification.

![Avalanche Consensus](/assets/research/avalanche-consensus.png "Avalanche Consensus")

#### Snowman Consensus

Snowman consensus is one of the consensus mechanisms for single blockchains supported by snow [^con-4], the following excerp and diagram give an overview of how a blockchain (in our case the C-chain) can leverage one of snows mulitple conensus mechanisms (in our case snowman).

> Each blockchain on Avalanche has several components: the virtual machine, database, consensus engine, sender, and handler. These components help the chain run smoothly. Blockchains also interact with the P2P layer and the chain router to send and receive messages.

![Avalanche flow of a single blockchain](/assets/research/avalanche-flow.png "Avalanche Flow of a single blockchain")

In the case of the C-Chain, avalanche uses coreth[^con-5] a modified version of geth, as it's vm to provide EVM support. It also uses Snowman++ [^con-7] as a congestion controle mechanism, effectively pre-selecting a set of proposers and giving them a submission window to submit blocks. If they fail to submit within their WindowDuration then any other validator can issue the block.

Below is an excerpt of how Snowman vms [^con-6] and the consensus engine work.

> **Implementing the Snowman VM Block**
> From the perspective of the consensus engine, the state of the VM can be defined as a linear chain starting from the genesis block through to the last accepted block.
>
> Following the last accepted block, the consensus engine may have any number of different blocks that are processing. The configuration of the processing set can be defined as a tree with the last accepted block as the root.
>
> In practice, this looks like the following:
>
> ```text
>    G
>    |
>    .
>    .
>    .
>    |
>    L
>    |
>    A
>  /   \
> B     C
> ```

### Signing Mechanisms

#### Consensus Signing Mechanism

Avalanche is not prescriptive about addressing schemes, choosing to instead leave addressing up to each blockchain [^sig-1].

Avalanche uses Transport Layer Security, TLS, to protect node-to-node communications from eavesdroppers. TLS combines the practicality of public-key cryptography with the efficiency of symmetric-key cryptography.

#### Inter-Subnet Message Signing Mechanism

Avalanche Warp Messaging (AWM)[^ov-14] [^ov-15] enables Subnet Validators to collectively produce a BLS Multi-Signature that attests to the validity of an arbitrary message (e.g., transfer, contract data, etc.) that can be verified by any other Subnet.

#### Transaction Signing Mechanism

The addressing scheme of the X-Chain and the P-Chain relies on secp256k1. Avalanche follows a similar approach as Bitcoin and hashes the ECDSA public key. The 33-byte compressed representation of the public key is hashed with sha256 once. The result is then hashed with ripemd160 to yield a 20-byte address.

The Avalanche virtual machine uses elliptic curve cryptography, specifically secp256k1, for its signatures on the blockchain.

### Verification Walkthrough

1. Transactions are gossiped via P2P mechanisms in coreth

```go
// Block represents an entire block in the Ethereum blockchain.
type Block struct {
 header       *Header
 uncles       []*Header
 transactions Transactions

 // Coreth specific data structures to support atomic transactions
 version uint32
 extdata *[]byte

 // caches
 hash atomic.Value
 size atomic.Value
}

// Header represents a block header in the Ethereum blockchain.
type Header struct {
 ParentHash  common.Hash    `json:"parentHash"       gencodec:"required"`
 UncleHash   common.Hash    `json:"sha3Uncles"       gencodec:"required"`
 Coinbase    common.Address `json:"miner"            gencodec:"required"`
 Root        common.Hash    `json:"stateRoot"        gencodec:"required"`
 TxHash      common.Hash    `json:"transactionsRoot" gencodec:"required"`
 ReceiptHash common.Hash    `json:"receiptsRoot"     gencodec:"required"`
 Bloom       Bloom          `json:"logsBloom"        gencodec:"required"`
 Difficulty  *big.Int       `json:"difficulty"       gencodec:"required"`
 Number      *big.Int       `json:"number"           gencodec:"required"`
 GasLimit    uint64         `json:"gasLimit"         gencodec:"required"`
 GasUsed     uint64         `json:"gasUsed"          gencodec:"required"`
 Time        uint64         `json:"timestamp"        gencodec:"required"`
 Extra       []byte         `json:"extraData"        gencodec:"required"`
 MixDigest   common.Hash    `json:"mixHash"`
 Nonce       BlockNonce     `json:"nonce"`
 ExtDataHash common.Hash    `json:"extDataHash"      gencodec:"required"`

 // BaseFee was added by EIP-1559 and is ignored in legacy headers.
 BaseFee *big.Int `json:"baseFeePerGas" rlp:"optional"`

 // ExtDataGasUsed was added by Apricot Phase 4 and is ignored in legacy
 // headers.
 //
 // It is not a uint64 like GasLimit or GasUsed because it is not possible to
 // correctly encode this field optionally with uint64.
 ExtDataGasUsed *big.Int `json:"extDataGasUsed" rlp:"optional"`

 // BlockGasCost was added by Apricot Phase 4 and is ignored in legacy
 // headers.
 BlockGasCost *big.Int `json:"blockGasCost" rlp:"optional"`
}

```

2. The block is then wrapped into an `innerBlock` by [snowman++](https://github.com/ava-labs/avalanchego/blob/master/vms/README.mdx) and has the following interfaces

```go
type Block interface {
 ID() ids.ID
 ParentID() ids.ID
 Block() []byte
 Bytes() []byte

 initialize(bytes []byte) error
}

type SignedBlock interface {
 Block

 PChainHeight() uint64
 Timestamp() time.Time
 Proposer() ids.NodeID

 Verify(shouldHaveProposer bool, chainID ids.ID) error
}

type statelessUnsignedBlock struct {
 ParentID     ids.ID `serialize:"true"`
 Timestamp    int64  `serialize:"true"`
 PChainHeight uint64 `serialize:"true"`
 Certificate  []byte `serialize:"true"`
 Block        []byte `serialize:"true"`
}

type statelessBlock struct {
 StatelessBlock statelessUnsignedBlock `serialize:"true"`
 Signature      []byte                 `serialize:"true"`

 id        ids.ID
 timestamp time.Time
 cert      *x509.Certificate
 proposer  ids.NodeID
 bytes     []byte
}
```

The block is initialized using [block.Build](https://github.com/ava-labs/avalanchego/blob/master/vms/proposervm/block.go#L231) which currently uses `StakingCertLeaf` not `StakingBLSKey`

```go
 statelessChild, err = block.Build(
  parentID,
  newTimestamp,
  pChainHeight,
  p.vm.ctx.StakingCertLeaf,
  innerBlock.Bytes(),
  p.vm.ctx.ChainID,
  p.vm.ctx.StakingLeafSigner,
 )
```

The [Build](https://github.com/ava-labs/avalanchego/blob/master/vms/proposervm/block/build.go#L41) function takes the `StakingCertLeaf` as input for `cert *x509.Certificate`

```
func Build(
 parentID ids.ID,
 timestamp time.Time,
 pChainHeight uint64,
 cert *x509.Certificate,
 blockBytes []byte,
 chainID ids.ID,
 key crypto.Signer,
)
```

Signatures are verified using [Verify](https://github.com/ava-labs/avalanchego/blob/master/vms/proposervm/block/block.go#L119) which checks the signature as follows

```go
 return b.cert.CheckSignature(b.cert.SignatureAlgorithm, headerBytes, b.Signature)
```

### Code Review

Folllowing is a review of . Avalanche also has a [coreth codebase](https://github.com/ava-labs/coreth) which was inspired by [geth](https://github.com/ethereum/go-ethereum). Please see [here](./ethereum-1-0.mdx) for a code review of geth. Following is an excerpt from [coreth README.md](https://github.com/ava-labs/coreth/blob/master/README.mdx).

> Coreth (from core Ethereum) is the Virtual Machine (VM) that defines the Contract Chain (C-Chain). This chain implements the Ethereum Virtual Machine and supports Solidity smart contracts as well as most other Ethereum client functionality.

#### Signing

* [Avalanche Signing Codebase](https://github.com/ava-labs/avalanchego/tree/master/utils/crypto)
  * [getStakingSigner](https://github.com/ava-labs/avalanchego/blob/master/config/config.go#L688): Configuration retrieving validators BLS key. (go)
  * [Signer Interface](https://github.com/ava-labs/avalanchego/blob/master/vms/platformvm/signer/signer.go): returns the public BLS key if it exists. (go)
  * [bls signature](https://github.com/ava-labs/avalanchego/blob/master/utils/crypto/bls/signature.go): Includes functions `SignatureToBytes`, `SignatureFromBytes` and `AggregateSignatures` aggregates a non-zero number of signatures into a single aggregated signature.
  * [secp256kr1](https://github.com/ava-labs/avalanchego/blob/master/utils/crypto/secp256k1r.go): Avalanches implementation of the ECSDA secp256k1r curve (go)
  * [tx.go](https://github.com/ava-labs/avalanchego/blob/master/vms/platformvm/txs/tx.go#L38): Includes function for signing transactions using a Secp256k1r private key.

#### Consensus

* [Avalanche ConsensusContext Codebase](https://github.com/ava-labs/avalanchego/blob/master/snow/context.go#L63): Context is information about the current executio including `NetworkID` is the ID of the network this context exists within. `ChainID` is the ID of the chain this context exists within. `NodeID` is the ID of this node. (go)
* [Avalanche Consensus CodeBase](https://github.com/ava-labs/avalanchego/tree/master/snow/consensus): Contains consenus engines snowball, snowman, snowstorm and avalanche (go)
  * [Avalanche snow README.md](https://github.com/ava-labs/avalanchego/blob/master/snow/README.mdx): Documentation of the folow of a Single Blockchain.
  * [consensus.go](https://github.com/ava-labs/avalanchego/blob/master/snow/consensus/avalanche/consensus.go): Consensus code (go). *Consensus represents a general avalanche instance that can be used directly to process a series of partially ordered elements.*
  * [avalanche poll](https://github.com/ava-labs/avalanchego/tree/master/snow/consensus/avalanche/poll): Avalanches Polling (validator voting) mechanism (go).
  * [snowman consensus.go](https://github.com/ava-labs/avalanchego/blob/master/snow/consensus/snowman/consensus.go): Snowman consenus code (go). *represents a general snowman instance that can be used directly to process a series of dependent operations.*
  * [avalanche snowman poll](https://github.com/ava-labs/avalanchego/tree/master/snow/consensus/snowman/poll): Snowman Polling (validator voting) mechanism (go).

#### Cryptographic Primitives

**general primitives**

* [bag](https://github.com/ava-labs/avalanchego/tree/master/utils/bag): Mulitset with the ability to set thresholds add elements, compare against other bags, filter, split and return all elements which have been added a number of times.
* [beacon](https://github.com/ava-labs/avalanchego/tree/master/utils/beacon): Beacons are a structure contiaining the NodeId and IPPort.
* [bloom](https://github.com/ava-labs/avalanchego/tree/master/utils/bloom): Avalanches implementation of BloomFilteres
* [bufer](https://github.com/ava-labs/avalanchego/tree/master/utils/buffer): Buffer with queuing mechanisms including an unbounded deque [double-ended queue](https://en.wikipedia.org/wiki/Double-ended_queue). Not safe for concurrent access.
* [cb58](https://github.com/ava-labs/avalanchego/tree/master/utils/cb58): [CB58](https://support.avax.network/en/articles/4587395-what-is-cb58) is a format used to represent keys, addresses, and other binary values in web wallets and APIs. CB58 is the concatenation of the data bytes and a checksum. The checksum is created by taking the last four bytes of the SHA256 hash of the data bytes.
* [compare](https://github.com/ava-labs/avalanchego/tree/master/utils/compare): Compares slices and returns true iff the slices have the same elements, regardless of order.
* [compression](https://github.com/ava-labs/avalanchego/tree/master/utils/compression): compresss and decompresses messages using gzip compression.
* [constants](https://github.com/ava-labs/avalanchego/tree/master/utils/constants): Constants for avalanche including aliases, applications, network\_ids, network constantns and vm\_ids.
* [crypto](https://github.com/ava-labs/avalanchego/tree/master/utils/crypto)
  * [bls](https://github.com/ava-labs/avalanchego/tree/master/utils/crypto/bls): Provides the interface to the [blst](https://github.com/supranational/blst/) BLS12-381 signature library.
  * [keychain](https://github.com/ava-labs/avalanchego/tree/master/utils/crypto/keychain): implements functions for a keychain to return its main address and to sign a hash.
  * [ledger](https://github.com/ava-labs/avalanchego/tree/master/utils/crypto/ledger): Ledger is a wrapper around the low-level Ledger Device interface that provides Avalanche-specific access.
  * [secp256k1](https://github.com/ava-labs/avalanchego/tree/master/utils/crypto/secp256k1): Avalanche implementation of [secp256k1](https://arxiv.org/pdf/1808.02988.pdf)
* [dynamicip](https://github.com/ava-labs/avalanchego/tree/master/utils/dynamicip): Updates and resolves public IP's using [ifconfig's](https://en.wikipedia.org/wiki/Ifconfig) format.
* [filesystem](https://github.com/ava-labs/avalanchego/tree/master/utils/filesystem): Reads and renames files.
* [formatting](https://github.com/ava-labs/avalanchego/tree/master/utils/formatting): Formats addresses. Parse takes in an address string and splits returns the corresponding parts. This returns the chain ID alias, bech32 HRP, address bytes, and an error if it occurs.
* [hashing](https://github.com/ava-labs/avalanchego/tree/master/utils/hashing): see hash functions below.
* [ips](https://github.com/ava-labs/avalanchego/tree/master/utils/ips): ip utlitilties including claim (A self contained proof that a peer is claiming ownership of an IPPort at a given time.) and lookup (Lookup attempts to resolve a hostname to a single IP. If multiple IPs are found.
* [json](https://github.com/ava-labs/avalanchego/tree/master/utils/json); utilities for marshalling and unmarshalling json.
* [linkedhashmap](https://github.com/ava-labs/avalanchego/tree/master/utils/linkedhashmap): is a hashmap that keeps track of the oldest pairing and the newest pairing. hashmap provides an O(1) mapping from a [comparable](https://go.dev/ref/spec#Comparison_operators) key to any value.
* [math](https://github.com/ava-labs/avalanchego/tree/master/utils/math): mathematic functions
* [metric](https://github.com/ava-labs/avalanchego/tree/master/utils/metric): Provide metrics by integrating with [Prometheus](https://prometheus.io/).
* [password](https://github.com/ava-labs/avalanchego/tree/master/utils/password): Implements password Hashing using [Argon2](https://pkg.go.dev/golang.org/x/crypto/argon2)
* [perms](https://github.com/ava-labs/avalanchego/tree/master/utils/perms): provides the ability to modify file permissions.
* [profiler](https://github.com/ava-labs/avalanchego/tree/master/utils/profiler): Profiler provides helper methods for measuring the current performance of processes/
* [resource](https://github.com/ava-labs/avalanchego/tree/master/utils/resource): provides resource usage information including active cpu and disk usage.
* [rpc](https://github.com/ava-labs/avalanchego/tree/master/utils/rpc): Manages requests for avalanche rpc endpoints.
* [sampler](https://github.com/ava-labs/avalanchego/tree/master/utils/sampler): sample a specified valued based on a provided weighted distribution. Sampling is performed by executing a modified binary search over the provided elements. Rather than cutting the remaining dataset in half, the algorithm attempt to just in to where it think the value will be assuming a linear distribution of the element weights.
* [set](https://github.com/ava-labs/avalanchego/tree/master/utils/set): Return a new set with initial capacity \[size]. More or less than \[size] elements can be added to this set. Using NewSet() rather than Set\[T]{} is just an optimization that can be used if you know how many elements will be put in this set.
* [storage](https://github.com/ava-labs/avalanchego/tree/master/utils/storage): File system storage
* [timer](https://github.com/ava-labs/avalanchego/tree/master/utils/timer): Timer wraps a timer object. This allows a user to specify a handler. Once specifying the handler, the dispatch thread can be called. The dispatcher will only return after calling Stop. SetTimeoutIn will result in calling the handler in the specified amount of time.
* [ulimit](https://github.com/ava-labs/avalanchego/tree/master/utils/ulimit): Manages resource limits.
* [units](https://github.com/ava-labs/avalanchego/tree/master/utils/units): Unit Constants (e.g. `Avax      uint64 = 1000 * MilliAvax` )
* [window](https://github.com/ava-labs/avalanchego/tree/master/utils/window): an interface which represents a sliding window of elements.
* [wrappers](https://github.com/ava-labs/avalanchego/tree/master/utils/wrappers): Wrappers for packing and unpacking data.

**hash functions**

* [hashing](https://github.com/ava-labs/avalanchego/tree/master/utils/hashing)
  * [sha256](https://github.com/ava-labs/avalanchego/blob/master/utils/hashing/hashing.go#L7): Implements [SHA256](https://en.wikipedia.org/wiki/SHA-2) hashing.
  * [ripmed160](https://github.com/ava-labs/avalanchego/blob/master/utils/hashing/hashing.go#LL11C2-L11C2): Implements [RIPEMD](https://en.wikipedia.org/wiki/RIPEMD) (RIPE Message Digest), a family of cryptographic hash functions developed in 1992 (the original RIPEMD) and 1996 (other variants). There are five functions in the family: RIPEMD, RIPEMD-128, RIPEMD-160, RIPEMD-256, and RIPEMD-320, of which RIPEMD-160 is the most common.
  * [ring](https://github.com/ava-labs/avalanchego/blob/master/utils/hashing/consistent/ring.go): Ring is an interface for a consistent [hashing ring](https://en.wikipedia.org/wiki/Consistent_hashing).
* [Argon2 password hashing](https://github.com/ava-labs/avalanchego/tree/master/utils/password): Implements password Hashing using [Argon2](https://pkg.go.dev/golang.org/x/crypto/argon2)

**encryption**

**random number generators**

**serilization**

**virtual machines**

* [vms](https://github.com/ava-labs/avalanchego/tree/master/vms): Avalanche Virtual Machines

### References

**Consensus**

* [Scalable and Probabilistic Leaderless BFT Consensus through Metastability](https://assets.website-files.com/5d80307810123f5ffbb34d6e/6009805681b416f34dcae012_Avalanche%20Consensus%20Whitepaper.pdf): This paper introduces a family of leaderless Byzantine fault tolerance protocols, built around a metastable mechanism via network subsampling.

* [Avalanche Blockchain Consensus Documentation](https://docs.avax.network/overview/getting-started/avalanche-consensus): Overive of the Snowball Algorithm used for Avalanche Consenus and it's use of Directed Acyclic Graphs (DAGs).

* [Avalanche Subnet Overview Documentation](https://docs.avax.network/subnets): Overview of Avalanches Subnets and their use of Avalanche's 3 built-in blockchains: Platform Chain (P-Chain), Contract Chain (C-Chain) and Exchange Chain (X-Chain).

* [Avalanche Get Current Validator Documentation](https://docs.avax.network/apis/avalanchego/apis/p-chain#platformgetcurrentvalidators): List the current validators of the given Subnet. Signer is the node's BLS public key and proof of possession.

* [Avalanche Get Node Id Documentation](https://docs.avax.network/apis/avalanchego/apis/info#infogetnodeid): Get the ID of this node. nodePOP is this node's BLS key and proof of possession.

* [Avalanche Platform Transaction Format Documentation](https://docs.avax.network/specs/platform-transaction-serialization): Documenation on how transactions are serialized and the use of the primitive serialization format for packing and secp256k1 for cryptographic user identification.

* [Avalanche Network Status Dashboard](https://stats.avax.network/dashboard/network-status/):

**Signing**

* [Avalanche Cryptographic Primitive Documentation](https://docs.avax.network/specs/cryptographic-primitives): Overview of Avalanches cryptographic primitives focusing on it's use of TLS AND Secp256k1.
* Avalanche BLS Support Release Documentation
  * [Release v1.8.6: Apricot Phase 6](https://github.com/ava-labs/avalanchego/releases/tag/v1.8.6): Adds BLS key file and exposes blos proof of posession
  * [Release v1.9.1: Banff.1](https://github.com/ava-labs/avalanchego/releases/tag/v1.9.1): Added BLS signer to the snow\.Context
  * [Release v1.9.2: Banff.2 - Additional BLS Support](https://github.com/ava-labs/avalanchego/releases/tag/v1.9.2): Added bls proof of possession to `platform.getCurrentValidators` and `platform.getPendingValidators`. Added bls public key to in-memory staker objects. Improved memory clearing of bls secret keys.
* Avalanch BLS Relevant Commits
  * [Add BLS key to AddPermissionlessValidatorTx for the Primary Network (#1987)](https://github.com/ava-labs/avalanchego/commit/fb6bb81f499b4b8c0f903c8745f5b7fbd8d97668)
  * [Add BLS signer to snow.Context (#2069)](https://github.com/ava-labs/avalanchego/commit/5176495568e512b2ebbfb1102dfd59541ccaa578)

**Staking**

* [Avalanche Staking Documentation](https://docs.avax.network/nodes/validate/staking#staking-parameters-on-avalanche): Staking Parameters on Avalanche

**Additional**

* [UTXO Codebase](https://github.com/ava-labs/avalanchego/blob/master/vms/platformvm/utxo/handler.go): Unsigned Transaction Output Handling.
* [xsvm](https://github.com/ava-labs/xsvm): Cross Subnet Asset Transfers README Overview

### Footnotes

Overview

[^ov-1]: [Avalanche introductory documentation](https://docs.avax.network/overview/getting-started/avalanche-platform): Avalanche is a heterogeneous network of blockchains allowing separate chains to be created for different applications.

[^ov-2]: [Snowman VM](https://github.com/ava-labs/avalanchego/blob/master/vms/README.mdx): To the consensus engine, the Snowman VM is a black box that handles all block building, parsing, and storage and provides a simple block interface for the consensus engine to call as it decides blocks.

[^ov-3]: [Avalanche explorer](https://subnets.avax.network/): Block Explorere showing subnets, totoal blockchains, total validators and totals stake amount.

[^ov-4]: [Snowman++](https://github.com/ava-labs/avalanchego/blob/master/vms/proposervm/README.mdx): a congestion control mechanism available for snowman VMs.

[^ov-5]: [block verify function](https://github.com/ava-labs/avalanchego/blob/master/vms/proposervm/block/block.go#L119): statelessBlock Verify function in proposervm.

[^ov-6]: [block structure](https://github.com/ava-labs/avalanchego/blob/master/vms/proposervm/block/block.go#L51): statelessBlock structure in proposervm.

[^ov-7]: [NewCertAndKeyBytes](https://github.com/ava-labs/avalanchego/blob/master/staking/tls.go#L120): Creates a new staking private key / staking certificate pair. Returns the PEM byte representations of both.

Avalanche BLS Support Release Documentation

[^ov-8]: [release notes on GitHub](https://github.com/ava-labs/avalanchego/releases/tag/v1.9.2) and [code commit search result](https://github.com/ava-labs/avalanchego/search?q=bls\&type=commits)

[^ov-9]: [Release v1.8.6: Apricot Phase 6](https://github.com/ava-labs/avalanchego/releases/tag/v1.8.6): Adds BLS key file and exposes blos proof of posession

[^ov-10]: [Release v1.9.1: Banff.1](https://github.com/ava-labs/avalanchego/releases/tag/v1.9.1): Added BLS signer to the snow\.Context

[^ov-11]: [Release v1.9.2: Banff.2 - Additional BLS Support](https://github.com/ava-labs/avalanchego/releases/tag/v1.9.2): Added bls proof of possession to `platform.getCurrentValidators` and `platform.getPendingValidators`. Added bls public key to in-memory staker objects. Improved memory clearing of bls secret keys.

Avalanche BLS Relevant Commits

[^ov-12]: [Add BLS key to AddPermissionlessValidatorTx for the Primary Network (#1987)](https://github.com/ava-labs/avalanchego/commit/fb6bb81f499b4b8c0f903c8745f5b7fbd8d97668)

[^ov-13]: [Add BLS signer to snow.Context (#2069)](https://github.com/ava-labs/avalanchego/commit/5176495568e512b2ebbfb1102dfd59541ccaa578)

Warp Messaging

[^ov-14]: [Avalanche Warp Messaging (AWM)](https://medium.com/avalancheavax/avalanche-warp-messaging-awm-launches-with-the-first-native-subnet-to-subnet-message-on-avalanche-c0ceec32144a): AWM enables Subnet Validators to collectively produce a BLS Multi-Signature that attests to the validity of an arbitrary message (e.g., transfer, contract data, etc.) that can be verified by any other Subnet.

[^ov-15]: [avalanchego warp codebase](https://github.com/ava-labs/avalanchego/tree/master/vms/platformvm/warp): Codebase supporting bls signing of inter-subnet messages.

RSA Support

[^ov-16]: [EIP-198](https://github.com/ethereum/EIPs/blob/f2db669da93ca4ce1605866e147bfa4f56303fc6/EIPS/eip-198.mdx): Big integer modular exponentiation. Pre-compile for Ethereum which allows for efficient RSA verification inside of the EVM, as well as other forms of number theory-based cryptography.

[^ov-17]: [SolRsaVerify](https://github.com/adria0/SolRsaVerify): Solidity Library which allows verification of RSA Sha256 Pkcs1.5 Signatures

[^ov-18]: [Cortina: X-Chain Linearization](https://medium.com/avalancheavax/cortina-x-chain-linearization-a1d9305553f6): This upgrade linearizes the X-chain, introduces delegation batching to the P-chain, and increases the maximum block size on the C-chain. (Release notes are [here](https://github.com/ava-labs/avalanchego/releases) and changelog is [here](https://github.com/ava-labs/avalanchego/compare/v1.9.16...v1.10.0))

consensus

[^con-1]: [Avalanche Platform](https://docs.avax.network/overview/getting-started/avalanche-platform): Avalanche is a heterogeneous network of blockchains. The Primary Network is a special Subnet that contains all validators (including validators of any custom Subnets).

[^con-2]: [Avalanche Consensus Whitepaper](https://assets.website-files.com/5d80307810123f5ffbb34d6e/6009805681b416f34dcae012_Avalanche%20Consensus%20Whitepaper.pdf): Scalable and Probabilistic Leaderless BFT Consensus through Metastability. This paper introduces a family of leaderless Byzantine fault tolerance protocols, built around a metastable mechanism via network subsampling.

[^con-3]: [Avalanche Docs: Consensus](https://docs.avax.network/overview/getting-started/avalanche-consensus): a consensus protocol that is scalable, robust, and decentralized. It has low latency and high throughput. It is energy efficient and does not require special computer hardware.

[^con-4]: [Snow README.md](https://github.com/ava-labs/avalanchego/blob/master/snow/README.mdx): Each blockchain on Avalanche has several components: the virtual machine, database, consensus engine, sender, and handler. These components help the chain run smoothly. Blockchains also interact with the P2P layer and the chain router to send and receive messages.

[^con-5]: [Coreth and the C-Chain](https://github.com/ava-labs/coreth/tree/master#readme): Coreth is a dependency of AvalancheGo which is used to implement the EVM based Virtual Machine for the Avalanche C-Chain.

[^con-6]: [Snowman VM's](https://github.com/ava-labs/avalanchego/blob/master/vms/README.mdx): To the consensus engine, the Snowman VM is a black box that handles all block building, parsing, and storage and provides a simple block interface for the consensus engine to call as it decides blocks.

[^con-7]: [Snowman++: congestion control for Snowman VMs](https://github.com/ava-labs/avalanchego/blob/master/vms/proposervm/README.mdx): Snowman++ introduces a soft proposer mechanism which attempts to select a single proposer with the power to issue a block, but opens up block production to every validator if sufficient time has passed without blocks being generated.

signing

[^sig-1]: [Avalanche Cryptographic Primitive Documentation](https://docs.avax.network/specs/cryptographic-primitives): Overview of Avalanches cryptographic primitives focusing on it's use of TLS AND Secp256k1.


## Binance Smart Chain

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

Binanace Smart Chain (BSC) has similar signature schemes to Polygon but with a much smaller set of validators and some degree of random (yet predictable and deterministic) perturbation to the active validator set.

The consensus protocol is based on Parlia<sup>[19](#f19)</sup>, a variation that adds staking, validators, and elections to the proof-of-authority consensus protocol Clique, initially proposed in the Ethereum community. The protocol uses 21 validators for producing and signing blocks, with 19 of them picked from stakers with top voting power and 2 randomly chosen every 200 blocks <sup>[20](#f20)</sup>. Blocks are signed using ECDSA on secp256k1 curves, and block headers can be verified following the standard signature verification process<sup>[21](#f21)</sup>.

### Consensus Mechanism

Following is an excerpt from [Binance Consensus Engine documentation](https://github.com/bnb-chain/bnb-chain.github.io/blob/master/docs/learn/consensus.mdx)

> Although Proof-of-Work (PoW) has been recognized as a practical mechanism to implement a decentralized network, it is not friendly to the environment and also requires a large size of participants to maintain the security.
>
> Ethereum and some other blockchain networks, such as [MATIC Bor](https://github.com/maticnetwork/bor), [TOMOChain](https://tomochain.com/), [GoChain](https://gochain.io/), [xDAI](https://xdai.io/), do use [Proof-of-Authority(PoA)](https://en.wikipedia.org/wiki/Proof_of_authority) or its variants in different scenarios, including both testnet and mainnet. PoA provides some defense to 51% attack, with improved efficiency and tolerance to certain levels of Byzantine players (malicious or hacked). It serves as an easy choice to pick as the fundamentals.
>
> Meanwhile, the PoA protocol is most criticized for being not as decentralized as PoW, as the validators, i.e. the nodes that take turns to produce blocks, have all the authorities and are prone to corruption and security attacks. Other blockchains, such as EOS and Lisk both, introduce different types of [Delegated Proof of Stake (DPoS)](https://en.bitcoinwiki.org/wiki/DPoS) to allow the token holders to vote and elect the validator set. It increases the decentralization and favors community governance.
>
> BSC here proposes to combine DPoS and PoA for consensus, so that:
>
> 1. Blocks are produced by a limited set of validators
> 2. Validators take turns to produce blocks in a PoA manner, similar to [Ethereum's Clique](https://eips.ethereum.org/EIPS/eip-225) consensus design
> 3. Validator set are elected in and out based on a staking based governance
>
> The consensus protocol of BSC fulfills the following goals:
>
> 1. Short Blocking time, 3 seconds on mainnet.
> 2. It requires limited time to confirm the finality of transactions, around 45s for mainnet.
> 3. There is no inflation of native token: BNB, the block reward is collected from transaction fees, and it will be paid in BNB.
> 4. It is 100% compatible with Ethereum system .
> 5. It allows modern proof-of-stake blockchain network governance.

### Signing Mechanism

BSC uses the same signing mechanism as Ethereum 1.0.

Transactions are signed using recoverable ECDSA signatures. This method utilises the SECP-256k1 curve. (see the [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) Appendix F. Signing Transactions). go-ethereum utilizes the [secp256k1](https://github.com/bnb-chain/bsc/tree/master/crypto/secp256k1) package which wraps the bitcoin secp256k1 C library. Signing is handled by the [signer](https://github.com/bnb-chain/bsc/tree/master/signer) receives a request and produces a signature. Note, the produced signature conforms to the secp256k1 curve R, S and V values, where the V value will be 27 or 28 for legacy reasons, if legacyV==true.

**Signing**

* [Signature Documentation](https://docs.bnbchain.org/docs/beaconchain/learn/signature/): Binance overview of how transactions are signed using ECDSA curve Secp256k1.
* [secp256k1 codebase](https://github.com/ethereum/go-ethereum/tree/master/crypto/secp256k1): Binance secp256k1 crytpographic library (go)
* [secp256k1 Public Key](https://github.com/bnb-chain/bsc/blob/03ff2992ab4674c1df8f568ee9a31596f3503c26/crypto/signature_cgo.go#L32): Binance codebase(go) recovering the uncompressed secp256k1 key that created a given signature.

### Code Review

The Binance Smart chain is cloned from [Ethereum 1.0](./ethereum-1-0.mdx) and thus the majority of code incuding primitives, signing are similar. The key addtions are

* [Consensus - Parlia](https://github.com/bnb-chain/bsc/tree/master/consensus/parlia)
* [systemcontracts](https://github.com/bnb-chain/bsc/tree/master/core/systemcontracts)
* [Mobile](https://github.com/bnb-chain/bsc/tree/master/mobile): Outdated library.

Some ommissions include the majority of work done for Ethereum 2.0 for example BSC has no [beacon/engine](https://github.com/ethereum/go-ethereum/tree/master/beacon/engine).

### References

**Consensus**

* [Parlia Documentation](https://docs.bnbchain.org/docs/learn/consensus/#parlia): Binance Consensus Engine Parlia Documentation
* [Consenus Engine Codebase](https://github.com/bnb-chain/bsc/blob/master/consensus/consensus.go): Binance algorithm agnostic consensus engine. (go)
* [Parlia Consensus Codebase](https://github.com/bnb-chain/bsc/blob/master/consensus/parlia/parlia.go): Binance Parlia codebase (go)
* [Clique Consensus Codebase](https://github.com/bnb-chain/bsc/blob/master/consensus/clique/clique.go): Clique implements the proof-of-authority consensus engine (go). It is what Parlia was based of.
* [Parlia Consensus Verify Seal](https://github.com/bnb-chain/bsc/blob/master/consensus/parlia/parlia.go#L546): Binance seal verification codebase (go). *verifySeal checks whether the signature contained in the header satisfies the consensus protocol requirements. The method accepts an optional list of parent headers that aren't yet part of the local blockchain to generate the snapshots from. The transition rule is described in the eth1/2 merge spec EIP-3675.*
* [EIP-3675: Upgrade consensus to Proof-of-Stake](https://eips.ethereum.org/EIPS/eip-3675): Specification of the consensus mechanism upgrade on Ethereum Mainnet that introduces Proof-of-Stake.

**Staking**

* [BNB Staking Economics](https://docs.bnbchain.org/docs/stake/Staking/#staking-economics): Binance Staking Documentation
* [BNB Chain Staking](https://www.bnbchain.org/en/staking): Binance Staking App

**Additional**

<a name="f19">\[19]</a> See [BSC Consensus Engine
documentations](https://docs.bnbchain.org/docs/learn/consensus/#consensus-protocol)

<a name="f20">\[20]</a> Following BEP-131, see a
[summary](https://www.bnbchain.org/en/blog/bep131-introducing-candidate-validators-bnb-smart-chain/)
and [detailed specifications](https://github.com/bnb-chain/BEPs/pull/131). Note
that the proportion of randomly selected validators may increase, as proposed in
the BEP.

<a name="f21">\[21]</a> See
[code](https://github.com/bnb-chain/bsc/blob/cb9e50bdf62c6b46a71724066d39f9851181a5af/consensus/parlia/parlia.go#L546)
for full procedure and how ecrecover is used for signature verification.

* [State of BNB Chain Q4 2022](https://messari.io/report/state-of-bnb-chain-q4-2022)


## Cosmos

-date: 2023-02-04

* last updated: 2023-02-04

### Overview

Cosmos is the hub to almost 50 blockchains based on the Tendermint consensus engine and Inter-Blockchain Communication (IBC) protocol. It is also one of the earliest proponents for cross-chain communication and defined the first set of communication specificiations<sup>[24](#f24)</sup>. From a purely technical point of view, the signature scheme for signing blocks, Ed25519, is also often used in many other protocols, such as NEAR.

Cosmos Hub itself has 175 validators<sup>[25](#f25)</sup> and is built upon Tendermint, in which validators sign blocks using EdDSA on Curve25519 (i.e., Ed25519)<sup>[26](#f26)</sup>.

### Consensus Mechanism

For a deep dive on Tendemints Consensus, please read [The latest gossip on BFT consensus](https://arxiv.org/pdf/1807.04938.pdf): The paper presents Tendermint, a new protocol for ordering events in a distributed network under adversarial conditions.

Following is an excerpt from [What is Tendermint](https://github.com/tendermint/tendermint/blob/main/docs/introduction/what-is-tendermint.mdx)

> Tendermint is an easy-to-understand, mostly asynchronous, BFT consensus protocol. The protocol follows a simple state machine that looks like this:

![consensus-logic](/assets/research/tendermint_consensus_logic.png)

> Participants in the protocol are called **validators**; they take turns proposing blocks of transactions and voting on them. Blocks are committed in a chain, with one block at each **height**. A block may fail to be committed, in which case the protocol moves to the next **round**, and a new validator gets to propose a block for that height. Two stages of voting are required to successfully commit a block; we call them **pre-vote** and **pre-commit**. A block is committed when more than 2/3 of validators pre-commit for the same block in the same round.

> There is a picture of a couple doing the polka because validators are doing something like a polka dance. When more than two-thirds of the validators pre-vote for the same block, we call that a **polka**. Every pre-commit must be justified by a polka in the same round.

> Validators may fail to commit a block for a number of reasons; the current proposer may be offline, or the network may be slow. Tendermint allows them to establish that a validator should be skipped. Validators wait a small amount of time to receive a complete proposal block from the proposer before voting to move to the next round. This reliance on a timeout is what makes Tendermint a weakly synchronous protocol, rather than an asynchronous one. However, the rest of the protocol is asynchronous, and validators only make progress after hearing from more than two-thirds of the validator set. A simplifying element of Tendermint is that it uses the same mechanism to commit a block as it does to skip to the next round.

> Assuming less than one-third of the validators are Byzantine, Tendermint guarantees that safety will never be violated - that is, validators will never commit conflicting blocks at the same height. To do this it introduces a few **locking** rules which modulate which paths can be followed in the flow diagram. Once a validator precommits a block, it is locked on that block. Then,

> 1. it must prevote for the block it is locked on
> 2. it can only unlock, and precommit for a new block, if there is a polka for that block in a later round

### Signing Mechanism

Below is an excerpt from [Tendermint Specification](https://github.com/tendermint/tendermint/blob/main/spec/core/encoding.md#public-key-cryptography)

> Tendermint uses Protobuf [Oneof](https://protobuf.dev/programming-guides/proto3/#oneof) to distinguish between different types public keys, and signatures. Additionally, for each public key, Tendermint defines an Address function that can be used as a more compact identifier in place of the public key.
>
> #### Key Types
>
> Each type specifies it's own pubkey, address, and signature format.
>
> ##### Ed25519
>
> The address is the first 20-bytes of the SHA256 hash of the raw 32-byte public key:
>
> ```go
> address = SHA256(pubkey)[:20]
> ```
>
> The signature is the raw 64-byte ED25519 signature.
>
> Tendermint adopted [zip215](https://zips.z.cash/zip-0215) for verification of ed25519 signatures.
>
> Note: This change will be released in the next major release of Tendermint-Go (0.35).

##### Secp256k1

The address is the first 20-bytes of the SHA256 hash of the raw 32-byte public key:

```go
address = SHA256(pubkey)[:20]
```

Following is an excerpt from [Tendermint docs: Validator Keys](https://docs.tendermint.com/v0.34/tendermint-core/validators.html#)

> Currently Tendermint uses Ed25519 (opens new window)keys which are widely supported across the security sector and HSMs.

### Code Review

#### Signing

* [ed25519](https://github.com/tendermint/tendermint/tree/main/crypto/ed25519): Sign produces a signature on the provided message. This assumes the privkey is wellformed in the golang format. The first 32 bytes should be random, corresponding to the normal ed25519 private key. The latter 32 bytes should be the compressed public key. If these conditions aren't met, Sign will panic or produce an incorrect signature.
* [secp256k1](https://github.com/tendermint/tendermint/tree/main/crypto/secp256k1)
* [sr25519](https://github.com/tendermint/tendermint/tree/main/crypto/sr25519)
* [codec.go](https://github.com/tendermint/tendermint/blob/main/crypto/encoding/codec.go): Tranforms protobuf publick key to crypto public keys and vice versa. Support secp256k1 and edd25519.

#### Consensus

* [consensus](https://github.com/tendermint/tendermint/tree/main/consensus)
  * [state](https://github.com/tendermint/tendermint/blob/main/consensus/state.go): State handles execution of the consensus algorithm. It processes votes and proposals, and upon reaching agreement, commits blocks to the chain and executes them against the application. The internal state machine receives input from peers, the internal validator, and from a timer.

#### Cryptographic Primitives

**general primitives**

* [bits](https://github.com/tendermint/tendermint/tree/main/libs/bits): BitArray is a thread-safe implementation of a bit array.
* [bytes](https://github.com/tendermint/tendermint/tree/main/libs/bytes): Byte functions including marshalling and unmarshalling into JSON as well as fingerprint which returns the first 6 bytes of a byte slice.
* [clist](https://github.com/tendermint/tendermint/tree/main/libs/clist): provide a goroutine-safe linked-list. This list can be traversed concurrently by any number of goroutines. However, removed CElements cannot be added back.
* [cmap](https://github.com/tendermint/tendermint/tree/main/libs/cmap): a goroutine-safe map
* [flowrate](https://github.com/tendermint/tendermint/tree/main/libs/flowrate): provides the tools for monitoring and limiting the flow rate of an arbitrary data stream.
* [json](https://github.com/tendermint/tendermint/tree/main/libs/json): provides functions for marshaling and unmarshaling JSON in a format that is backwards-compatible with Amino JSON encoding. This mostly differs from encoding/json in encoding of integers (64-bit integers are encoded as strings, not numbers), and handling of interfaces (wrapped in an interface object with type/value keys).
* [math](https://github.com/tendermint/tendermint/tree/main/libs/math): math functions including fractions and safemath.
* [pubsub](https://github.com/tendermint/tendermint/tree/main/libs/pubsub): implements a pub-sub model with a single publisher (Server) and multiple subscribers (clients).
* [strings](https://github.com/tendermint/tendermint/tree/main/libs/strings): string manipulation functions.

**hash functions**

* [tmhash](https://github.com/tendermint/tendermint/blob/main/crypto/tmhash/hash.go): Tendermint implementation of SHA256 hash.
* [hash](https://github.com/tendermint/tendermint/blob/main/crypto/hash.go): included in tmhash.

**encryption**

* [armor](https://github.com/tendermint/tendermint/blob/main/crypto/armor/armor.go): implementation of [OpenPGP ASCII Armor](https://www.rfc-editor.org/rfc/rfc4880.html).
* [xchacha20poly1305](https://github.com/tendermint/tendermint/tree/main/crypto/xchacha20poly1305): Tendermint implementation of [ChaCha20-Poly1305](https://en.wikipedia.org/wiki/ChaCha20-Poly1305) an authenticated encryption with additional data (AEAD) algorithm, that combines the ChaCha20 stream cipher with the Poly1305 message authentication code.
* [xsalsa20symmetric](https://github.com/tendermint/tendermint/tree/main/crypto/xsalsa20symmetric): Tendermint implementation of [Salsa20](https://en.wikipedia.org/wiki/Salsa20).

**random number generators**

* [random.go](https://github.com/tendermint/tendermint/blob/main/crypto/random.go): only uses the OS's randomness. CRandHex returns a hex encoded string that's floor(numDigits/2) \*2 long.\*Note: CRandHex(24) gives 96 bits of randomness that are usually strong enough for most purposes.\*
* [rand](https://github.com/tendermint/tendermint/tree/main/libs/rand): prng, that is seeded with OS randomness. The OS randomness is obtained from crypto/rand, however none of the provided methods are suitable for cryptographic usage. They all utilize math/rand's prng internally. All of the methods here are suitable for concurrent use. This is achieved by using a mutex lock on all of the provided methods.

**serilization/deserialization**

### References

**Consensus**

* [Tendermint Byzantine Consensus Algorithm Specification](https://github.com/tendermint/tendermint/blob/main/spec/consensus/consensus.mdx): Specification for Tendermints Consensus including state machine, background gossip (messaging) and proofs.
* [Tendermint Consensus Overview](https://docs.tendermint.com/v0.34/introduction/what-is-tendermint.html#consensus-overview): Tendermint Consensus Overview Documentation.
* [Proposer Selection Procedure Specification](https://github.com/tendermint/tendermint/blob/main/spec/consensus/proposer-selection.mdx): Specifies the Proposer Selection Procedure that is used in Tendermint to choose a round proposer for its "leader-based-protocol".

**Signing**

* [Ed25519: high-speed high-security signatures](https://ed25519.cr.yp.to/): Ed25519 Signature Information
  * [High-speed high-security signatures](https://ed25519.cr.yp.to/ed25519-20110926.pdf): Paper introducing Ed25519 signatures
* [Tendermint Validator Keys](https://docs.tendermint.com/v0.34/tendermint-core/validators.html): Tendermint Documentation highlighting the use of Ed25519 keys for validators.
* [Tendermint Public Key Cryptography](https://github.com/tendermint/tendermint/blob/main/spec/core/encoding.md#public-key-cryptography): Documenation on Tendermints Public Key Cryptography.
* [Tendermint Crypto Code Base](https://github.com/tendermint/tendermint/tree/main/crypto): crypto is the cryptographic package adapted for Tendermint's uses (go)
  * [key.go](https://github.com/tendermint/tendermint/blob/main/p2p/key.go#L50): Tendermint Validator Key Management(go). *LoadOrGenNodeKey attempts to load the NodeKey from the given filePath. If the file does not exist, it generates and saves a new NodeKey.*
  * [ed25519.go](https://github.com/maticnetwork/tendermint/blob/peppermint/crypto/ed25519/ed25519.go): Used for signing messages with an ed25519 private key.

**Light Client**

* [Light Client](https://docs.tendermint.com/v0.34/tendermint-core/light-client.html): he objective of the light client protocol is to get a commit for a recent block hash where the commit includes a majority of signatures from the last known validator set. From there, all the application state is verifiable with [merkle proofs](https://github.com/tendermint/spec/blob/master/spec/core/encoding.md#iavl-tree).
* [tendermint light package](https://pkg.go.dev/github.com/tendermint/tendermint/light)(go): Tendermint light clients allow bandwidth & compute-constrained devices, such as smartphones, low-power embedded chips, or other blockchains to efficiently verify the consensus of a Tendermint blockchain. This forms the basis of safe and efficient state synchronization for new network nodes and inter-blockchain communication (where a light client of one Tendermint instance runs in another chain's state machine). ([tendermint light source code](https://github.com/tendermint/tendermint/tree/main/light)(go)).

**Serialization/DeSerialization**

* [Tendermint has four serialization protocols](https://github.com/tendermint/tendermint/issues/608)

**Staking**

**Additional**

<a name="f24">\[24]</a> See [Cosmos IBC
documentation](https://tutorials.cosmos.network/academy/3-ibc/1-what-is-ibc.html)

<a name="f25">\[25]</a> See [Cosmos Hub
overview](https://hub.cosmos.network/main/validators/overview.html)

<a name="f26">\[26]</a> See [Tendermint Core
documentation](https://docs.tendermint.com/v0.34/tendermint-core/validators.html#validator-keys)


## Ethereum 1.0

date: 2023-02-04
last-updated: 2023-02-04

### Overview

### Consensus Mechanism

#### Ethereum 1.0 Proof Of Work

> Existing Blockchain technology is working on the core concept of 'Proof Of Work' (POW). A proof-of-work (PoW) is a protocol that is difficult to compute but easy to verify. It can be verified in far less time than it took to compute in first place. The process involves scanning for a value that when hashed, (such as with SHA-256), the hash begins with a number of zero bits. The average work required is exponential in the number of zero bits required and can be verified by executing a single hash. In simple words, Proof of work is an expensive computation done by all miners to compete to find a number that, when added to the block of transactions, causes this block to hash to a code with certain rare properties. Finding such a rare number is hard (based on the cryptographic features of the hash function used in this process), but verifying its validity when it's found is relatively easy. One can take the challenge, the proof string and hash them together and check if the hash begins with a number of zero bits. This requires to apply the hash function just once and verify the output indeed has requisite numbers of 0's in front. If so, then the proof of work is considered valid under the application of that cryptographic hash function. Every block in the participating network should contain such rare number.

![Proof Of Work](/assets/research/pow.png "Proof Of Work")

Block Structure from [go-ethereum](https://github.com/ethereum/go-ethereum/blob/release/1.9/consensus/ethash/consensus.go)

```
// SealHash returns the hash of a block prior to it being sealed.
func (ethash *Ethash) SealHash(header *types.Header) (hash common.Hash) {
 hasher := sha3.NewLegacyKeccak256()

 rlp.Encode(hasher, []interface{}{
  header.ParentHash,
  header.UncleHash,
  header.Coinbase,
  header.Root,
  header.TxHash,
  header.ReceiptHash,
  header.Bloom,
  header.Difficulty,
  header.Number,
  header.GasLimit,
  header.GasUsed,
  header.Time,
  header.Extra,
 })
 hasher.Sum(hash[:0])
 return hash
}
```

### Signing Mechanism

Transactions are signed using recoverable ECDSA signatures. This method utilises the SECP-256k1 curve. (see the [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf) Appendix F. Signing Transactions). go-ethereum utilizes the [secp256k1](https://github.com/ethereum/go-ethereum/tree/master/crypto/secp256k1) package which wraps the bitcoin secp256k1 C library. Signing is handled by the [signer](https://github.com/ethereum/go-ethereum/tree/master/signer) receives a request and produces a signature. Note, the produced signature conforms to the secp256k1 curve R, S and V values, where the V value will be 27 or 28 for legacy reasons, if legacyV==true.

### Code Review

#### Signing

* [bls12381](https://github.com/ethereum/go-ethereum/tree/master/crypto/bls12381): BLS12-381 is a pairing-friendly elliptic curve.
* [bn256](https://github.com/ethereum/go-ethereum/tree/master/crypto/bn256): Package bn256 implements the Optimal Ate pairing over a 256-bit Barreto-Naehrig curve. ([insecure](https://moderncrypto.org/mail-archive/curves/2016/000740.html))
* [secp256k1](https://github.com/ethereum/go-ethereum/tree/master/crypto/secp256k1): Package secp256k1 wraps the bitcoin secp256k1 C library.
* [signer](https://github.com/ethereum/go-ethereum/tree/master/signer): sign receives a request and produces a signature. Note, the produced signature conforms to the secp256k1 curve R, S and V values, where the V value will be 27 or 28 for legacy reasons, if legacyV==true.

#### Consensus

* [consensus](https://github.com/ethereum/go-ethereum/tree/master/consensus)
  * [algorithm](https://github.com/ethereum/go-ethereum/blob/master/consensus/ethash/algorithm.go): hashimoto aggregates data from the full dataset in order to produce our final value for a particular header hash and nonce.
  * [api](https://github.com/ethereum/go-ethereum/blob/master/consensus/ethash/api.go): API's include GetWork, SubmitWork, SubmitHashRate and GetHashRate.
  * [ethhash](https://github.com/ethereum/go-ethereum/tree/master/consensus): Package ethash implements the ethash proof-of-work consensus engine.
  * [sealer](https://github.com/ethereum/go-ethereum/blob/master/consensus/ethash/sealer.go): Seal implements consensus.Engine, attempting to find a nonce that satisfies the block's difficulty requirements.
* Additional Consensus Engines
  * [beacon](https://github.com/ethereum/go-ethereum/tree/master/consensus/beacon): Beacon is a consensus engine that combines the eth1 consensus and proof-of-stake algorithm. There is a special flag inside to decide whether to use legacy consensus rules or new rules. The transition rule is described in the eth1/2 merge spec[EIP-3675](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-3675.mdx). The beacon here is a half-functional consensus engine with partial functions which is only used for necessary consensus checks. The legacy consensus engine can be any engine implements the consensus interface (except the beacon itself).
  * [clique](https://github.com/ethereum/go-ethereum/blob/master/consensus/clique/clique.go): Package clique implements the proof-of-authority consensus engine.

#### Cryptographic Primitives

**general primitives**

* [asm](https://github.com/ethereum/go-ethereum/tree/master/core/asm): Package asm provides support for dealing with EVM assembly instructions (e.g., disassembling them).
* [bitutil](https://github.com/ethereum/go-ethereum/tree/master/common/bitutil): Package bitutil implements fast bitwise operations.
* [bloombits](https://github.com/ethereum/go-ethereum/tree/master/core/bloombits): Package bloombits implements bloom filtering on batches of data.
* [forkid](https://github.com/ethereum/go-ethereum/tree/master/core/forkid): Package forkid implements [EIP-2124](https://eips.ethereum.org/EIPS/eip-2124).
* [hexutil](https://github.com/ethereum/go-ethereum/tree/master/common/hexutil): Package hexutil implements hex encoding with 0x prefix. This encoding is used by the Ethereum RPC API to transport binary data in JSON payloads.
* [lru](https://github.com/ethereum/go-ethereum/tree/master/common/lru): Package lru implements generically-typed Least Recently Used(LRU) caches.
* [math](https://github.com/ethereum/go-ethereum/tree/master/common/math): Package math provides integer math utilities.
* [mclock](https://github.com/ethereum/go-ethereum/tree/master/common/mclock): Package mclock is a wrapper for a monotonic clock source
* [prque](https://github.com/ethereum/go-ethereum/tree/master/common/prque):Package prque implements a priority queue data structure supporting arbitrary value types and int64 priorities.
* [trie](https://github.com/ethereum/go-ethereum/tree/master/trie): Package trie implements Merkle Patricia Tries.

**hash functions**

* [blake2b](https://github.com/ethereum/go-ethereum/tree/master/crypto/blake2b) (go): Package blake2b implements the BLAKE2b hash algorithm defined by RFC 7693 and the extendable output function (XOF) BLAKE2Xb.

**encryption**

* [signify](https://github.com/ethereum/go-ethereum/tree/master/crypto/signify): signFile reads the contents of an input file and signs it (in armored format) with the key provided, placing the signature into the output file.[ascii armored encryption](https://www.rfc-editor.org/rfc/pdfrfc/rfc4880.txt.pdf)
* [ecies](https://github.com/ethereum/go-ethereum/tree/master/crypto/ecies): a hybrid encryption scheme

**random number generators**

**serilization/deserialization**

* [RLP](https://github.com/ethereum/go-ethereum/tree/master/rlp): Package rlp implements the RLP serialization format.([doc](https://github.com/ethereum/go-ethereum/blob/master/rlp/doc.go)) The purpose of RLP (Recursive Linear Prefix) is to encode arbitrarily nested arrays of binary data, and RLP is the main encoding method used to serialize objects in Ethereum.
  The only purpose of RLP is to encode structure; encoding specific atomic data types (eg.
  strings, ints, floats) is left up to higher-order protocols. In Ethereum integers must be
  represented in big endian binary form with no leading zeroes (thus making the integer
  value zero equivalent to the empty string). RLP values are distinguished by a type tag. The type tag precedes the value in the input stream and defines the size and kind of the bytes that follow.

**threading**

**virtual machine**

* [vm](https://github.com/ethereum/go-ethereum/tree/master/core/vm) : Package vm implements the Ethereum Virtual Machine. The vm package implements one EVM, a byte code VM. The BC (Byte Code) VM loops over a set of bytes and executes them according to the set of rules defined in the Ethereum yellow paper.

**compiler**

* [compiler](https://github.com/ethereum/go-ethereum/tree/master/common/compiler): Package compiler wraps the ABI compilation outputs. ParseCombinedJSON takes the direct output of a solc --combined-output run and parses it into a map of string contract name to Contract structs. The provided source, language and compiler version, and compiler options are all passed through into the Contract structs. The solc output is expected to contain ABI, source mapping, user docs, and dev docs. Returns an error if the JSON is malformed or missing data, or if the JSON embedded within the JSON is malformed.

### References

**Consensus**

* [Proof of Work (POW), Ethereum Org, 2022](https://ethereum.org/en/developers/docs/consensus-mechanisms/pow/): Ethereum Proof of Work Documentation.

* [Proof Of Work (POW), EtherWorld 2017](https://etherworld.co/2017/04/16/proof-of-work-pow/): Etherworld Proof of Work Guide.

* [EIP-1057: ProgPoW, a Programmatic Proof-of-Work](https://eips.ethereum.org/EIPS/eip-1057): ProgPoW is a proof-of-work algorithm designed to close the efficiency gap available to specialized ASICs.

* [consensus go-ethereum: release 1.9 (codebase)](https://github.com/ethereum/go-ethereum/blob/release/1.9/consensus/consensus.go): Engine is an algorithm agnostic consensus engine. (go)

* [ethash.go, go-ethereum release 1.9 (codebase)](https://github.com/ethereum/go-ethereum/blob/release/1.9/consensus/ethash/ethash.go): Package ethash implements the ethash proof-of-work consensus engine. (go)

* [ethash.sol, horizon (codebase)](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/ethash/ethash.sol): Solidity implementation enableing the verification of ethhash (solidity)

* [ethash.rs, parity-ethereum (codebase)](https://github.com/openethereum/parity-ethereum/blob/v2.7.2-stable/ethash/src/lib.rs): EthashManager implementation by parity (rust).

* [progpow.ps, parity-ethereum (codebase)](https://github.com/openethereum/parity-ethereum/blob/v2.7.2-stable/ethash/src/progpow.rs): EthHash implementation by parity for ASICs (rust). *ProgPoW (Programmatic Proof-of-Work) is the Ethereum network's proposed new Application-Specific Integrated Circuit (ASIC) resistant Proof-of-Work mining algorithm.*

**Staking**

**Additional**

* [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf):
* [Ethereum EVM illustrated](https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf): A technical overview of Ethereum including state, accounts, transactions and messages as well as the EVM. [Appendix E](#appendix-e-data-structures) has links to type definitions for blocks, transactions, state etc in geth.


## Ethereum

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

With the Introduction of Ethereum 2.0<sup>[1](#bp1)</sup> <sup>[2](#bp2)</sup> <sup>[3](#bp3)</sup> block production and consensus were separated<sup>[4](#bp4)</sup> into execution clients<sup>[5](#bp5)</sup> and consensus clients<sup>[6](#ts6)</sup> <sup>[7](#bp7)</sup>.

The execution chain implemented a simplified Proof of Work<sup>[1](#bp1)</sup> reducing difficutly to zero and removing the need for omners (uncles) which would now be handled by the beacon chain<sup>[3](#bp3)</sup> which is responsible for providing consensus <sup>[2](#bp2)</sup>.

Light Clients<sup>[11](#ts11)</sup> were also introduced. To facilate this
a sync committee of 512 current validators is elected every 255 epochs, approximately every 27 hours (see [sample sync comittee data](#sync-committee-latest)), they are responsible for signing each block.

As at December 11th, 2022 Ethereum has 487,920 validators<sup>[8](#bp8)</sup> with a sample epoch ([166581](https://beaconcha.in/epoch/166581)) and slot ([5,330,592](https://beaconcha.in/slot/5330592)) having [139 transactions](https://beaconcha.in/slot/5330592#transactions) with [19,227 votes](https://beaconcha.in/slot/5330592#votes) from 63 committees and [126 aggregated committe attestations](https://beaconcha.in/slot/5330592#attestations).

Here is more information on the upgrade<sup>[9](#bp9)</sup> and the roadmap<sup>[10](#bp10)</sup>

![Ethereum Roadmap](/assets/research/ethereum-roadmap.jpg "Ethereum Roadmap")

### Consensus Mechanism

Ethreum uses Proof of Stake (PoS). Here we give an overview of Proof of Stake Followed by a deep dive into synch committees.
Following is an excerpt from [Ethereum Orgs Proof of Stake document](Proof-of-stake "PoS")

> **What is proof-of-stake (PoS)?**

> Proof-of-stake underlies certain consensus mechanisms used by blockchains to achieve distributed consensus. In proof-of-work, miners prove they have capital at risk by expending energy. Ethereum uses proof-of-stake, where validators explicitly stake capital in the form of ETH into a smart contract on Ethereum. This staked ETH then acts as collateral that can be destroyed if the validator behaves dishonestly or lazily. The validator is then responsible for checking that new blocks propagated over the network are valid and occasionally creating and propagating new blocks themselves.

> Proof-of-stake comes with a number of improvements to the now-deprecated proof-of-work system:

> * better energy efficiency – there is no need to use lots of energy on proof-of-work computations
> * lower barriers to entry, reduced hardware requirements – there is no need for elite hardware to stand a chance of creating new blocks
> * reduced centralization risk – proof-of-stake should lead to more nodes securing the network
> * because of the low energy requirement less ETH issuance is required to incentivize participation
> * economic penalties for misbehaviour make 51% style attacks exponentially more costly for an attacker compared to proof-of-work
> * the community can resort to social recovery of an honest chain if a 51% attack were to overcome the crypto-economic defenses.

#### Block Production

Validators run both an Ethereum 1 client (e.g. geth) and a Beacon Chain Client (e.g. prysm). The geth client recieves transactions and places them into blocks. For additional details see the Ethereum Builder Specs<sup>[12](#ts12)</sup>. The following diagrams give an overview of how blocks are proposed and how MEV Boost<sup>[13](#ts13)</sup> could be integrated. For simplification we can replace mev\_boost and relay with geth in the block proposal diagram as the majority of validators simply run a geth node.

![Block Proposal](/assets/research/block-proposal.png "Block Proposal")

#### Slots and Epochs <sup>[6](#ts6a)</sup>

> The Beacon Chain provides the heartbeat to Ethereum’s consensus. Each slot is 12 seconds and an epoch is 32 slots: 6.4 minutes.

![Slots and Epochs](/assets/research/Beacon-Chain-Slots-and-Epochs.png.webp "Slots and Epochs")

#### Block Proposals

When a validator is nominated as a proposer for a slot in an Epoch they propose a block gathered from there Ethereum 1 client.

This proposed block is attested to by other validators who have been assigned as committe members for this slot<sup>[6b](#ts6b)</sup>.

> A block proposer is a validator that has been pseudorandomly selected to build a block.
>
> Most of the time, validators are attesters that vote on blocks. These votes are recorded in the Beacon Chain and determine the head of the Beacon Chain.

![Validators and Attestations](/assets/research/Beacon-Chain-Validators.png "Validators and Attestations")

#### Committees

> A committee is a group of validators. For security, each slot has committees of at least 128 validators. An attacker has less than a one in a trillion probability of controlling ⅔ of a committee.
>
> The concept of a randomness beacon that emits random numbers for the public, lends its name to the Ethereum Beacon Chain. The Beacon Chain enforces consensus on a pseudorandom process called RANDAO.

![Committees](/assets/research/Beacon-Chain-RANDAO.png "Committees")

#### Attestations

The attestation lifecyle<sup>[9](#ts9)</sup> involves

1. Generation of the proposed Block
2. Propagation of the block to committee members to vote on and sign
3. Aggregation of the votes (signatures) of the committee members by Aggregators
4. Propagation of the aggregated attestations back to the block Proposer
5. Inclusion of the block in the Beaconchain

![Attestation Life Cycle](/assets/research/AttestationLifeCycle.png "Attestation Life Cycle")

#### Checkpoints and Finality<sup>[6](#ts6)</sup>

> When an epoch ends, if its checkpoint has garnered a ⅔ supermajority, the checkpoint gets justified.

![Checkpoints](/assets/research/Beacon-Chain-Checkpoints.jpg "Checkpoints")

> If a checkpoint B is justified and the checkpoint in the immediate next epoch becomes justified, then B becomes finalized. Typically, a checkpoint is finalized in two epochs, 12.8 minutes.

![Finality](/assets/research/Beacon-Chain-Justification-and-Finalization.png "Finality")

#### Sync Committee <sup>[10](#ts10)</sup>

A sync committee of 512 current validators is elected every 255 epochs, approximately every 27 hours (see [sample sync comittee data](#sync-committee-latest)).
They are responsible for signing each block which records which sync committee members (validtors) signed the block, held in `syncaggregate_bits`, and creates a bls aggregate signature held in `syncaggregate_signature` (see [block-data](#block-data-for-slot-5330592)).

```
    "syncaggregate_bits": "0xdffffffffffffffffffffffffffffff7fffffffffffffffffffffffffffffffffffffffffffffffffffffffdfffffffffffffffdffffffffffffffffffffffff",
    "syncaggregate_participation": 0.9921875,
    "syncaggregate_signature": "0x95332c55790018eed3d17eada01cb4045348d09137505bc8697eeedaa3800a830ee2c138251850a9577f62a5488419ef0a722579156a177fb3a147017f1077af5d778f46a4cdf815fc450129d135fe5286e16df68333592e4aa45821bde780dd",
```

This is used in Altair Light Client -- Sync Protocol<sup>[11](#ts11)</sup> which enables the beacon chain to be light client friendly for constrained environments to access Ethereum.

#### Validator Lifecycle

Following is an overview of statuses for validators in Ethereum 2.0 phase 0 <sup>[14](#ts14)</sup>.

> 1. **Deposited**: the validator has made a deposit and has registered in BeaconState.
> 2. **Eligible to be activated (Pending)**: the validator is eligible to be activated.
> 3. **Activated**: the validator is activated
>    * *Note that the validator may be “eligible to be activated, but has not been activated yet”.*
> 4. **Slashed**: the validator has been slashed
> 5. **Exited**: the validator is exited
> 6. **Withdrawable**: the validator is withdrawable
>    * *Note that the validator will be able to withdraw to EEs in phase 2*
>
> *Note that in some cases, a validator can be in multiple statuses at the same time, e.g., an active validator may be “activated and slashed”.*

![Validator Status Transition](/assets/research/ValidatorStateTransition.png "Validator Status Transition")

### Light Client Support

**Light client state updates**

* A light client receives objects of type `LightClientUpdate`, `LightClientFinalityUpdate` and `LightClientOptimisticUpdate`:
  * **`update: LightClientUpdate`**: Every `update` triggers `process_light_client_update(store, update, current_slot, genesis_validators_root)` where `current_slot` is the current slot based on a local clock.
  * **`finality_update: LightClientFinalityUpdate`**: Every `finality_update` triggers `process_light_client_finality_update(store, finality_update, current_slot, genesis_validators_root)`.
  * **`optimistic_update: LightClientOptimisticUpdate`**: Every `optimistic_update` triggers `process_light_client_optimistic_update(store, optimistic_update, current_slot, genesis_validators_root)`.
* `process_light_client_store_force_update` MAY be called based on use case dependent heuristics if light client sync appears stuck.

**validate\_light\_client\_update**

```python
def validate_light_client_update(store: LightClientStore,
                                 update: LightClientUpdate,
                                 current_slot: Slot,
                                 genesis_validators_root: Root) -> None:
    # Verify sync committee has sufficient participants
    sync_aggregate = update.sync_aggregate
    assert sum(sync_aggregate.sync_committee_bits) >= MIN_SYNC_COMMITTEE_PARTICIPANTS

    # Verify update does not skip a sync committee period
    assert is_valid_light_client_header(update.attested_header)
    update_attested_slot = update.attested_header.beacon.slot
    update_finalized_slot = update.finalized_header.beacon.slot
    assert current_slot >= update.signature_slot > update_attested_slot >= update_finalized_slot
    store_period = compute_sync_committee_period_at_slot(store.finalized_header.beacon.slot)
    update_signature_period = compute_sync_committee_period_at_slot(update.signature_slot)
    if is_next_sync_committee_known(store):
        assert update_signature_period in (store_period, store_period + 1)
    else:
        assert update_signature_period == store_period

    # Verify update is relevant
    update_attested_period = compute_sync_committee_period_at_slot(update_attested_slot)
    update_has_next_sync_committee = not is_next_sync_committee_known(store) and (
        is_sync_committee_update(update) and update_attested_period == store_period
    )
    assert (
        update_attested_slot > store.finalized_header.beacon.slot
        or update_has_next_sync_committee
    )

    # Verify that the `finality_branch`, if present, confirms `finalized_header`
    # to match the finalized checkpoint root saved in the state of `attested_header`.
    # Note that the genesis finalized checkpoint root is represented as a zero hash.
    if not is_finality_update(update):
        assert update.finalized_header == LightClientHeader()
    else:
        if update_finalized_slot == GENESIS_SLOT:
            assert update.finalized_header == LightClientHeader()
            finalized_root = Bytes32()
        else:
            assert is_valid_light_client_header(update.finalized_header)
            finalized_root = hash_tree_root(update.finalized_header.beacon)
        assert is_valid_merkle_branch(
            leaf=finalized_root,
            branch=update.finality_branch,
            depth=floorlog2(FINALIZED_ROOT_INDEX),
            index=get_subtree_index(FINALIZED_ROOT_INDEX),
            root=update.attested_header.beacon.state_root,
        )

    # Verify that the `next_sync_committee`, if present, actually is the next sync committee saved in the
    # state of the `attested_header`
    if not is_sync_committee_update(update):
        assert update.next_sync_committee == SyncCommittee()
    else:
        if update_attested_period == store_period and is_next_sync_committee_known(store):
            assert update.next_sync_committee == store.next_sync_committee
        assert is_valid_merkle_branch(
            leaf=hash_tree_root(update.next_sync_committee),
            branch=update.next_sync_committee_branch,
            depth=floorlog2(NEXT_SYNC_COMMITTEE_INDEX),
            index=get_subtree_index(NEXT_SYNC_COMMITTEE_INDEX),
            root=update.attested_header.beacon.state_root,
        )

    # Verify sync committee aggregate signature
    if update_signature_period == store_period:
        sync_committee = store.current_sync_committee
    else:
        sync_committee = store.next_sync_committee
    participant_pubkeys = [
        pubkey for (bit, pubkey) in zip(sync_aggregate.sync_committee_bits, sync_committee.pubkeys)
        if bit
    ]
    fork_version = compute_fork_version(compute_epoch_at_slot(update.signature_slot))
    domain = compute_domain(DOMAIN_SYNC_COMMITTEE, fork_version, genesis_validators_root)
    signing_root = compute_signing_root(update.attested_header.beacon, domain)
    assert bls.FastAggregateVerify(participant_pubkeys, signing_root, sync_aggregate.sync_committee_signature)
```

**apply\_light\_client\_update**

```python
def apply_light_client_update(store: LightClientStore, update: LightClientUpdate) -> None:
    store_period = compute_sync_committee_period_at_slot(store.finalized_header.beacon.slot)
    update_finalized_period = compute_sync_committee_period_at_slot(update.finalized_header.beacon.slot)
    if not is_next_sync_committee_known(store):
        assert update_finalized_period == store_period
        store.next_sync_committee = update.next_sync_committee
    elif update_finalized_period == store_period + 1:
        store.current_sync_committee = store.next_sync_committee
        store.next_sync_committee = update.next_sync_committee
        store.previous_max_active_participants = store.current_max_active_participants
        store.current_max_active_participants = 0
    if update.finalized_header.beacon.slot > store.finalized_header.beacon.slot:
        store.finalized_header = update.finalized_header
        if store.finalized_header.beacon.slot > store.optimistic_header.beacon.slot:
            store.optimistic_header = store.finalized_header
```

**Sample Implementation: NEAR Rainbow Bridge Ethereum Light Client Deployed on NEAR**

Bridging support was implemented by NEAR under [Eth2-to-Near-relay: prototype implementation #762
](https://github.com/aurora-is-near/rainbow-bridge/pull/762)

![Ethereum 2 block proof](/assets/posts/2023-02-05-ethereum-bridging-costs/ETH_2_0_MMR.jpg "Ethereum 2 Block Proof")

> When we send light client update for finality block inside light client update, we also send Eth1 execution block hash with the Merkle proof of include to Beacon Block Body. Execution block hash you can find at BeaconBlockBody.execution\_payload.block\_hash.
>
> So, for creating Merkle proof, we need two levels of Merkle Tree, as shown in the picture. Both Merkle trees you can find in beacon\_block\_body\_merkle\_tree.rs The first level Merkle tree for beacon block body and the second level Merkle tree for execution payload.
>
> The execution block hash proof creation you can find in execution\_block\_proof.rs First, we build two Merkle trees and concatenate together the Merkle proof for block\_hash in execution\_payload and the Merkle proof of execution\_payload in beacon\_block\_body. The final Merkle proof is shown by the orange vertices on the picture; the orange numbers in the picture are the order of hashes in the proof.
>
> beacon\_block\_header\_with\_execution\_data.rs contain a structure which consists of beacon\_block\_header and correspondent execution\_block\_hash with Merkle proof. This structure is created for finality blocks in a light client update.

### References

**Consensus**

* [Gasper Consensus Whitepaper](https://arxiv.org/pdf/2003.03052.pdf): Combining GHOST and Casper
* [sigp lighthouse beacon block](https://github.com/sigp/lighthouse/blob/stable/consensus/types/src/beacon_block.rs#L7): Beacon Block codebase (rust)

<a name="bp1">\[1]</a> [EIP-3675: Upgrade consensus to
Proof-of-Stake](https://eips.ethereum.org/EIPS/eip-3675#pow-block-processing):
Specification of the consensus mechanism upgrade on Ethereum Mainnet that
introduces Proof-of-Stake.

<a name="bp2">\[2]</a> [EIP-2982: Serenity Phase
0](https://eips.ethereum.org/EIPS/eip-2982): Phase 0 of the release schedule of
Serenity, a series of updates to Ethereum a scalable, proof-of-stake consensus.

<a name="bp3">\[3]</a> [Ethreum Consensus Specs Phase
0](https://github.com/ethereum/consensus-specs/tree/dev/specs/phase0):
Specifications for Ethereum 2.0 Phase 0 including
[beacon-chain](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.mdx),
[deposit-contract](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/deposit-contract.mdx),
[fork-choice](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/fork-choice.mdx),
[p2p-interface](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/p2p-interface.mdx),
[validator](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/validator.mdx)
and
[weak-subjectivity](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/weak-subjectivity.mdx)

<a name="bp4">\[6]</a> [Ethereum Consensus and Execution Client
Distribution](https://clientdiversity.org/#distribution): Percentages of nodes
running client types for both Consensus (Prysm, Lighthours, Nimbus, Teku) and
Execution (Geth, Erigon, Besu, Nethermind) clients.

<a name="bp5">\[5]</a> [go-ethereum go
documentation](https://pkg.go.dev/github.com/ethereum/go-ethereum@v1.10.26):
Documentation for Go Ethereum, Official Golang implementation of the Ethereum
protocol. Which is an execution chain implementation.

<a name="bp6">\[6]</a> [prysm go
documentation](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2):
Documentation for prysm, An Ethereum Consensus Implementation Written in Go. A
beacon-chain immplementation. Also see [Prysm
Documentation](https://docs.prylabs.network/docs/getting-started)

<a name="bp7">\[7]</a> [lighthouse
documentation](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2):
Documentation for lighthouse, written in Rust. A beacon-chain immplementation.

<a name="bp8">\[8]</a> [Etherum 2.0 Validators
Overview](https://beaconcha.in/validators): Live Monitoring of Ethreum 2.0
Validators from beachoncha.in

<a name="bp9">\[9]</a> [Upgrading Ethereum](https://eth2book.info/bellatrix/): A
technical handbook on Ethereum's move to proof of stake and beyond Edition 0.2:
Bellatrix \[WIP] by Ben Edgington.

<a name="bp10">\[9]</a> [Annotated Ethereum
Roadmap](https://notes.ethereum.org/@domothy/roadmap): an entry point for the
various items on the Ethereum roadmap, with a quick summary along with links for
those who want to dive deeper.

<a name="bp11">\[10]</a> [Shanghai/Capella
Upgrade](https://consensys.net/shanghai-capella-upgrade/): the first
simultaneous upgrade of Ethereum’s execution layer and consensus layer, and is
highly anticipated because it will enable staked ETH withdrawals.

**Signing**

* [sigp lighthouse bls signing](https://github.com/sigp/lighthouse/blob/stable/crypto/bls/src/lib.rs): BLS signing codebase (rust)

**Staking**

* [Ethereum Staking](https://ethereum.org/en/staking/): Staking User Interface
* [App Stakewise](https://app.stakewise.io/): Ethreeum Staking Application
* [PROOF-OF-STAKE (POS)](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/): Ethereum Proof of Stake Documentation

**References Technical Summary**

<a name="ts1">\[1]</a> [Ethereum EVM
illustrated](https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf):
A technical overview of Ethereum including state, accounts, transactions and
messages as well as the EVM. [Appendix E](#appendix-e-data-structures) has links
to type definitions for blocks, transactions, state etc in geth.

<a name="ts2">\[2]</a> [Blocks](https://ethereum.org/en/developers/docs/blocks/):
Block data definitions including attestations from ethereum.org

<a name="ts3">\[3]</a> [eth1 block
proposal](https://hackmd.io/@flashbots/mev-in-eth2#eth1-block-proposal):
Technical walkthrough of how blocks are proposed and potential MEV opportunities
from FlashBots.

<a name="ts4">\[4]</a> [Assemble
Block](https://github.com/ethereum/rayonism/blob/master/specs/merge.md#assemble-block):
Ethereum Specification for block Assembly as part of Rayonism -- The Merge spec.

<a name="ts5">\[5]</a> [Prysm running a
node](https://docs.prylabs.network/docs/install/install-with-script):
Operational procedures for Validators by Prysm. Note validators run both the
beacon chain(consensus) and a geth node(execution)

<a name="ts6">\[6]</a>[The Beacon Chain Ethereum 2.0 explainer you need to read
first](https://ethos.dev/beacon-chain): Detailed walk through og Ethereum 2.0
block production including slots, epochs, validators, commitees and finality.

<a name="ts6a">\[6]</a>[The Beacon Chain Ethereum 2.0 explainer you need to read
first](https://ethos.dev/beacon-chain): Detailed walk through og Ethereum 2.0
block production including slots, epochs, validators, commitees and finality.

<a name="ts6b">\[6]</a>[The Beacon Chain Ethereum 2.0 explainer you need to read
first](https://ethos.dev/beacon-chain): Detailed walk through og Ethereum 2.0
block production including slots, epochs, validators, commitees and finality.

<a name="ts7">\[7]</a> [Etherum 2.0 Validators
Overview](https://beaconcha.in/validators): Live Monitoring of Ethreum 2.0
Validators from beachoncha.in

<a name="ts8">\[8]</a>[BLS
Signatures](https://eth2book.info/bellatrix/part2/building_blocks/signatures/):
Detailed walkthrough of BLS Signatures and how they can be used in aggregation.

<a name="ts9">\[8]</a>[Attestation Inclusion
Lifecycle](https://kb.beaconcha.in/attestation#attestation-inclusion-lifecycle):
High Level overview of the attestation life cycle including geeration,
propogation, aggregation and inclusion.Attest

<a name="ts10">\[ts10]</a> [Beacon Chain Proposal: Sync
Comittees](https://notes.ethereum.org/@vbuterin/HF1_proposal#Sync-committees):
For each period (\~27 hours), 1024 validators are randomly selected to be part of
the sync committee during that period. Validators in the sync committee would
publish signatures attesting to the current head. These signatures would be
broadcasted as part of a LightClientUpdate object that could help light clients
find the head, and would be included in the beacon chain to be rewarded.

<a name="ts11">\[ts11]</a> [Altair Light Client -- Sync
Protocol](https://notes.ethereum.org/@vbuterin/HF1_proposal#Sync-committees):
This document suggests a minimal light client design for the beacon chain that
uses sync committees.

<a name="ts12">\[ts12]</a> [Ethereum Builder Specifications: Honest
Validator](https://github.com/ethereum/builder-specs/blob/main/specs/validator.mdx):
explains the way in which a beacon chain validator is expected to use the
Builder spec to participate in an external builder network.

<a name="ts13">\[ts13]</a> [Flashbots:
mev-boost](https://github.com/flashbots/mev-boost): open source middleware run
by validators to access a competitive block-building market.

<a name="ts14">\[ts14]</a> [A note on Ethereum 2.0 phase 0 validator
lifecycle](https://notes.ethereum.org/7CFxjwMgQSWOHIxLgJP2Bw#A-note-on-Ethereum-20-phase-0-validator-lifecycle):
describes the concept of validator status epochs and the cases of validator
lifecycle in the view of “validator status transition” in phase 0.

**Additional**

### Appendices

#### Appendix A: Ethreum 2.0 Technical Deep Dive

##### Block Production

**Process Flow**

* Transactions are placed in [txpool](https://github.com/ethereum/go-ethereum/tree/master/core/txpool)
* The transaction pool is read and [blocks](https://github.com/ethereum/go-ethereum/blob/release/1.9/core/types/block.go#L169) are produced by the [miner](https://github.com/ethereum/go-ethereum/blob/master/miner/miner.go)
* Blocks Headers get forwarded to the Beacon chain once they pass [beacon consensus](https://github.com/ethereum/go-ethereum/blob/master/consensus/beacon/consensus.go)
* The Beacon chain embeds the EthChain Header into a [BeaconBlock](https://github.com/prysmaticlabs/prysm/blob/develop/consensus-types/blocks/types.go#L43)

##### Consensus and Finality

Attestation Process Flow

* Proposing Block
* Signing Blocks
* Aggregated Attestation generation
* Block Proposal and Inclusion of Attestation
* The [SignedBeaconBlock](https://github.com/prysmaticlabs/prysm/blob/develop/consensus-types/blocks/types.go#L72) is added to the chain

Attestations Block(LMD Ghost Vote) and Epoch Checkpoints (FFG Votes)

* The validators in the committee attest to the validity of the block (LMD Ghost Vote)
* The validators in the comittee attest to the first block in the Epoch (FFG Vote)

From [Attestations, ethereum.org](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/attestations)

> Every epoch (6.4 minutes) a validator proposes an attestation to the network. The attestation is for a specific slot in the epoch. The purpose of the attestation is to vote in favor of the validator's view of the chain, in particular the most recent justified block and the first block in the current epoch (known as source and target checkpoints). This information is combined for all participating validators, enabling the network to reach consensus about the state of the blockchain.
>
> The attestation contains the following components:
>
> * aggregation\_bits: a bitlist of validators where the position maps to the validator index in their committee; the value (0/1) indicates whether the validator signed the data (i.e. whether they are active and agree with the block proposer)
> * data: details relating to the attestation, as defined below
> * signature: a BLS signature that aggregates the signatures of individual validators
>
> The first task for an attesting validator is to build the data. The data contains the following information:
>
> * slot: The slot number that the attestation refers to
> * index: A number that identifies which committee the validator belongs to in a given slot
> * beacon\_block\_root: Root hash of the block the validator sees at the head of the chain (the result of applying the fork-choice algorithm)
> * source: Part of the finality vote indicating what the validators see as the most recent justified block
> * target: Part of the finality vote indicating what the validators see as the first block in the current epoch
>
> Once the data is built, the validator can flip the bit in aggregation\_bits corresponding to their own validator index from 0 to 1 to show that they participated.
>
> Finally, the validator signs the attestation and broadcasts it to the network.

**Technical Details**

Following is an overview of the state structure and logic for generating committees and aggregating attestations. For data structures, please see [Beacon State Data Structures from Prysm](#beacon-state-data-structures-from-prysm) and [web3signer\_types from prysm](#web3signer_types-from-prysm).

[BeaconState](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/state#BeaconState) contains both a [ReadOnlyBeaconState](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/state#ReadOnlyBeaconState) and a [WriteOnlyBeaconState](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/state#WriteOnlyBeaconState) wich contain [ReadOnlyValidators](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/state#ReadOnlyValidators) and [ReadOnlyRandaoMixes](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/state#ReadOnlyRandaoMixes) and [WriteOnlyValidators](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/state#WriteOnlyValidators) and [WriteOnlyRandaoMixes](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/state#WriteOnlyRandaoMixes) respectively.

At the beginning of each epoch [func ProcessRandaoMixesReset](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/epoch#ProcessRandaoMixesReset) processes the final updates to RANDAO mix during epoch processing. This calls [RandaoMix](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#RandaoMix) which returns the randao mix (xor'ed seed) of a given slot. It is used to shuffle validators.

Following are sample mixes generated from [func TestRandaoMix\_OK](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/core/helpers/randao_test.go#L16) by adding the statement `fmt.Printf("mix: %v\n", mix)`

```
mix: [10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
mix: [40 9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
mix: [159 134 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
```

The shuffle functions consist of

* [func ShuffleList](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#ShuffleList): returns list of shuffled indexes in a pseudorandom permutation `p` of `0...list_size - 1` with “seed“ as entropy. We utilize 'swap or not' shuffling in this implementation; we are allocating the memory with the seed that stays constant between iterations instead of reallocating it each iteration as in the spec. This implementation is based on the original implementation from protolambda, [https://github.com/protolambda/eth2-shuffle](https://github.com/protolambda/eth2-shuffle)

  Following is an example of a shuffled list generated from [TestShuffleList\_OK](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/core/helpers/shuffle_test.go#L25)

  ```
  list1: [0 1 2 3 4 5 6 7 8 9]
  seed1: [1 128 12 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
  shuffledList1: [0 7 8 6 3 9 4 5 2 1]
  ```

* [func ShuffleIndex](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#ShuffledIndex): returns `p(index)` in a pseudorandom permutation `p` of `0...list_size - 1` with “seed“ as entropy. We utilize 'swap or not' shuffling in this implementation; we are allocating the memory with the seed that stays constant between iterations instead of reallocating it each iteration as in the spec. This implementation is based on the original implementation from protolambda, [https://github.com/protolambda/eth2-shuffle](https://github.com/protolambda/eth2-shuffle)

* [func ShuffleIndices](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#ShuffledIndices): ShuffledIndices uses input beacon state and returns the shuffled indices of the input epoch, the shuffled indices then can be used to break up into committees.

Committes are formed using functions from [beacon\_comittee.go](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/core/helpers/beacon_committee.go)

* [func BeaconComittee](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#BeaconCommittee): returns the beacon committee of a given slot and committee index. The validator indices and seed are provided as an argument rather than an imported implementation from the spec definition. Having them as an argument allows for cheaper computation run time. (This is an optomized version of [func BeaconComitteFromState](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#BeaconCommitteeFromState))

  Following is an example of a `beaconComittee` generated by adding the following lines to [TestBeaconCommitteeFromState\_UpdateCacheForPreviousEpoch](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/core/helpers/beacon_committee_test.go#L574):

  ```
  var beaconCommittee []types.ValidatorIndex
  beaconCommittee, err = BeaconCommitteeFromState(context.Background(), state, 1 /_previous epoch_/, 0)
  fmt.Printf("beaconComittee: %+v\n", beaconCommittee)
  ```

  Result

  ```
  beaconComittee: [160 338 313 307 320 324 45 469 196 303 23 14 97 312 126 488]
  ```

* [func CommitteeAssignments](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#CommitteeAssignments): is a map of validator indices pointing to the appropriate committee assignment for the given epoch.

  1. Determine the proposer validator index for each slot.
  2. Compute all committees.
  3. Determine the attesting slot for each committee.
  4. Construct a map of validator indices pointing to the respective committees.

  Following is an example of `commitees` generated by adding the following lines to [TestComputeCommittee\_WithoutCache](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/core/helpers/beacon_committee_test.go#L23)

committees, err := computeCommittee(indices, seed, 0, 1 /\_ Total committee\_/)

```

fmt.Printf("committees: %+v\n", committees)
```

<details>
  <summary>result</summary>

  ```
  committees: [799 45 913 1 631 654 417 244 1270 918 798 719 426 164 1171 863 848 522 828 359 713 972 284 680 203 832 453 75 979 468 667 540 180 729 1137 156 624 434 655 974 108 321 641 750 1150 356 933 870 650 984 869 95 975 510 563 1002 821 819 599 597 593 635 982 915 693 910 1030 845 461 887 936 354 1075 1253 1238 1011 395 773 670 54 389 765 1183 912 866 1230 1279 521 898 598 1038 814 377 1209 1226 19 1087 775 820 401 640 1028 673 174 493 857 931 288 475 1115 139 429 353 295 412 1136 1166 1191 496 677 1039 629 826 528 769 289 856 147 1227 243 731 297 924 89 644 557 1027 1239 1109 447 323 716 764 669 903 612 350 1046 392 768 1257 1083 216 294 606 971 103 902 1015 801 674 1099 49 484 995 1012 146 879 1156 548 1081 844 873 1246 1107 115 121 1018 387 751 941 1259 183 916 937 71 163 287 706 421 304 247 310 113 1032 776 502 1276 274 1214 418 271 307 1224 332 1222 240 657 1060 479 874 14 1147 627 122 448 1082 458 371 214 64 487 1263 34 172 497 880 555 1091 839 507 530 1170 498 999 727 950 317 1266 423 134 364 1092 1128 155 362 419 1219 1019 379 1163 483 917 318 804 336 985 463 584 210 1255 26 583 850 365 723 433 1073 1141 735 922 1035 893 774 1114 256 358 1044 997 546 679 1024 699 1096 663 1066 499 366 1256 883 566 17 717 393 422 622 795 1181 554 1212 736 1064 106 1050 72 1153 1210 198 943 818 518 309 101 471 0 38 688 107 718 1077 1021 648 1236 891 969 39 481 1159 660 686 450 990 1045 1213 756 900 849 355 119 1135 623 878 44 596 262 553 1013 290 269 691 18 207 454 620 221 983 852 430 843 1272 209 526 1100 865 402 437 278 976 1185 784 128 906 536 608 683 1205 574 1251 562 344 930 440 758 472 239 369 73 1235 478 724 373 399 1142 375 490 966 1203 1093 403 74 65 1247 579 145 1090 143 80 190 187 449 1160 194 959 533 671 442 136 158 665 79 253 226 1076 572 1130 227 909 940 275 43 342 182 126 967 700 267 1070 171 1000 658 876 1120 424 141 1164 328 1277 1220 1245 314 335 886 249 638 836 104 527 1057 1179 1111 551 334 749 754 237 1232 495 549 672 250 547 1132 427 346 935 515 452 184 739 77 689 744 831 281 76 48 2 327 542 351 47 1079 661 585 746 709 260 486 1242 932 303 435 1061 282 1217 390 996 457 470 40 592 785 1065 24 160 991 920 858 978 616 934 586 601 939 730 501 859 482 1207 386 1037 78 1184 947 861 643 231 22 397 1126 1215 265 1145 864 942 809 398 715 890 385 559 232 777 185 410 131 112 192 632 1124 302 1025 904 1047 94 1175 516 474 1122 568 617 894 733 1074 1252 264 263 851 124 1258 1023 1121 283 901 1225 923 464 193 1140 810 604 1108 740 1157 368 853 199 270 8 752 529 973 90 246 896 11 960 6 734 285 299 1042 152 732 965 469 161 609 1234 467 1084 780 1069 466 816 588 50 1194 1127 5 1010 31 712 766 1049 813 157 27 259 1055 343 793 1005 127 558 1036 794 1006 1178 767 1168 537 254 1218 590 361 531 186 567 605 4 255 618 37 1216 1134 337 223 811 962 67 587 1001 1187 842 455 1228 1248 1056 300 613 396 1152 830 329 61 1155 439 1188 807 1182 268 662 1101 1026 82 847 755 757 148 1244 778 664 1059 1197 301 1117 1274 743 840 316 123 634 272 1237 326 1041 1068 372 1003 1190 1243 630 298 215 166 445 513 838 363 1085 854 639 503 129 1029 1196 219 325 1161 70 165 564 1206 111 1078 1233 970 444 12 400 211 742 191 41 760 506 196 988 1173 125 177 420 805 957 862 1088 1144 1267 1265 994 380 1250 505 235 1089 451 120 762 867 1167 117 675 16 711 575 1009 85 577 550 1116 895 438 822 138 308 13 349 233 197 404 142 1123 589 614 251 411 1007 228 151 911 105 1162 738 140 892 1110 607 511 802 580 459 293 619 927 488 378 60 1020 236 212 279 980 322 1052 29 720 173 812 1043 882 797 159 926 1261 58 726 492 494 242 3 725 800 524 1062 1195 504 1016 808 168 436 682 383 952 615 179 57 921 370 394 945 489 1254 154 938 789 1229 339 684 806 525 539 787 1268 698 1008 621 225 408 32 964 357 188 477 114 581 144 745 701 110 391 460 381 181 1231 63 206 1264 480 538 561 591 1113 1202 825 348 704 33 625 783 681 1063 1080 1240 217 28 1176 928 582 914 229 252 1102 552 280 728 594 1017 35 406 137 175 162 1118 176 66 296 837 56 508 786 602 102 443 1095 868 696 899 692 1086 1223 907 834 1241 1172 118 1221 855 266 556 1098 384 948 55 340 178 1249 150 781 642 514 771 291 877 519 100 919 224 376 1125 987 645 1169 305 1133 319 201 611 956 42 189 238 908 703 88 981 954 1139 1174 881 576 1105 1186 1201 414 545 741 407 313 23 653 1051 509 872 195 649 1208 1165 1014 595 222 697 1112 1033 234 748 823 570 476 1198 1180 1154 248 257 905 306 1269 676 116 135 51 208 68 202 646 1177 312 86 388 1200 833 779 791 153 347 230 1158 565 543 261 986 875 1193 415 889 273 20 258 600 860 573 636 149 759 374 1072 1053 610 286 656 1119 1260 500 637 702 97 951 628 170 491 944 747 99 714 1278 721 69 571 83 520 473 569 989 98 245 929 1106 961 431 955 1004 884 998 446 544 949 220 535 1031 311 93 1262 871 763 1273 485 647 352 803 205 652 1034 687 958 888 753 792 456 782 59 462 441 796 708 1192 360 96 1148 678 428 277 1189 1071 633 1151 1103 25 993 835 241 1211 320 968 788 338 925 7 9 668 84 330 204 690 133 405 1094 1138 1097 1275 761 1104 10 897 315 517 694 416 685 560 62 772 382 977 87 651 532 659 827 1204 737 841 331 213 1040 132 846 963 695 130 292 91 1022 324 81 992 1199 770 790 465 523 425 1146 21 1054 815 345 829 666 603 1067 109 167 722 432 1149 953 512 413 707 1058 885 218 626 341 409 824 30 705 1048 578 367 710 946 36 1131 46 200 534 15 92 1129 276 817 169 53 52 541 333 1143 1271]
  ```
</details>

Attestations are managed using functions from [attestation.go](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/core/helpers/attestation.go)

* [func ValidateNilAttestation](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#ValidateNilAttestation): checks if any composite field of input attestation is nil. Access to these nil fields will result in run time panic, it is recommended to run these checks as first line of defense.

* [func ValidateSlotTargetEpoch](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#ValidateSlotTargetEpoch): ValidateSlotTargetEpoch checks if attestation data's epoch matches target checkpoint's epoch. It is recommended to run `ValidateNilAttestation` first to ensure `data.Target` can't be nil.

* [func IsAggregator](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#IsAggregator): IsAggregator returns true if the signature is from the input validator. The committee count is provided as an argument rather than imported implementation from spec. Having committee count as an argument allows cheaper computation at run time.

* [func AggregateSignature](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#AggregateSignature): returns the aggregated signature of the input attestations.

  Spec pseudocode definition:

  ```
  def get_aggregate_signature(attestations: Sequence[Attestation]) -> BLSSignature:
  signatures = [attestation.signature for attestation in attestations]
  return bls.Aggregate(signatures)
  ```

  Following is an example aggregrated signature by adding the following lines to [TestAttestation\_AggregateSignature](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/core/helpers/attestation_test.go#L48)

  ```
  aggSig, err := helpers.AggregateSignature(atts)
  fmt.Printf("aggSig: %+v\n", aggSig)
  ```

  Result

  ```
      aggSig: &{s:0xc0003fe000}
  ```

* [func IsAggregated](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#IsAggregated): IsAggregated returns true if the attestation is an aggregated attestation, false otherwise.

* [func ComputeSubnetForAttestation](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#ComputeSubnetForAttestation): returns the subnet for which the provided attestation will be broadcasted to.This differs from the spec definition by instead passing in the active validators indices in the attestation's given epoch.

```
  Spec pseudocode definition:

def compute_subnet_for_attestation(committees_per_slot: uint64, slot: Slot, committee_index: CommitteeIndex) -> uint64:

"""
Compute the correct subnet for an attestation for Phase 0.
Note, this mimics expected future behavior where attestations will be mapped to their shard subnet.
"""
slots_since_epoch_start = uint64(slot % SLOTS_PER_EPOCH)
committees_since_epoch_start = committees_per_slot \* slots_since_epoch_start

return uint64((committees_since_epoch_start + committee_index) % ATTESTATION_SUBNET_COUNT)

```

* [func ComputeSubnetFromCommitteeAndSlot](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#ComputeSubnetFromCommitteeAndSlot): is a flattened version of ComputeSubnetForAttestation where we only pass in the relevant fields from the attestation as function arguments.

Spec pseudocode definition:

```

def compute_subnet_for_attestation(committees_per_slot: uint64, slot: Slot, committee_index: CommitteeIndex) -> uint64:

"""
Compute the correct subnet for an attestation for Phase 0.
Note, this mimics expected future behavior where attestations will be mapped to their shard subnet.
"""
slots_since_epoch_start = uint64(slot % SLOTS_PER_EPOCH)
committees_since_epoch_start = committees_per_slot \* slots_since_epoch_start

return uint64((committees_since_epoch_start + committee_index) % ATTESTATION_SUBNET_COUNT)

```

* [func ValidateAttestationTime](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#ValidateAttestationTime): Validates that the incoming attestation is in the desired time range.
  An attestation is valid only if received within the last ATTESTATION\_PROPAGATION\_SLOT\_RANGE slots.

Example:

```

ATTESTATION_PROPAGATION_SLOT_RANGE = 5
clockDisparity = 24 seconds
current_slot = 100
invalid_attestation_slot = 92
invalid_attestation_slot = 103
valid_attestation_slot = 98
valid_attestation_slot = 101

```

In the attestation must be within the range of 95 to 102 in the example above.

* [func VerifyCheckpointEpoch](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/helpers#VerifyCheckpointEpoch): VerifyCheckpointEpoch is within current epoch and previous epoch with respect to current time. Returns true if it's within, false if it's not.

*Note: Sample command for running tests in Prysm: `bazel test //beacon-chain/core/helpers:go_default_test --test_output=streamed --test_filter=TestAttestation_AggregateSignature`.*

**Consensus Committee Selection**

* [func ProcessRandoa](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/beacon-chain/core/blocks#ProcessRandao): checks the block proposer's randao commitment and generates a new randao mix to update in the beacon state's latest randao mixes slice.
* [func randaoSigningData](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/core/blocks/signature.go#L157): retrieves the randao related signing data from the state.
  * [func (b \*BeaconState) PubkeyAtIndex(idx types.ValidatorIndex) \[fieldparams.BLSPubkeyLength\]byte ](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/state/state-native/getters_validator.go#L135): returns the pubkey at the given validator index.

#### Appendix B: Additional Light Client Support Documentation

##### Key Concepts

* Syncing to Current state

* Advancing Blocks

* Communication can be either via

* RPC to the [Eth BEACON Node API](https://ethereum.github.io/beacon-APIs/#/Beacon)

* [Networking Gossip Topics](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/p2p-interface.md#global-topics)
  * [light\_client\_finality\_update](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/p2p-interface.md#light_client_finality_update): This topic is used to propagate the latest `LightClientFinalityUpdate` to light clients, allowing them to keep track of the latest `finalized_header`.
  * [light\_client\_optimistic\_update](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/p2p-interface.md#light_client_optimistic_update): This topic is used to propagate the latest`LightClientOptimisticUpdate` to light clients, allowing them to keep track of the latest `optimistic_header`.

*Note: Time on Ethereum 2.0 Proof of Stake is divided into slots and epochs. One slot is 12 seconds. One epoch is 6.4 minutes, consisting of 32 slots. One block can be created for each slot.*

##### Altair Light Client -- Sync Protocol

* [Altair Light Client -- Sync Protocol](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.mdx): The beacon chain is designed to be light client friendly for constrained environments to access Ethereum with reasonable safety and liveness.

Such environments include resource-constrained devices (e.g. phones for trust-minimized wallets)and metered VMs (e.g. blockchain VMs for cross-chain bridges).

This document suggests a minimal light client design for the beacon chain thatuses sync committees introduced in [this beacon chain extension](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/beacon-chain.mdx).

Additional documents describe how the light client sync protocol can be used:

* [Full node](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/full-node.mdx)

* [Light client](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/light-client.mdx)

* [Networking](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/p2p-interface.mdx)

* [Light client sync process](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/light-client.mdx): explains how light clients MAY obtain light client data to sync with the network.

1. The light client MUST be configured out-of-band with a spec/preset (including fork schedule), with `genesis_state` (including `genesis_time` and `genesis_validators_root`), and with a trusted block root. The trusted block SHOULD be within the weak subjectivity period, and its root SHOULD be from a finalized `Checkpoint`.
2. The local clock is initialized based on the configured `genesis_time`, and the current fork digest is determined to browse for and connect to relevant light client data providers.
3. The light client fetches a [`LightClientBootstrap`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/light-client.mdx) object for the configured trusted block root. The `bootstrap` object is passed to [`initialize_light_client_store`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#initialize_light_client_store) to obtain a local [`LightClientStore`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#lightclientstore).
4. The light client tracks the sync committee periods `finalized_period` from `store.finalized_header.slot`, `optimistic_period` from `store.optimistic_header.slot`, and `current_period` from `current_slot` based on the local clock.
   1. When `finalized_period == optimistic_period` and [`is_next_sync_committee_known`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#is_next_sync_committee_known) indicates `False`, the light client fetches a [`LightClientUpdate`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#lightclientupdate) for `finalized_period`. If `finalized_period == current_period`, this fetch SHOULD be scheduled at a random time before `current_period` advances.
   2. When `finalized_period + 1 < current_period`, the light client fetches a `LightClientUpdate` for each sync committee period in range `[finalized_period + 1, current_period)` (current period excluded)
   3. When `finalized_period + 1 >= current_period`, the light client keeps observing [`LightClientFinalityUpdate`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#lightclientfinalityupdate) and [`LightClientOptimisticUpdate`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#lightclientoptimisticupdate). Received objects are passed to [`process_light_client_finality_update`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#process_light_client_finality_update) and [`process_light_client_optimistic_update`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#process_light_client_optimistic_update). This ensures that `finalized_header` and `optimistic_header` reflect the latest blocks.
5. [`process_light_client_store_force_update`](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.md#process_light_client_store_force_update) MAY be called based on use case dependent heuristics if light client sync appears stuck. If available, falling back to an alternative syncing mechanism to cover the affected sync committee period is preferred.

##### The Portal Network

* [The Portal Network](https://github.com/ethereum/portal-network-specs): The Portal Network is an in progess effort to enable lightweight protocol access by resource constrained devices. The term *"portal"* is used to indicate that these networks provide a *view* into the protocol but are not critical to the operation of the core Ethereum protocol.

The Portal Network is comprised of multiple peer-to-peer networks which together provide the data and functionality necessary to expose the standard [JSON-RPC API](https://eth.wiki/json-rpc/API). These networks are specially designed to ensure that clients participating in these networks can do so with minimal expenditure of networking bandwidth, CPU, RAM, and HDD resources.

The term 'Portal Client' describes a piece of software which participates in these networks. Portal Clients typically expose the standard JSON-RPC API.

* Motivation: The Portal Network is focused on delivering reliable, lightweight, and decentralized access to the Ethereum protocol.

* Prior Work on the "Light Ethereum Subprotocol" (LES): The term "light client" has historically refered to a client of the existing [DevP2P](https://github.com/ethereum/devp2p/blob/master/rlpx.mdx) based [LES](https://github.com/ethereum/devp2p/blob/master/caps/les.mdx) network. This network is designed using a client/server architecture. The LES network has a total capacity dictated by the number of "servers" on the network. In order for this network to scale, the "server" capacity has to increase. This also means that at any point in time the network has some total capacity which if exceeded will cause service degradation across the network. Because of this the LES network is unreliable when operating near capacity.

* Block Relay

* [Beacon State](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/beacon-state-network.md#dht-overview): A client has a trusted beacon state root, and it wants to access some parts of the state. Each of the access request corresponds to some leave nodes of the beacon state. The request is a content lookup on a DHT. The response is a Merkle proof.

  A Distributed Hash Table (DHT) allows network participants to have retrieve data on-demand based on a content

* [Syncing Block Headers](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/sync-gossip.mdx): A beacon chain client could sync committee to perform state updates. The data object LightClientSkipSyncUpdate allows a client to quickly sync to a recent header with the appropriate sync committee. Once the client establishes a recent header, it could sync to other headers by processing LightClientUpdates. These two data types allow a client to stay up-to-date with the beacon chain.
  * [Sync State](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/skip-sync-network.mdx): A client uses SkipSyncUpdate to skip sync from a known header to a recent header. A client with a trusted but outdated header cannot use the messages in the gossip channel bc-light-client-update to update. The client's sync-committee in the stored snapshot is too old and not connected to any update messages. The client look for the appropriate SkipSyncUpdate to skip sync its header.
  * [Advance Block Headers](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/sync-gossip.mdx): A beacon chain client could sync committee to perform [state updates](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/sync-protocol.mdx). The data object [LightClientSkipSyncUpdate](skip-sync-network) allows a client to quickly sync to a recent header with the appropriate sync committee. Once the client establishes a recent header, it could sync to other headers by processing [LightClientUpdates](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/sync-protocol.md#lightclientupdate). These two data types allow a client to stay up-to-date with the beacon chain.

    These two data types are placed into separate sub-networks. A light client make find-content requests on `skip-sync-network` at start of the sync to get a header with the same `SyncCommittee` object as in the current sync period. The client uses messages in the gossip topic `bc-light-client-update` to advance its header.

    The gossip topics described in this document is part of a [proposal](https://ethresear.ch/t/a-beacon-chain-light-client-proposal/11064) for a beacon chain light client.

##### Transaction Proofs

* [Retrieving Beacon State](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/beacon-state-network.mdx): A client has a trusted beacon state root, and it wants to access some parts of the state. Each of the access request corresponds to some leave nodes of the beacon state. The request is a content lookup on a DHT. The response is a Merkle proof.

A Distributed Hash Table (DHT) allows network participants to have retrieve data on-demand based on a content key. A portal-network DHT is different than a traditional one in that each participant could selectively limit its workload by choosing a small interest radius r. A participants only process messages that are within its chosen radius boundary.

* [Wire Protocol](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/beacon-state-network.md#wire-protocol): For a subprotocol, we need to further define the following to be able to instantiate the wire format of each message type. 1. `content_key` 2. `content_id` 3. `payload`

  The content of the message is a Merkle proof contains multiple leave nodes for a [BeaconState](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/beacon-chain.md#beaconstate).

  Finally, we define the necessary encodings. A light client only knows the root of the beacon state. The client wants to know the details of some leave nodes. The client has to be able to construct the `content_key` only knowing the root and which leave nodes it wants see. The `content_key` is the ssz serialization of the paths. The paths represent the part of the beacon state that one wants to know about. The paths are represented by generalized indices. Note that `hash_tree_root` and `serialize` are the same as those defined in [sync-gossip](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/sync-gossip.mdx).

* TODO: Review of Retrieving a transaction proof not just retrieving data on-demand

##### Further Information

* Ethereum 2.0 Specifications
* [Beacon Chain Specification](https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/beacon-chain.mdx)
* [Extended light client protocol](https://notes.ethereum.org/@vbuterin/extended_light_client_protocol)
* [Altair Light Client -- Light Client](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/light-client.mdx)
* [Altair Light Client -- Sync Protocol](https://github.com/ethereum/consensus-specs/blob/dev/specs/altair/light-client/sync-protocol.mdx)
* [Beacon Chain Fork Choice](https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/fork-choice.mdx)
* [The Portal Network Specification](https://github.com/ethereum/portal-network-specs): an in progess effort to enable lightweight protocol access by resource constrained devices.
* [Light Ethereum Subprotocol (LES)](https://github.com/ethereum/devp2p/blob/master/caps/les.mdx): the protocol used by "light" clients, which only download block headers as they appear and fetch other parts of the blockchain on-demand.
* [BlockDaemon: Ethereum Altair Hard Folk: Light Clients & Sync Committees](https://blockdaemon.com/blog/ethereum-altair-hard-folk-light-clients-sync-committees/)
* [Efficient algorithms for CBC Casper](https://docs.google.com/presentation/d/1oc_zdywOsHxz3zez1ILAgrerS7RkaF1hHoW0FLtp0Gw/edit#slide=id.p): Review of LMD GHOST (Latest Message Driven, Greediest Heaviest Observed Sub-Tree)
* [SSZ: Simple Serialize](https://ethereum.org/en/developers/docs/data-structures-and-encoding/ssz/): Overview of Simple serialize (SSZ) is the serialization method used on the Beacon Chain. (including merkalization and multiproofs)
* [The Noise Protocol Framework](https://noiseprotocol.org/noise.html): Noise is a framework for crypto protocols based on Diffie-Hellman key agreement.
* [Flashbots for Ethereum Consensus Clients](https://hackmd.io/QoLwVQf3QK6EiVt15YOYqQ?view)
* [Optimistic Sync Specification](https://github.com/ethereum/consensus-specs/blob/dev/sync/optimistic.mdx): Optimistic Sync is a stop-gap measure to allow execution nodes to sync via established methods until future Ethereum roadmap items are implemented (e.g., statelessness).
* [Consensus Light Client Server Implementation Notes](https://hackmd.io/hsCz1G3BTyiwwJtjT4pe2Q?view): How Lodestar beacon node was tweaked to serve light clients
* [beacon chain light client design doc](https://notes.ethereum.org/@ralexstokes/HJxDMi8vY): notes about the design/implementation of a beacon chain light client using standard APIs and protocol features
* [A Beacon Chain Light Client Proposal](https://ethresear.ch/t/a-beacon-chain-light-client-proposal/11064): proposing a light client implementation that goes a step further than the minimum light client described in the altair consensus-spec. The proposed client aims to allow queries into the beacon state.
* [Distributed Hash Table (DHT) Overview](https://github.com/ethereum/portal-network-specs/blob/master/beacon-chain/beacon-state-network.md#dht-overview): allows network participants to have retrieve data on-demand based on a content key.
* [(WIP) Light client p2p interface Specification](https://github.com/ethereum/consensus-specs/pull/2786): a PR to get the conversation going about a p2p approach.
  Here we cover two approaches which may be combined

#### Appendix C: Proving and Verification Mechanisms

##### [eth-proof-of-consensus](https://github.com/succinctlabs/eth-proof-of-consensus): Proof of Consensus for Ethereum by succinctlabs

Circuits

* [aggregate\_bls\_verify.circom](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/circuits/circuits/aggregate_bls_verify.circom): Computes an aggregate BLS12-381 public key over a set of public keys and a bitmask
* [assert\_valid\_signed\_header.circom](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/circuits/circuits/assert_valid_signed_header.circom)
* [pubkey\_poseidon.circom](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/circuits/circuits/pubkey_poseidon.circom): Computes the Poseidon merkle root of a list of field elements
* [sha256\_bytes.circom](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/circuits/circuits/sha256_bytes.circom): Wrapper around SHA256 to support bytes as input instead of bits
* [simple\_serialize.circom](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/circuits/circuits/simple_serialize.circom): Helper function to implement SSZArray
* [sync\_committee\_committments.circom](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/circuits/circuits/sync_committee_committments.circom): Asserts that the byte representation of a BLS12-381 public key's x-coordinate matches the BigInt representation

Verification

* [AMB](https://github.com/succinctlabs/eth-proof-of-consensus/tree/main/contracts/src/amb): Arbitrary Message Passing
* [TrustlessAMB.sol](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/amb/TrustlessAMB.sol): sends and executes messages
* [TrustlessAMBStorage.sol](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/amb/TrustlessAMBStorage.sol): Storage for messages between two chains
* [bridge](https://github.com/succinctlabs/eth-proof-of-consensus/tree/main/contracts/src/bridge): Allows for the deposit and withdrawal of ERC20 tokens
* [Bridge.sol](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/bridge/Bridge.sol): Deposit and withdraw functionality
* [Token.sol](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/bridge/Tokens.sol): ERC20 bridge token definitions
* [lightclient](https://github.com/succinctlabs/eth-proof-of-consensus/tree/main/contracts/src/lightclient)
* [BLSAggregatedSignatureVerifier.sol](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BLSAggregatedSignatureVerifier.sol): Verifies BLS aggregated signature proofs
* [BeaconLightClient.sol](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BeaconLightClient.sol): Beacon Light Client Functionality including
  * [step(LightClientUpdate memory update)](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BeaconLightClient.sol#L86): Updates the head given a finalized light client update.
  * [function updateSyncCommittee(LightClientUpdate memory update, bytes32 nextSyncCommitteePoseidon, Groth16Proof memory commitmentMappingProof)](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BeaconLightClient.sol#L102): Set the sync committee validator set root for the next sync commitee period.
  * [function forceUpdate()](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BeaconLightClient.sol#L131): Finalizes the optimistic update and sets the next sync committee if no finalized updates have been received for a period.
  * [function processLightClientUpdate(LightClientUpdate memory update)](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BeaconLightClient.sol#L131): Implements shared logic for processing light client updates.
  * [function zkMapSSZToPoseidon(bytes32 sszCommitment, bytes32 poseidonCommitment, Groth16Proof memory proof)](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BeaconLightClient.sol#L190): Maps a simple serialize merkle root to a poseidon merkle root with a zkSNARK. The proof asserts that: SimpleSerialize(syncCommittee) == Poseidon(syncCommittee).
  * [function zkBLSVerify(bytes32 signingRoot, bytes32 syncCommitteeRoot, uint256 claimedParticipation, Groth16Proof memory proof)](https://github.com/succinctlabs/eth-proof-of-consensus/blob/main/contracts/src/lightclient/BeaconLightClient.sol#L208): Does an aggregated BLS signature verification with a zkSNARK.
* [scripts](https://github.com/succinctlabs/eth-proof-of-consensus/tree/main/contracts/src/scripts): A collection of [forge-scripts](https://book.getfoundry.sh/reference/forge/forge-script) for contract deployment.

#### Appendix D: Topics

Beacon Chain Topics [Prysm](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/p2p/topics.go)

```

package p2p

const (
// GossipProtocolAndDigest represents the protocol and fork digest prefix in a gossip topic.
GossipProtocolAndDigest = "/eth2/%x/"

// Message Types
//
// GossipAttestationMessage is the name for the attestation message type. It is
// specially extracted so as to determine the correct message type from an attestation
// subnet.
GossipAttestationMessage = "beacon_attestation"
// GossipSyncCommitteeMessage is the name for the sync committee message type. It is
// specially extracted so as to determine the correct message type from a sync committee
// subnet.
GossipSyncCommitteeMessage = "sync_committee"
// GossipBlockMessage is the name for the block message type.
GossipBlockMessage = "beacon_block"
// GossipExitMessage is the name for the voluntary exit message type.
GossipExitMessage = "voluntary_exit"
// GossipProposerSlashingMessage is the name for the proposer slashing message type.
GossipProposerSlashingMessage = "proposer_slashing"
// GossipAttesterSlashingMessage is the name for the attester slashing message type.
GossipAttesterSlashingMessage = "attester_slashing"
// GossipAggregateAndProofMessage is the name for the attestation aggregate and proof message type.
GossipAggregateAndProofMessage = "beacon_aggregate_and_proof"
// GossipContributionAndProofMessage is the name for the sync contribution and proof message type.
GossipContributionAndProofMessage = "sync_committee_contribution_and_proof"
// GossipBlsToExecutionChangeMessage is the name for the bls to execution change message type.
GossipBlsToExecutionChangeMessage = "bls_to_execution_change"

// Topic Formats
//
// AttestationSubnetTopicFormat is the topic format for the attestation subnet.
AttestationSubnetTopicFormat = GossipProtocolAndDigest + GossipAttestationMessage + "_%d"
// SyncCommitteeSubnetTopicFormat is the topic format for the sync committee subnet.
SyncCommitteeSubnetTopicFormat = GossipProtocolAndDigest + GossipSyncCommitteeMessage + "_%d"
// BlockSubnetTopicFormat is the topic format for the block subnet.
BlockSubnetTopicFormat = GossipProtocolAndDigest + GossipBlockMessage
// ExitSubnetTopicFormat is the topic format for the voluntary exit subnet.
ExitSubnetTopicFormat = GossipProtocolAndDigest + GossipExitMessage
// ProposerSlashingSubnetTopicFormat is the topic format for the proposer slashing subnet.
ProposerSlashingSubnetTopicFormat = GossipProtocolAndDigest + GossipProposerSlashingMessage
// AttesterSlashingSubnetTopicFormat is the topic format for the attester slashing subnet.
AttesterSlashingSubnetTopicFormat = GossipProtocolAndDigest + GossipAttesterSlashingMessage
// AggregateAndProofSubnetTopicFormat is the topic format for the aggregate and proof subnet.
AggregateAndProofSubnetTopicFormat = GossipProtocolAndDigest + GossipAggregateAndProofMessage
// SyncContributionAndProofSubnetTopicFormat is the topic format for the sync aggregate and proof subnet.
SyncContributionAndProofSubnetTopicFormat = GossipProtocolAndDigest + GossipContributionAndProofMessage
// BlsToExecutionChangeSubnetTopicFormat is the topic format for the bls to execution change subnet.
BlsToExecutionChangeSubnetTopicFormat = GossipProtocolAndDigest + GossipBlsToExecutionChangeMessage
)

```

#### Appendix E: gRPC and API's

[Beaconcha.in ETH2 API](https://beaconcha.in/api/v1/docs/index.html)

#### Appendix F: Data Structures

* Block Structure from [go-ethereum](https://github.com/ethereum/go-ethereum/blob/release/1.9/core/types/block.go#L72)

```

// SealHash returns the hash of a block prior to it being sealed.
func (ethash *Ethash) SealHash(header *types.Header) (hash common.Hash) {
hasher := sha3.NewLegacyKeccak256()

rlp.Encode(hasher, []interface{}{
header.ParentHash,
header.UncleHash,
header.Coinbase,
header.Root,
header.TxHash,
header.ReceiptHash,
header.Bloom,
header.Difficulty,
header.Number,
header.GasLimit,
header.GasUsed,
header.Time,
header.Extra,
})
hasher.Sum(hash[:0])
return hash
}

```

* Blocks Headers get forwarded to the Beacon chain once they pass [beacon consensus](https://github.com/ethereum/go-ethereum/blob/master/consensus/beacon/consensus.go)
* The Beacon chain embeds the EthChain Header into a [BeaconBlock](https://github.com/prysmaticlabs/prysm/blob/develop/consensus-types/blocks/types.go#L43)

BeaconBlockBody from [prysm](https://github.com/prysmaticlabs/prysm/blob/develop/consensus-types/blocks/types.go) (golang)

```

// BeaconBlockBody is the main beacon block body structure. It can represent any block type.
type BeaconBlockBody struct {
version int
isBlinded bool
randaoReveal [field_params.BLSSignatureLength]byte
eth1Data *eth.Eth1Data
graffiti [field_params.RootLength]byte
proposerSlashings []*eth.ProposerSlashing
attesterSlashings []*eth.AttesterSlashing
attestations []*eth.Attestation
deposits []*eth.Deposit
voluntaryExits []*eth.SignedVoluntaryExit
syncAggregate *eth.SyncAggregate
executionPayload *engine.ExecutionPayload
executionPayloadHeader \*engine.ExecutionPayloadHeader
}

// BeaconBlock is the main beacon block structure. It can represent any block type.
type BeaconBlock struct {
version int
slot types.Slot
proposerIndex types.ValidatorIndex
parentRoot [field_params.RootLength]byte
stateRoot [field_params.RootLength]byte
body \*BeaconBlockBody
}

// SignedBeaconBlock is the main signed beacon block structure. It can represent any block type.
type SignedBeaconBlock struct {
version int
block \*BeaconBlock
signature [field_params.BLSSignatureLength]byte
}

```

Eth1Data from [prysm](https://github.com/prysmaticlabs/prysm/blob/develop/proto/prysm/v1alpha1/powchain.pb.go#L24) (golang)

```

type ETH1ChainData struct {
state protoimpl.MessageState
sizeCache protoimpl.SizeCache
unknownFields protoimpl.UnknownFields

CurrentEth1Data *LatestETH1Data `protobuf:"bytes,1,opt,name=current_eth1_data,json=currentEth1Data,proto3" json:"current_eth1_data,omitempty"`
ChainstartData *ChainStartData `protobuf:"bytes,2,opt,name=chainstart_data,json=chainstartData,proto3" json:"chainstart_data,omitempty"`
BeaconState *BeaconState `protobuf:"bytes,3,opt,name=beacon_state,json=beaconState,proto3" json:"beacon_state,omitempty"`
Trie *SparseMerkleTrie `protobuf:"bytes,4,opt,name=trie,proto3" json:"trie,omitempty"`
DepositContainers []\*DepositContainer `protobuf:"bytes,5,rep,name=deposit_containers,json=depositContainers,proto3" json:"deposit_containers,omitempty"`
}

type LatestETH1Data struct {
state protoimpl.MessageState
sizeCache protoimpl.SizeCache
unknownFields protoimpl.UnknownFields

BlockHeight uint64 `protobuf:"varint,2,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
BlockTime uint64 `protobuf:"varint,3,opt,name=block_time,json=blockTime,proto3" json:"block_time,omitempty"`
BlockHash []byte `protobuf:"bytes,4,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
LastRequestedBlock uint64 `protobuf:"varint,5,opt,name=last_requested_block,json=lastRequestedBlock,proto3" json:"last_requested_block,omitempty"`
}

```

BeaconBlockAltair from [lighthouse](https://github.com/sigp/lighthouse/blob/stable/consensus/types/src/beacon_block.rs#L407) rust

```

    /// Return an Altair block where the block has maximum size.
    pub fn full(spec: &ChainSpec) -> Self {
        let base_block: BeaconBlockBase<_, Payload> = BeaconBlockBase::full(spec);
        let sync_aggregate = SyncAggregate {
            sync_committee_signature: AggregateSignature::empty(),
            sync_committee_bits: BitVector::default(),
        };
        BeaconBlockAltair {
            slot: spec.genesis_slot,
            proposer_index: 0,
            parent_root: Hash256::zero(),
            state_root: Hash256::zero(),
            body: BeaconBlockBodyAltair {
                proposer_slashings: base_block.body.proposer_slashings,
                attester_slashings: base_block.body.attester_slashings,
                attestations: base_block.body.attestations,
                deposits: base_block.body.deposits,
                voluntary_exits: base_block.body.voluntary_exits,
                sync_aggregate,
                randao_reveal: Signature::empty(),
                eth1_data: Eth1Data {
                    deposit_root: Hash256::zero(),
                    block_hash: Hash256::zero(),
                    deposit_count: 0,
                },
                graffiti: Graffiti::default(),
                _phantom: PhantomData,
            },
        }
    }

}

```

##### Beacon State Data Structures from Prysm

```

type BeaconState interface {
SpecParametersProvider
ReadOnlyBeaconState
WriteOnlyBeaconState
Copy() BeaconState
HashTreeRoot(ctx context.Context) ([32]byte, error)
FutureForkStub
StateProver
}

```

```

type ReadOnlyBeaconState interface {
ReadOnlyBlockRoots
ReadOnlyStateRoots
ReadOnlyRandaoMixes
ReadOnlyEth1Data
ReadOnlyValidators
ReadOnlyBalances
ReadOnlyCheckpoint
ReadOnlyAttestations
ToProtoUnsafe() interface{}
ToProto() interface{}
GenesisTime() uint64
GenesisValidatorsRoot() []byte
Slot() types.Slot
Fork() *ethpb.Fork
LatestBlockHeader() *ethpb.BeaconBlockHeader
HistoricalRoots() [][]byte
Slashings() []uint64
FieldReferencesCount() map[string]uint64
MarshalSSZ() ([]byte, error)
IsNil() bool
Version() int
LatestExecutionPayloadHeader() (interfaces.ExecutionData, error)
}

```

```

type ReadOnlyValidators interface {
Validators() []*ethpb.Validator
ValidatorAtIndex(idx types.ValidatorIndex) (*ethpb.Validator, error)
ValidatorAtIndexReadOnly(idx types.ValidatorIndex) (ReadOnlyValidator, error)
ValidatorIndexByPubkey(key [fieldparams.BLSPubkeyLength]byte) (types.ValidatorIndex, bool)
PubkeyAtIndex(idx types.ValidatorIndex) [fieldparams.BLSPubkeyLength]byte
NumValidators() int
ReadFromEveryValidator(f func(idx int, val ReadOnlyValidator) error) error
}

```

```

type ReadOnlyRandaoMixes interface {
RandaoMixes() [][]byte
RandaoMixAtIndex(idx uint64) ([]byte, error)
RandaoMixesLength() int
}

```

```

type WriteOnlyBeaconState interface {
WriteOnlyBlockRoots
WriteOnlyStateRoots
WriteOnlyRandaoMixes
WriteOnlyEth1Data
WriteOnlyValidators
WriteOnlyBalances
WriteOnlyCheckpoint
WriteOnlyAttestations
SetGenesisTime(val uint64) error
SetGenesisValidatorsRoot(val []byte) error
SetSlot(val types.Slot) error
SetFork(val *ethpb.Fork) error
SetLatestBlockHeader(val *ethpb.BeaconBlockHeader) error
SetHistoricalRoots(val [][]byte) error
SetSlashings(val []uint64) error
UpdateSlashingsAtIndex(idx, val uint64) error
AppendHistoricalRoots(root [32]byte) error
SetLatestExecutionPayloadHeader(payload interfaces.ExecutionData) error
SetWithdrawalQueue(val []*enginev1.Withdrawal) error
AppendWithdrawal(val *enginev1.Withdrawal) error
SetNextWithdrawalIndex(i uint64) error
SetNextPartialWithdrawalValidatorIndex(i types.ValidatorIndex) error
}

```

```

type WriteOnlyValidators interface {
SetValidators(val []*ethpb.Validator) error
ApplyToEveryValidator(f func(idx int, val *ethpb.Validator) (bool, *ethpb.Validator, error)) error
UpdateValidatorAtIndex(idx types.ValidatorIndex, val *ethpb.Validator) error
AppendValidator(val \*ethpb.Validator) error
}

```

```

type WriteOnlyRandaoMixes interface {
SetRandaoMixes(val [][]byte) error
UpdateRandaoMixesAtIndex(idx uint64, val []byte) error
}

```

[Validator](https://pkg.go.dev/github.com/prysmaticlabs/prysm/v3@v3.1.2/proto/prysm/v1alpha1#Validator) information

```

type Validator struct {
PublicKey []byte `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty" spec-name:"pubkey" ssz-size:"48"`
WithdrawalCredentials []byte ``/* 138-byte string literal not displayed */
 EffectiveBalance           uint64                                                             `protobuf:"varint,3,opt,name=effective_balance,json=effectiveBalance,proto3" json:"effective_balance,omitempty"`
 Slashed                    bool                                                               `protobuf:"varint,4,opt,name=slashed,proto3" json:"slashed,omitempty"`
 ActivationEligibilityEpoch github_com_prysmaticlabs_prysm_v3_consensus_types_primitives.Epoch`` /_ 221-byte string literal not displayed _/
ActivationEpoch github*com_prysmaticlabs_prysm_v3_consensus_types_primitives.Epoch `/* 186-byte string literal not displayed _/
ExitEpoch github_com_prysmaticlabs_prysm_v3_consensus_types_primitives.Epoch` /_ 168-byte string literal not displayed _/
WithdrawableEpoch github_com_prysmaticlabs_prysm_v3_consensus_types_primitives.Epoch `` /_ 192-byte string literal not displayed \_/
// contains filtered or unexported fields
}

```

##### [web3signer\_types from prysm](https://github.com/prysmaticlabs/prysm/blob/develop/validator/keymanager/remote-web3signer/v1/web3signer_types.go#L107)

```

////////////////////////////////////////////////////////////////////////////////
// sub properties of Sign Requests /////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// ForkInfo a sub property object of the Sign request
type ForkInfo struct {
Fork \*Fork `json:"fork"`
GenesisValidatorsRoot hexutil.Bytes `json:"genesis_validators_root"`
}

// Fork a sub property of ForkInfo.
type Fork struct {
PreviousVersion hexutil.Bytes `json:"previous_version"`
CurrentVersion hexutil.Bytes `json:"current_version"`
Epoch string `json:"epoch"` /_uint64_/
}

// AggregationSlot a sub property of AggregationSlotSignRequest.
type AggregationSlot struct {
Slot string `json:"slot"`
}

// AggregateAndProof a sub property of AggregateAndProofSignRequest.
type AggregateAndProof struct {
AggregatorIndex string `json:"aggregator_index"` /_ uint64 _/
Aggregate _Attestation `json:"aggregate"`
SelectionProof hexutil.Bytes `json:"selection_proof"` /_ 96 bytes _/
}

// Attestation a sub property of AggregateAndProofSignRequest.
type Attestation struct {
AggregationBits hexutil.Bytes `json:"aggregation_bits"` /_hex bitlist_/
Data \*AttestationData `json:"data"`
Signature hexutil.Bytes `json:"signature"`
}

// AttestationData a sub property of Attestation.
type AttestationData struct {
Slot string `json:"slot"` /_ uint64 _/
Index string `json:"index"` /_ uint64 _/ // Prysm uses CommitteeIndex but web3signer uses index.
BeaconBlockRoot hexutil.Bytes `json:"beacon_block_root"`
Source *Checkpoint `json:"source"`
Target *Checkpoint `json:"target"`
}

// Checkpoint a sub property of AttestationData.
type Checkpoint struct {
Epoch string `json:"epoch"`
Root string `json:"root"`
}

```

[attestation.proto from prysm (Message Structure)](https://github.com/prysmaticlabs/prysm/blob/develop/proto/prysm/v1alpha1/attestation.proto)

```

message AttestationData {
// Attestation data includes information on Casper the Friendly Finality Gadget's votes
// See: https://arxiv.org/pdf/1710.09437.pdf

    // Slot of the attestation attesting for.
    uint64 slot = 1 [(ethereum.eth.ext.cast_type) = "github.com/prysmaticlabs/prysm/v3/consensus-types/primitives.Slot"];

    // The committee index that submitted this attestation.
    uint64 committee_index = 2  [(ethereum.eth.ext.cast_type) = "github.com/prysmaticlabs/prysm/v3/consensus-types/primitives.CommitteeIndex"];

    // 32 byte root of the LMD GHOST block vote.
    bytes beacon_block_root = 3 [(ethereum.eth.ext.ssz_size) = "32"];

    // The most recent justified checkpoint in the beacon state
    Checkpoint source = 4;

    // The checkpoint attempting to be justified for the current epoch and its epoch boundary block
    Checkpoint target = 5;

}

```

#### Appendix G: Sample Data

##### Epoch Data for 167040

Following is the Epoch Data for 167040
It can be retrieved from [here](https://beaconcha.in/api/v1/docs/index.html#/Epoch/get_api_v1_epoch__epoch_) or by using this curl command

`curl -X 'GET' \
  'https://beaconcha.in/api/v1/epoch/167040' \
  -H 'accept: application/json'`

Response

```

{
"status": "OK",
"data": {
"attestationscount": 3457,
"attesterslashingscount": 0,
"averagevalidatorbalance": 33899775551,
"blockscount": 32,
"depositscount": 0,
"eligibleether": 15596542000000000,
"epoch": 167040,
"finalized": true,
"globalparticipationrate": 0.9963188171386719,
"missedblocks": 0,
"orphanedblocks": 0,
"proposedblocks": 32,
"proposerslashingscount": 0,
"scheduledblocks": 0,
"totalvalidatorbalance": 16522615004645864,
"validatorscount": 487396,
"voluntaryexitscount": 0,
"votedether": 15539128000000000
}
}

```

##### Block Data for Slot 5,330,592

Following is the Block Data for Slot 5,330,592
It can be retrieved from [here](https://beaconcha.in/api/v1/docs/index.html#/Block/get_api_v1_block__slotOrHash_) or by using this curl command

`curl -X 'GET' 'https://beaconcha.in/api/v1/block/5330592' -H 'accept: application/json'`

Response

```

{
"status": "OK",
"data": {
"attestationscount": 126,
"attesterslashingscount": 0,
"blockroot": "0xaebe891086c79ab79b325f474dc1150f1223e567337bff815cc318f14c64c233",
"depositscount": 0,
"epoch": 166581,
"eth1data_blockhash": "0xd346f84ffe7c600b7714d6411c8bea988d9d64dbdb432f26db58e72946337954",
"eth1data_depositcount": 498785,
"eth1data_depositroot": "0x9a5603a34aa60f299384679bf4bfc267e99b68278a81f343bde8cb5650bf1d60",
"exec_base_fee_per_gas": 12376913565,
"exec_block_hash": "0x26239efe09f51b24bdf7c518b1aa925a3b0b6453682408ec8a5c906d5038a6e7",
"exec_block_number": 16163905,
"exec_extra_data": "0x496c6c756d696e61746520446d6f63726174697a6520447374726962757465",
"exec_fee_recipient": "0xdafea492d9c6733ae3d56b7ed1adb60692c98bc5",
"exec_gas_limit": 30000000,
"exec_gas_used": 9901267,
"exec_logs_bloom": "0x8c21554815843b4084a999b2901917a52c58004a82a8440d94919a77f9241181388a0c404f000a8c0321ab024800bf899610e60ec801fb4b0352e34f147626192648619065381ded6b9d92bcd0861120adc1ec01064e7a016ea91c478d01b81316462d2d622a60010bc0139f6fb8ccf200499c0e211a85c042047d1601aa0c2ea2833902a2a3091528492dad09f6dc064529c455d328413b78c680c4699815ac9a91610f19e66542edca45a10518ee65b02cf02241a124232d5958b6004cd0a5846c5703d00b5e4d8353221015f7d38c1429074e34aaa11f3804f933082860c401152088251479918297a1a9237d9ac35539f6d069cca07a005819494a653913",
"exec_parent_hash": "0x06746d5ff105e96a1b8961c2490c0261b474604fbcbf934e86295c0030e26ce2",
"exec_random": "0xc2861c72cf4d34b37ec73519dbc20b690742b5cc119ed3738f1dd67d8ca52723",
"exec_receipts_root": "0x33cdf5c6e03dd341f282d02d3c354c2361a6212692b2a3c06b520397045313f4",
"exec_state_root": "0x517304bade8d83337c9a52f8ceeb13f924b64486b3b8033f7c348c176922104a",
"exec_timestamp": 1670791127,
"exec_transactions_count": 139,
"graffiti": "0x0000000000000000000000000000000000000000000000000000000000000000",
"graffiti_text": "",
"parentroot": "0x0cab36616bbcbbc67c343ddce00241c27d0df2c367c5fa82fc7c0fdf0ed37405",
"proposer": 4345,
"proposerslashingscount": 0,
"randaoreveal": "0x83950cb64781aff91f4bd14aa6abb0f5fdb7e08e4e81c264f0754c93d7672c4a9615de196491fdb53eafdeb8f49e9cf515f1bd3dc05bb5dc0e2dd8bff5a8d783b503e3385e80b61485f0ddac1caa9361132a863db84e7e234df5815e6908e4e7",
"signature": "0x84865a9480ae6313b0e5fcadfa294b35f5963e06c66ad1c7613dc081e9700c07f82a2583ba4b62b2483b4a1b9d49aafe0690f22fcf4d0072f9f44a5ce3067ef4fda560d171001cc6bf5dc84e09d9055d92894b86b27695c297f25530cd8db7a0",
"slot": 5330592,
"stateroot": "0x9e7e40d844c3b229cd9497d662a6d94276d285945073849995aba93c7e73cfe7",
"status": "1",
"syncaggregate_bits": "0xdffffffffffffffffffffffffffffff7fffffffffffffffffffffffffffffffffffffffffffffffffffffffdfffffffffffffffdffffffffffffffffffffffff",
"syncaggregate_participation": 0.9921875,
"syncaggregate_signature": "0x95332c55790018eed3d17eada01cb4045348d09137505bc8697eeedaa3800a830ee2c138251850a9577f62a5488419ef0a722579156a177fb3a147017f1077af5d778f46a4cdf815fc450129d135fe5286e16df68333592e4aa45821bde780dd",
"voluntaryexitscount": 0,
"votes": 19227
}
}

```

##### Execution Block for 16163905

Following is the execution block data for 16163905
It can be retrieved from [here](https://beaconcha.in/api/v1/docs/index.html#/Execution/get_api_v1_execution_block__blockNumber_) or by using this curl command

`curl -X 'GET' 'https://beaconcha.in/api/v1/execution/block/16163905'  -H 'accept: application/json'`

Result

```

{
"status": "OK",
"data": [
{
"blockHash": "0x26239efe09f51b24bdf7c518b1aa925a3b0b6453682408ec8a5c906d5038a6e7",
"blockNumber": 16163905,
"timestamp": 1670791127,
"blockReward": 37343826945103810,
"blockMevReward": 37083911760238810,
"producerReward": 37083911760238810,
"feeRecipient": "0xdafea492d9c6733ae3d56b7ed1adb60692c98bc5",
"gasLimit": 30000000,
"gasUsed": 9901267,
"baseFee": 12376913565,
"txCount": 139,
"internalTxCount": 54,
"uncleCount": 0,
"parentHash": "0x06746d5ff105e96a1b8961c2490c0261b474604fbcbf934e86295c0030e26ce2",
"uncleHash": "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347",
"difficulty": 0,
"posConsensus": {
"executionBlockNumber": 16163905,
"proposerIndex": 4345,
"slot": 5330592,
"epoch": 166581,
"finalized": true
},
"relay": {
"tag": "flashbots-relay",
"builderPubkey": "0x81beef03aafd3dd33ffd7deb337407142c80fea2690e5b3190cfc01bde5753f28982a7857c96172a75a234cb7bcb994f",
"producerFeeRecipient": "0x60987e0d8b5e0095869ca6f0e642828e3f258bb5"
},
"consensusAlgorithm": "pos"
}
]
}

```

##### Sync Committee (latest)

Following is a sample Sync Committee
It can be retrieved from [here](https://beaconcha.in/api/v1/docs/index.html#/SyncCommittee/get_api_v1_sync_committee__period_) or by using this curl command

`curl -X 'GET' 'https://beaconcha.in/api/v1/sync_committee/latest' -H 'accept: application/json'`

Abbrieviated Result

```

{
"status": "OK",
"data": {
"end_epoch": 167167,
"period": 652,
"start_epoch": 166912,
"validators": [
328781,
184949,
...
]
}
}

```

<details>
  <summary>Full Result</summary>

  ```

  {
  "status": "OK",
  "data": {
  "end_epoch": 167167,
  "period": 652,
  "start_epoch": 166912,
  "validators": [
  328781,
  184949,
  269719,
  484753,
  447707,
  190522,
  222987,
  429436,
  23553,
  353182,
  394935,
  347121,
  3941,
  77287,
  390407,
  41282,
  440380,
  477794,
  13208,
  321552,
  338223,
  414921,
  77542,
  57797,
  471002,
  238719,
  87491,
  85099,
  16484,
  220174,
  256680,
  194973,
  77409,
  150279,
  322042,
  275140,
  393620,
  21206,
  59424,
  308071,
  20736,
  173428,
  365316,
  293687,
  136783,
  459882,
  9048,
  128613,
  132177,
  267018,
  290896,
  236936,
  406218,
  380040,
  481667,
  34410,
  413701,
  158755,
  222721,
  295335,
  106306,
  426104,
  229412,
  377442,
  300381,
  251157,
  2301,
  255801,
  160943,
  417370,
  290905,
  435535,
  164094,
  204304,
  258455,
  366943,
  119808,
  311117,
  79552,
  164660,
  446993,
  347592,
  256827,
  244517,
  277343,
  303208,
  425967,
  216346,
  13359,
  481813,
  142254,
  105339,
  465226,
  200109,
  198691,
  43343,
  32947,
  392889,
  304855,
  452188,
  148690,
  441869,
  15210,
  216221,
  33338,
  124091,
  299153,
  305746,
  230810,
  484937,
  464816,
  474017,
  307185,
  370171,
  430926,
  21371,
  7607,
  209940,
  439052,
  398079,
  238559,
  108372,
  127122,
  62084,
  5906,
  278678,
  404838,
  253340,
  146867,
  437165,
  470827,
  252487,
  430474,
  433777,
  282060,
  221522,
  273826,
  56274,
  359184,
  401626,
  43613,
  287311,
  465536,
  301609,
  21832,
  192551,
  412598,
  186526,
  447005,
  112768,
  404399,
  289582,
  290124,
  191275,
  213003,
  39276,
  200971,
  315798,
  135302,
  121320,
  227480,
  156978,
  98919,
  201671,
  195988,
  186622,
  475967,
  314720,
  58582,
  404742,
  215008,
  306959,
  267381,
  126574,
  73725,
  156317,
  83010,
  375189,
  167000,
  459137,
  294856,
  144931,
  234176,
  371047,
  446790,
  219650,
  26577,
  64091,
  482916,
  203241,
  306809,
  178005,
  380280,
  452614,
  266272,
  264801,
  428464,
  342535,
  310436,
  297012,
  173959,
  384721,
  311372,
  375367,
  304633,
  247177,
  373217,
  43689,
  363227,
  447608,
  203474,
  186229,
  63975,
  189189,
  391682,
  197510,
  423160,
  168160,
  336488,
  11240,
  86706,
  316746,
  272065,
  50516,
  411785,
  25826,
  212663,
  233378,
  186547,
  268142,
  387972,
  275194,
  134600,
  337298,
  51510,
  206067,
  111837,
  461165,
  137209,
  317427,
  153989,
  464678,
  975,
  384374,
  433258,
  62611,
  413087,
  424810,
  449054,
  190150,
  310602,
  336220,
  71740,
  230657,
  453370,
  468144,
  322259,
  283775,
  1606,
  139348,
  352593,
  356482,
  156500,
  157489,
  454159,
  337203,
  63370,
  369541,
  170461,
  99771,
  398154,
  126177,
  281482,
  24217,
  234556,
  251792,
  201614,
  249765,
  130900,
  409074,
  46296,
  172953,
  194464,
  229313,
  120835,
  141417,
  187795,
  169516,
  352531,
  402467,
  433379,
  73331,
  345245,
  167093,
  176171,
  198482,
  486643,
  456439,
  449333,
  221367,
  481580,
  200704,
  197099,
  314035,
  336100,
  146714,
  415630,
  47127,
  287953,
  153548,
  438248,
  2664,
  325723,
  467719,
  408858,
  82963,
  180891,
  192679,
  86617,
  100068,
  2394,
  11764,
  48047,
  127406,
  149052,
  283994,
  342457,
  463547,
  320210,
  293252,
  6540,
  464926,
  265551,
  109109,
  164735,
  381110,
  29080,
  246178,
  355576,
  448267,
  430466,
  444401,
  126905,
  414347,
  451523,
  331926,
  366508,
  480803,
  387850,
  413867,
  17772,
  268744,
  427797,
  163955,
  333814,
  93663,
  338046,
  236013,
  180066,
  68685,
  466537,
  3904,
  277412,
  449845,
  16633,
  62120,
  108501,
  486885,
  60466,
  380719,
  269930,
  365432,
  377380,
  260009,
  300616,
  203897,
  289145,
  249814,
  26558,
  343110,
  48226,
  365643,
  401664,
  7355,
  350107,
  100836,
  99073,
  294093,
  7587,
  169932,
  166154,
  396054,
  108167,
  229069,
  307648,
  148531,
  233563,
  40093,
  44708,
  353913,
  456080,
  176129,
  156427,
  412072,
  154317,
  271015,
  126289,
  345876,
  156388,
  195860,
  25422,
  482057,
  362295,
  466187,
  115725,
  387438,
  170886,
  224753,
  126768,
  421612,
  96187,
  9314,
  194598,
  297360,
  121794,
  422582,
  428474,
  281996,
  211966,
  303980,
  232330,
  314475,
  485,
  146262,
  8780,
  459648,
  88780,
  371355,
  283376,
  480636,
  67695,
  153169,
  205011,
  52231,
  103646,
  432471,
  433747,
  16092,
  78487,
  165644,
  412660,
  451750,
  8088,
  185452,
  192135,
  355751,
  59734,
  341708,
  347491,
  466763,
  446951,
  670,
  392454,
  39840,
  469691,
  329363,
  61899,
  384770,
  317497,
  282776,
  211703,
  427937,
  284122,
  238949,
  417486,
  341081,
  241572,
  67225,
  294159,
  302865,
  227806,
  123006,
  329514,
  449279,
  31448,
  450144,
  485006,
  199737,
  253646,
  117814,
  408604,
  141399,
  121937,
  237632,
  315197,
  10397,
  318494,
  221051,
  444960,
  417643,
  90991,
  153828,
  291638,
  96654,
  280019,
  218632,
  74162,
  119769,
  20024,
  420771,
  219118,
  96325
  ]
  }
  }

  ```
</details>

#### Appendix H: Sync Committe Creation and Retrieval

**Sync Committee Configuration**

`EPOCHS_PER_SYNC_COMMITTEE_PERIOD` is set in [config.go](https://github.com/prysmaticlabs/prysm/blob/develop/config/params/config.go#L185) currently 255 epochs per synch comittee (approx 27 hrs) for Ethreum Mainnet.

**Sync Committee Update Process**

* [beacon-chain/blockchain](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/blockchain)
  * [process\_block.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/blockchain/process_block.go): has function `onBlock` which is called when a gossip block is received. It also has function `handleEpochBoundary` which calls `ProcessSlots` in [beacon-chain/core/transition](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/core/transition) and calls function `UpdateCommitteeCache` in [beacon-chain/core/helpers](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/core/helpers)
* [beacon-chain/core/transition](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/core/transition)
  * [transition.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/core/transition/transition.go): implements the whole state transition function which consists of per slot, per-epoch transitions. function `ProcessSlots` calls `ProcessEpoch` in [beacon-chain/core/altair/transition.go](\(%3Chttps://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/core/altair/transition.go\)%3E)
* [beacon-chain/core/altair](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/core/altair)
  * [transition.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/core/altair/transition.go): includes function `ProcessEpoch` which calls `ProcessSyncCommitteeUpdates` in [epoch\_spec.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/core/altair/epoch_spec.go)
  * [epoch\_spec.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/core/altair/epoch_spec.go): includes function `ProcessSyncCommitteeUpdates` which calls `NextSyncCommittee` it also persists beacon state syncCommittee by calling `beaconState.SetNextSyncCommittee(nextSyncCommittee)` in [setters\_sync\_committee.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/state/state-native/setters_sync_committee.go)
  * [sync\_committee.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/core/altair/sync_committee.go): includes function `NextSyncCommittee` which calls `NextSyncCommittee` to return the sync committee indices, with possible duplicates, for the next sync committee.
  * [block.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/core/altair/block.go): includes function `VerifySyncCommitteeSig`
* [beacon-chain/core/helpers](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/core/helpers)
  * [beacon\_committee.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/core/helpers/beacon_committee.go) has function `UpdateCommitteeCache` which gets called at the beginning of every epoch to cache the committee shuffled indices list with committee index and epoch number. It caches the shuffled indices for current epoch and next epoch. it calls `UpdatePositionsInCommittee` in [sync\_committee.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/cache/sync_committee.go)
* [beacon-chain/cache](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/cache)
  * [sync\_committee.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/cache/sync_committee.go): has function `UpdatePositionsInCommittee` which updates caching of validators position in sync committee in respect to current epoch and next epoch. This should be called when `current_sync_committee` and `next_sync_committee` change and that happens every `EPOCHS_PER_SYNC_COMMITTEE_PERIOD`.

**Sync Committee Retrieval**
gRPC and API methods

* [beacon-chain/rpc](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/rpc)
  * [prysm/v1alpha1](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/rpc/prysm/v1alpha1)
    * [validator](https://github.com/prysmaticlabs/prysm/tree/develop/beacon-chain/rpc/prysm/v1alpha1/validator)
      * [assignments.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/rpc/prysm/v1alpha1/validator/assignments.go): has functions `GetDuties` and `StreamDuties` which calls function `duties` to compute the validator duties from the head state's corresponding epoch for validators public key / indices requested.

which [manages sync committee duties](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/rpc/prysm/v1alpha1/validator/assignments.go#L213) every `EPOCHS_PER_SYNC_COMMITTEE_PERIOD - 1` which is set in [config.go](https://github.com/prysmaticlabs/prysm/blob/develop/config/params/config.go#L185) currently 255 epochs per synch comittee (approx 27 hrs) for Ethreum Mainnet.

[registerSyncSubnetNextPeriod](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/rpc/prysm/v1alpha1/validator/assignments.go#L281)

```

func registerSyncSubnetNextPeriod(s beaconState.BeaconState, epoch types.Epoch, pubKey []byte, status ethpb.ValidatorStatus) error {
committee, err := s.NextSyncCommittee()
if err != nil {
return err
}
syncCommPeriod := slots.SyncCommitteePeriod(epoch)
registerSyncSubnet(epoch, syncCommPeriod+1, pubKey, committee, status)
return nil
}

```

**Sync Committee Storage**

Persistence Mechanism

* [proto](https://github.com/prysmaticlabs/prysm/tree/develop/proto)
  * [eth/v2](https://github.com/prysmaticlabs/prysm/tree/develop/proto/eth/v2)
    * [validator.proto](https://github.com/prysmaticlabs/prysm/blob/develop/proto/eth/v2/validator.proto): messages for validators including `SyncCommitteeDuty`
    * [sync\_committee.proto](https://github.com/prysmaticlabs/prysm/blob/develop/proto/eth/v2/sync_committee.proto): messages for SyncCommittee which serves as committees to facilitate light client syncing to beacon chain.

[beacon\_state\_mainnet.go](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/state/state-native/beacon_state_mainnet.go)

```

// BeaconState defines a struct containing utilities for the Ethereum Beacon Chain state, defining
// getters and setters for its respective values and helpful functions such as HashTreeRoot().
type BeaconState struct {
version int
genesisTime uint64
genesisValidatorsRoot [32]byte
slot eth2types.Slot
fork *ethpb.Fork
latestBlockHeader *ethpb.BeaconBlockHeader
blockRoots *customtypes.BlockRoots
stateRoots *customtypes.StateRoots
historicalRoots customtypes.HistoricalRoots
eth1Data *ethpb.Eth1Data
eth1DataVotes []*ethpb.Eth1Data
eth1DepositIndex uint64
validators []*ethpb.Validator
balances []uint64
randaoMixes *customtypes.RandaoMixes
slashings []uint64
previousEpochAttestations []*ethpb.PendingAttestation
currentEpochAttestations []*ethpb.PendingAttestation
previousEpochParticipation []byte
currentEpochParticipation []byte
justificationBits bitfield.Bitvector4
previousJustifiedCheckpoint *ethpb.Checkpoint
currentJustifiedCheckpoint *ethpb.Checkpoint
finalizedCheckpoint *ethpb.Checkpoint
inactivityScores []uint64
currentSyncCommittee *ethpb.SyncCommittee
nextSyncCommittee *ethpb.SyncCommittee
latestExecutionPayloadHeader *enginev1.ExecutionPayloadHeader
latestExecutionPayloadHeaderCapella \*enginev1.ExecutionPayloadHeaderCapella
nextWithdrawalIndex uint64
nextWithdrawalValidatorIndex eth2types.ValidatorIndex

lock sync.RWMutex
dirtyFields map[nativetypes.FieldIndex]bool
dirtyIndices map[nativetypes.FieldIndex][]uint64
stateFieldLeaves map[nativetypes.FieldIndex]*fieldtrie.FieldTrie
rebuildTrie map[nativetypes.FieldIndex]bool
valMapHandler *stateutil.ValidatorMapHandler
merkleLayers [][][]byte
sharedFieldReferences map[nativetypes.FieldIndex]\*stateutil.Reference
}

```

[beacon\_state.pb.go](https://github.com/prysmaticlabs/prysm/blob/develop/proto/prysm/v1alpha1/beacon_state.pb.go#L962)

```

type SyncCommittee struct {
state protoimpl.MessageState
sizeCache protoimpl.SizeCache
unknownFields protoimpl.UnknownFields

Pubkeys [][]byte `protobuf:"bytes,1,rep,name=pubkeys,proto3" json:"pubkeys,omitempty" ssz-size:"512,48"`
AggregatePubkey []byte `protobuf:"bytes,2,opt,name=aggregate_pubkey,json=aggregatePubkey,proto3" json:"aggregate_pubkey,omitempty" ssz-size:"48"`
}

```

[Interfaces](https://github.com/prysmaticlabs/prysm/blob/v3.1.2/beacon-chain/state/interfaces.go)

```

// BeaconState has read and write access to beacon state methods.
type BeaconState interface {
SpecParametersProvider
ReadOnlyBeaconState
ReadOnlyWithdrawals
WriteOnlyBeaconState
Copy() BeaconState
HashTreeRoot(ctx context.Context) ([32]byte, error)
FutureForkStub
StateProver
}

```

```

// StateProver defines the ability to create Merkle proofs for beacon state fields.
type StateProver interface {
FinalizedRootProof(ctx context.Context) ([][]byte, error)
CurrentSyncCommitteeProof(ctx context.Context) ([][]byte, error)
NextSyncCommitteeProof(ctx context.Context) ([][]byte, error)
}

```

```
```


## Harmony

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

Despite relatively lower usage than other candidates, Harmony has a mature, battle-tested implementation for fast consensus using BLS-based signature schemes, which has been in production for over 2 years. Additionally, many other chains are also moving towards using BLS for signing blocks in their consensus protocols.

Harmony follows a two-round Fast Byzantine Fault Tolerance consensus derived from PBFT, where BLS signatures (on the BLS12-381 curve) are used to reduce communication costs[^1]. Blocks are produced by validator leaders, a minimal subset of validators, then further broadcasted to all validators and confirmed when more than 2/3 of validators sign the block with their own BLS signatures. The leader then aggregates the signatures into a single one and broadcasts again. The validators may verify the aggregated signature and sign the block again before sending the signed block back to the leader. Finally, the leader (after receiving signatures from 2/3 of the validators) may aggregate the signature for one last time and finalize the block. In the block header, the leader records which validators' signatures are received in each round.

The protocol uses a slot-bidding mechanism to elect a variable number of validators to fill 800-slots, where each validator may occupy multiple slots if their total delegated stake per slot is greater than the effective median[^2].

### Consensus Mechanism

#### Harmony Fast Byzantine Fault Tolerance (FBFT)

The following is an excerpt from [Consensus](https://docs.harmony.one/home/general/technology/consensus)

> The consensus algorithm is a key component of any blockchain. It determines the security and performance of a blockchain and is often referred to as the "engine" of a blockchain. Harmony’s consensus algorithm is called Fast Byzantine Fault Tolerance (FBFT), which is an innovative upgrade on the famous PBFT algorithm. FBFT is one order of magnitude faster and more scalable than PBFT because BLS (Boneh–Lynn–Shacham) aggregate signature is used to significantly reduce the communication cost. Specifically, FBFT allows at least 250 validators to reach consensus within 2 seconds.
>
> For every round of consensus in FBFT, one validator serves as the “leader” and there are three phases: the announce phase, the prepare phase and the commit phase. In the announce phase, the leader proposes a new block and broadcasts the block hash to all of the validators. In the prepare phase, validators verify the message and sign on the block hash, as well as sending the signature back to the leader. The prepare phase finishes when signatures with more than 2/3 of the voting power are collected. After that, the leader aggregated the collected signatures into a O(1)-sized BLS aggregate signature and then broadcast it with the whole block to start the commit phase. The commit phase involves validators verifying the block and doing a similar signing process as the prepare phase (i.e. 2/3 voting power collection). The consensus is reached after the commit phase is done. This whole process can be done within 2 seconds in mainnet.

The following is an excerpt from [Epoch Transition](https://docs.harmony.one/home/network/validators/definitions/epoch-transition)

> An epoch is a period of time when the beacon shard (i.e. shard 0, the coordinator for other shards) produces a fixed number of blocks. In Harmony mainnet, an epoch is 32768 blocks (\~18.2h with a 2s block time) in the beacon shard

*Note: If the leader fails to produce a block within a certain time frame, then a new leader is elected*

![Harmony FBFT](/assets//research/harmony-consensus.png "Harmony FBFT")

Block Structure from [harmony](https://github.com/harmony-one/harmony/blob/main/block/v3/header.go)

```
type headerFields struct {
 ParentHash          common.Hash    `json:"parentHash"       gencodec:"required"`
 Coinbase            common.Address `json:"miner"            gencodec:"required"`
 Root                common.Hash    `json:"stateRoot"        gencodec:"required"`
 TxHash              common.Hash    `json:"transactionsRoot" gencodec:"required"`
 ReceiptHash         common.Hash    `json:"receiptsRoot"     gencodec:"required"`
 OutgoingReceiptHash common.Hash    `json:"outgoingReceiptsRoot"     gencodec:"required"`
 IncomingReceiptHash common.Hash    `json:"incomingReceiptsRoot" gencodec:"required"`
 Bloom               ethtypes.Bloom `json:"logsBloom"        gencodec:"required"`
 Number              *big.Int       `json:"number"           gencodec:"required"`
 GasLimit            uint64         `json:"gasLimit"         gencodec:"required"`
 GasUsed             uint64         `json:"gasUsed"          gencodec:"required"`
 Time                *big.Int       `json:"timestamp"        gencodec:"required"`
 Extra               []byte         `json:"extraData"        gencodec:"required"`
 MixDigest           common.Hash    `json:"mixHash"          gencodec:"required"`
 // Additional Fields
 ViewID              *big.Int `json:"viewID"           gencodec:"required"`
 Epoch               *big.Int `json:"epoch"            gencodec:"required"`
 ShardID             uint32   `json:"shardID"          gencodec:"required"`
 LastCommitSignature [96]byte `json:"lastCommitSignature"  gencodec:"required"`
 LastCommitBitmap    []byte   `json:"lastCommitBitmap"     gencodec:"required"` // Contains which validator signed
 Vrf                 []byte   `json:"vrf"`
 Vdf                 []byte   `json:"vdf"`
 ShardState          []byte   `json:"shardState"`
 CrossLinks          []byte   `json:"crossLink"`
 Slashes             []byte   `json:"slashes"`
}
```

### Signing Mechanism

Harmony uses BLS12\_381 signatures for validators signing blocks. They began work on enhancing the [herumi/bls package](https://github.com/herumi/bls) in Jan 2019 to [support BLS12\_381](https://github.com/harmony-one/bls/commit/302fc1eea9d59cecb1a464280944f5b152d7e781). They have added [bls](https://github.com/harmony-one/harmony/blob/main/crypto/bls/bls.go) and [mutibls](https://github.com/harmony-one/harmony/blob/main/multibls/multibls.go) to the [harmony codbase](https://github.com/harmony-one/harmony) leveraging their [harmony-one bls package](https://github.com/harmony-one/bls).

### Light Client Support

Harmony is actively looking at light client support[^3].

Some initial work has been done for the support of [Merkle Mountain Ranges](https://github.com/opentimestamps/opentimestamps-server/blob/master/doc/merkle-mountain-range.mdx) has been proposed by Harmony in the pull request [\[WIP\] MMR-HardFork: add go-merklemountainrange and modified merkle proof logic #3872](https://github.com/harmony-one/harmony/pull/3872).

This introduces a new field into the block header populated by [mmr.go](https://github.com/gupadhyaya/harmony/blob/mmr-hard-fork/internal/mmr/mmr.go) which credits [zmitton/go-merklemountainrange](https://github.com/zmitton/go-merklemountainrange).

Updated [Interface.go](https://github.com/gupadhyaya/harmony/blob/mmr-hard-fork/block/interface/header.go)

```
// MMRRoot is the root of the Merkle Mountain Range tree formed
// using the block hashes of the current epoch
MMRRoot() []byte

// SetMMRRoot sets the updated MMR root after appending the parentHash
SetMMRRoot(newMMRRoot []byte)
```

Updated [header.go](https://github.com/gupadhyaya/harmony/blob/mmr-hard-fork/block/v4/header.go)

```
// MMRRoot is the root of the Merkle Mountain Range tree formed
// using the block hashes of the current epoch
func (h *Header) MMRRoot() []byte {
 return append(h.fields.MMRRoot[:0:0], h.fields.MMRRoot...)
}

// SetMMRRoot sets the updated MMR root after appending the parentHash
func (h *Header) SetMMRRoot(newMMRRoot []byte) {
 h.fields.MMRRoot = append(newMMRRoot[:0:0], newMMRRoot...)
}
```

Harmony [MMR PR Review](https://github.com/harmony-one/harmony/pull/3872) and [latest PR](https://github.com/harmony-one/harmony/pull/4198/files) uses Merkle Mountain Ranges to facilitate light client development against Harmony's sharded Proof of Stake Chain.

**Key Core Protocol Changes Include**
Block Structure from [harmony](https://github.com/peekpi/harmony/blob/mmrHardfork/block/v4/header.go) with [Merkle Mountain Range](https://docs.grin.mw/wiki/chain-state/merkle-mountain-range/) support [Mmr hardfork](https://github.com/harmony-one/harmony/pull/3872) [PR 4198](https://github.com/harmony-one/harmony/pull/4198) introduces `MMRoot`

GOAL: Allow verification that previous blocks were valid based on the MMRRoot Passed.

Features

* add receipt proof
* adding MMRRoot field to block header & cross-chain epoch
* add memdb and filedb mmr processing logic
* add GetProof rpc
* relayer rpcs for fetching full header
* adding block signers for rpc response, debug-only
* minor testing bls
* fix merge conflicts
* github.com/zmitton/go-merklemountainrange dependency
* minor fix
* moving mmr root compute/update logic to after the shard state is computed
* fix getting siblings bug
* adding index to mmr-proof and GetProof with respect to a block number
* check if mmr directory exists, if not create it first
* fixing failing test
* fixing config build test failure
* fixing more test failures
* cleanup
* turn of signers
* fix header copy issue and write mmr root directly to node.worker header
* fix nil pointer problems, shard state fetch issue, and refIndex bug
* clean up

```
type headerFields struct {
 ParentHash          common.Hash    `json:"parentHash"       gencodec:"required"`
 Coinbase            common.Address `json:"miner"            gencodec:"required"`
 Root                common.Hash    `json:"stateRoot"        gencodec:"required"`
 TxHash              common.Hash    `json:"transactionsRoot" gencodec:"required"`
 ReceiptHash         common.Hash    `json:"receiptsRoot"     gencodec:"required"`
 OutgoingReceiptHash common.Hash    `json:"outgoingReceiptsRoot"     gencodec:"required"`
 IncomingReceiptHash common.Hash    `json:"incomingReceiptsRoot" gencodec:"required"`
 Bloom               ethtypes.Bloom `json:"logsBloom"        gencodec:"required"`
 Number              *big.Int       `json:"number"           gencodec:"required"`
 GasLimit            uint64         `json:"gasLimit"         gencodec:"required"`
 GasUsed             uint64         `json:"gasUsed"          gencodec:"required"`
 Time                *big.Int       `json:"timestamp"        gencodec:"required"`
 Extra               []byte         `json:"extraData"        gencodec:"required"`
 MixDigest           common.Hash    `json:"mixHash"          gencodec:"required"`
 // Additional Fields
 ViewID              *big.Int    `json:"viewID"           gencodec:"required"`
 Epoch               *big.Int    `json:"epoch"            gencodec:"required"`
 ShardID             uint32      `json:"shardID"          gencodec:"required"`
 LastCommitSignature [96]byte    `json:"lastCommitSignature"  gencodec:"required"`
 LastCommitBitmap    []byte      `json:"lastCommitBitmap"     gencodec:"required"` // Contains which validator signed
 Vrf                 []byte      `json:"vrf"`
 Vdf                 []byte      `json:"vdf"`
 ShardState          []byte      `json:"shardState"`
 CrossLinks          []byte      `json:"crossLink"`
 Slashes             []byte      `json:"slashes"`
 MMRRoot             common.Hash `json:"mmrRoot"`
}
```

**Sample Light Client Implementation: Horizon Bridge Harmony Light Client Deployed on Ethereum**

This enables the validation of previous blocks by implemented by [TokenLockerOnEthereum.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/TokenLockerOnEthereum.sol) to use [MMRVerifier.sol](https://github.com/johnwhitton/horizon/blob/refactorV2/contracts/lib/MMRVerifier.sol) uses `./lib/MMRVerifier.sol` to validate the [Mountain Merkle Ranges](https://github.com/opentimestamps/opentimestamps-server/blob/master/doc/merkle-mountain-range.mdx)

### Code Review

The [Harmony codebase](https://github.com/harmony-one/harmony) was originally cloned from [Ethereum 1.0](./ethereum-1-0.mdx) around 2019.Thus the majority of code incuding primitives, signing are similar as at that period. Since then Ethreum has worked siginficantly on Ethreum 2.0 and these modifications were selectively leveraged by Harmony.

[Harmony has significant differences](https://medium.com/harmony-one/2022-harmony-technical-review-88462efba368) from Ethereum 1.0 including sharding, Effective Proof of Stake Consensus Mechanism, [Rosetta support](https://www.rosetta-api.org/docs/welcome.html) and verifiable delay functions and verifiaable random functions.

#### Signing

* [bls](https://github.com/harmony-one/harmony/blob/main/crypto/bls/bls.go): An implementation of BLS threshold signature
* [multibls](https://github.com/harmony-one/harmony/blob/main/multibls/multibls.go): Wrapper for a collection of bls private and public keys with dedup functionality and the ability to serialize to a hex string.

#### Consensus

* [consensus](https://github.com/harmony-one/harmony/tree/main/consensus): Consensus package includes the Harmony BFT consensus protocol code, which uses BLS-based multi-signature to cosign the new block. (details are [here](https://talk.harmony.one/t/bls-based-practical-bft-consensus/131)).
* [hmy](https://github.com/harmony-one/harmony/tree/main/hmy): implements the Harmony full node service.

#### Sharding

* [shard](https://github.com/harmony-one/harmony/tree/main/shard): Trackes the shard state and committee assignment.

#### Staking

* [staking](https://github.com/harmony-one/harmony/tree/main/staking): Implements staking for [Harmony's Effective Proof of Stake](https://blog.harmony.one/introducing-harmonys-effective-proof-of-stake-epos/)
  * [apr](https://github.com/harmony-one/harmony/tree/main/staking/apr): Calculates the expected rewards per year and the rewards for Validators.
  * [availablity](https://github.com/harmony-one/harmony/tree/main/staking/availability): Measures the availability of validators.
  * [effective](https://github.com/harmony-one/harmony/tree/main/staking/effective): Calcualates a validators effective proof of stake.
  * [newtwork](https://github.com/harmony-one/harmony/tree/main/staking/network): Calculates the network rewards.
  * [reward](https://github.com/harmony-one/harmony/tree/main/staking/reward): Checks whether rewards are issued and if so calculates the rewards based on total tokens staked.
  * [slash](https://github.com/harmony-one/harmony/tree/main/staking/slash): Slashes validators for malevolent acts such as double signing.
  * [types](https://github.com/harmony-one/harmony/tree/main/staking/types): Type definitions for staking structures.
  * [verify](https://github.com/harmony-one/harmony/tree/main/staking/verify): verifies aggregate signatures

#### Rosetta

* [rosetta](https://github.com/harmony-one/harmony/tree/main/rosetta): responsible for staring a [rosetta](https://www.rosetta-api.org/docs/welcome.html) http server.

#### Cryptographic Primitives

**hash functions**

* [hash](https://github.com/harmony-one/harmony/tree/main/crypto/hash): Uses kecakk256 and sha256 and provides the abilty to hash the RLP representation of the given object.

**random number generators**

* [VDF](https://github.com/harmony-one/harmony/tree/main/crypto/vdf): Verifiable Random Delay Function. Package vdf is a proof-of-concept implementation of a delay function and the security properties are not guaranteed. A more secure implementation of the [VDF by Wesolowski](https://eprint.iacr.org/2018/623.pdf) is to be implemented.
* [VRF](https://github.com/harmony-one/harmony/tree/main/crypto/vrf): a pseudorandom function f\_k from a secret key k, such that that knowledge of k not only enables one to evaluate f\_k at for any message m, but also to provide an NP-proof that the value f\_k(m) is indeed correct without compromising the unpredictability of f\_k for any m' != m. See [Verifiable Random Functions](https://dash.harvard.edu/bitstream/handle/1/5028196/Vadhan_VerifRandomFunction.pdf?sequence=2\&isAllowed=y).

### References

**Consensus**

* [Harmony FBFT Consensus Documentation](https://docs.harmony.one/home/general/technology/consensus): Harmony’s consensus algorithm is called Fast Byzantine Fault Tolerance (FBFT), which is an innovative upgrade on the famous PBFT algorithm. As an implementation detail, note that custom [generator points are used](https://github.com/herumi/bls/issues/74).
* [Harmony Slot Bidding and Election](https://docs.harmony.one/home/network/validators/definitions/slots-bidding-and-election)
* [Building a Better Blockchain: The Implementation of External Leader Rotation on Harmony](https://docs.harmony.one/home/network/validators/definitions/slots-bidding-and-election): A proposal to improve the leader rotatation by introducing changes to incldue external validators.
* [Harmony consensus.go Code](https://github.com/harmony-one/harmony/blob/main/consensus/consensus.go): Harmony Consensus logic (go)
* [Harmony quorom.go](https://github.com/harmony-one/harmony/blob/main/consensus/quorum/quorum.go): Harmony's quorom logic responsible for trakcing participants, submitting and aggregating votes.
* [Merkle Mountain Ranges](https://docs.grin.mw/wiki/chain-state/merkle-mountain-range/): Merkle Mountain Ranges1 are an alternative to Merkle trees2. While the latter relies on perfectly balanced binary trees, the former can be seen either as list of perfectly balance binary trees or a single binary tree that would have been truncated from the top right.
* [Harmony MMR-Hardfork Pull Request 3872](https://github.com/harmony-one/harmony/pull/3872): a MMR hard fork PR that adds mmrRoot to block header, adds logic to compute the MMR tree every epoch, RPCs to fetch the MMR proof for any given transaction.
* [Harmony MMR Hardfork Pull Request 4198](https://github.com/harmony-one/harmony/pull/4198): Follow up MMR pull request. *MMR is a series of perfect Merkle trees, from high to low. Each Merkle tree root we call it peak. Concat all peak hash and hash it, will get MMR root hash.*
* [Harmony MMRHardfork block header](https://github.com/peekpi/harmony/blob/mmrHardfork/block/v4/header.go): Harmony proposed block header including Merkle Mountain range (go).

**Signing**

* [Harmony bls.go codebase](https://github.com/harmony-one/bls/blob/master/ffi/go/bls/bls.go): Harmony's BLS library forked from [herumi/bls](https://github.com/herumi/bls) (go).

**Staking**

* [Harmony Effective Proof of Stake Documentation](https://docs.harmony.one/home/general/technology/effective-proof-of-stake): A staking mechanism for Harmony's sharded blockchain that achieves both security and decentralization using effective stake.
* [Harmony Staking Dashboard](https://staking.harmony.one/validators/mainnet): Staking Dashboard showing approximately 140 Elected Validators from 299 active validators.

### Footnotes

[^1]: [Harmony consensus documentation](https://docs.harmony.one/home/general/technology/consensus). As an implementation detail, note that custom [generator points are used](https://github.com/herumi/bls/issues/74)

[^2]: [Harmony Slot Bidding and Election](https://docs.harmony.one/home/network/validators/definitions/slots-bidding-and-election)

[^3]: [Scaling the Harmony Protocol with Light Clients](https://medium.com/harmony-one/scaling-the-harmony-protocol-with-light-clients-66d1eab26bf): a step-by-step guide on how to develop and run a light client on the Harmony Protocol using code examples.


## Chain Research

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

Here we do a deep dive on individual chains with a focus on the following areas

* Consensus Mechanism
* Signing Algorithms Supported
* Light Client Support
* Gas Costs
* Settlement Time
* Codebases

### Chain Economics

Following is an overview of the economics of sample chains. These chains are early candidates for the design and implementation of trustless bridging that we have been doing.

| Chain     | Token                                                 | Token Price | Market Capitalization | Total Value Locked                                        |
| --------- | ----------------------------------------------------- | ----------- | --------------------- | --------------------------------------------------------- |
| Avalanche | [AVAX](https://www.coingecko.com/en/coins/avalanche)  | $17.83      | $5,619,898,947        | [$912,440,000](https://defillama.com/chain/Avalanche)     |
| BSC       | [BNB](https://www.coingecko.com/en/coins/bnb)         | $308.08     | $48,646,681,885       | [$4,840,000,000](https://defillama.com/chain/BSC)         |
| Cosmos    | [ATOM](https://www.coingecko.com/en/coins/cosmos-hub) | $13.53      | $3,959,718,206        | [$1,218,000,000](https://defillama.com/chains/Cosmos) +++ |
| Ethereum  | [ETH](https://www.coingecko.com/en/coins/ethereum)    | $1,519.29   | $183,069,985,916      | [$27,850,000,000](https://defillama.com/chain/Ethereum)   |
| Harmony   | [ONE](https://www.coingecko.com/en/coins/harmony)     | $0.0244     | $299,878,381          | [$6,958,436](https://defillama.com/chain/Harmony)         |
| Polygon   | [MATIC](https://www.coingecko.com/en/coins/polygon)   | $1.24       | $11,171,619,834       | [$1,170,000,000](https://defillama.com/chain/Polygon)     |
| Pokadot   | [DOT](https://www.coingecko.com/en/coins/polkadot)    | $6.22       | $7,475,485,172        | [$278,000,000](https://defillama.com/chains/Parachain) ++ |

*The above data is from Feburary 11th, 2023. Links are provided to get current information.*

*++ Polkadot TVL includes all parachains*

*+++ Cosmos TVL include all cosmos based networks*

### Chain Technology

Following is an overview of the consensus, signing and staking mechanisms for sample chains. These chains are early candidates for the design and implementation of trustless bridging that we have been doing.

| Chain      | Consensus                                                                                                                                                                                                                                                                           | Signing                                                                                                                                      | Staking                                                                                               | Validators                                                                        | Subnets                                                                                                       |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| Avalanche  | [Snowball](https://docs.avax.network/overview/getting-started/avalanche-consensus), [White Paper](https://assets.website-files.com/5d80307810123f5ffbb34d6e/6009805681b416f34dcae012_Avalanche%20Consensus%20Whitepaper.pdf)                                                        | [rsa](https://en.wikipedia.org/wiki/RSA_\(cryptosystem\))                                                                                    | [Avalanche Staking](https://docs.avax.network/nodes/validate/staking#staking-parameters-on-avalanche) | [1215](https://subnets.avax.network/validators)                                   | [45](https://subnets.avax.network/subnets) [subnets](https://docs.avax.network/subnets)                       |
| BSC        | [Parlia](https://docs.bnbchain.org/docs/learn/consensus/#consensus-protocol)                                                                                                                                                                                                        | [secp256k1](https://docs.bnbchain.org/docs/beaconchain/learn/accounts/#signature)                                                            | [PoSA](https://docs.bnbchain.org/docs/stake/Staking/)                                                 | [50](https://www.bnbchain.org/en/staking)                                         |                                                                                                               |
| Cosmos Hub | [Tendermint](https://docs.tendermint.com/v0.34/introduction/what-is-tendermint.html)                                                                                                                                                                                                | [ed25519](https://ed25519.cr.yp.to/) [Validator Keys](https://docs.tendermint.com/v0.34/tendermint-core/validators.html#validator-keys)      | [Cosmos Staking](https://docs.cosmos.network/v0.46/modules/staking/)                                  | [504](https://www.mintscan.io/cosmos/validators)                                  | [21](https://defillama.com/chains/Cosmos) [Chains](https://docs.cosmos.network/main/intro/why-app-specific)   |
| Ethereum   | [Gasper](https://arxiv.org/pdf/2003.03052.pdf)                                                                                                                                                                                                                                      | BLS                                                                                                                                          | [PoS](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/)                              | [16,477,159](https://ethereum.org/en/staking/)                                    |                                                                                                               |
| Harmony    | [FBFT](https://docs.harmony.one/home/general/technology/consensus)                                                                                                                                                                                                                  | [BLS](https://medium.com/@caseyga/exploring-bls-keys-on-the-harmony-protocol-understanding-generation-management-and-use-cases-b8722f7219fc) | [EPoS](https://docs.harmony.one/home/general/technology/effective-proof-of-stake)                     | [299](https://staking.harmony.one/validators/mainnet)                             | [4](https://explorer.harmony.one/) [shards](https://docs.harmony.one/home/general/technology/sharding)        |
| Polygon    | [Peppermint](https://wiki.polygon.technology/docs/pos/peppermint/), [Heimdall and Bor](https://polygon.technology/blog/heimdall-and-bor), \_[Heimdall](https://wiki.polygon.technology/docs/pos/heimdall/overview/), [BOR](https://wiki.polygon.technology/docs/pos/bor/consensus/) | secp256k1                                                                                                                                    | [Heimdall Staking](https://wiki.polygon.technology/docs/pos/heimdall/modules/staking/)                | [100](https://staking.polygon.technology/)                                        |                                                                                                               |
| Polkadot   | [NPoS](https://wiki.polkadot.network/docs/learn-consensus)                                                                                                                                                                                                                          | [Sr25519](https://wiki.polkadot.network/docs/learn-cryptography#what-is-sr25519-and-where-did-it-come-from)                                  | [Nominated Pools](https://wiki.polkadot.network/docs/learn-staking)                                   | [1200](https://staking.polkadot.network/?utm_source=polkadot.network#/validators) | [36](https://polkadot.subscan.io/parachain) [parachains](https://wiki.polkadot.network/docs/learn-parachains) |

*The above data is from Feburary 11th, 2023. Links are provided to get current information.*

### Consensus Implementations

#### Consensus

* [avalanche](https://github.com/ava-labs/avalanchego/blob/master/snow/README.mdx) (go)
  * [avalanche](https://github.com/ava-labs/avalanchego/tree/master/snow/consensus/avalanche): a general avalanche instance that can be used directly to process a series of partially ordered elements.
  * [snowball](https://github.com/ava-labs/avalanchego/tree/master/snow/consensus/snowball): a general snow instance that can be used directly to process the results of network queries.
  * [snowman](https://github.com/ava-labs/avalanchego/tree/master/snow/consensus/snowman): a general snowman instance that can be used directly to process a series of dependent operations.
  * [snowstorm](https://github.com/ava-labs/avalanchego/tree/master/snow/consensus/snowstorm): a snowball instance deciding between an unbounded number of non-transitive conflicts. After performing a network sample of k nodes, you should call collect with the responses.
  * [Snowman++: congestion control for Snowman VMs](https://github.com/ava-labs/avalanchego/blob/master/vms/proposervm/README.mdx): Snowman++ introduces a soft proposer mechanism which attempts to select a single proposer with the power to issue a block, but opens up block production to every validator if sufficient time has passed without blocks being generated.
  * [Avalanche Warp Messaging (AWM)](https://medium.com/avalancheavax/avalanche-warp-messaging-awm-launches-with-the-first-native-subnet-to-subnet-message-on-avalanche-c0ceec32144a): AWM enables Subnet Validators to collectively produce a BLS Multi-Signature that attests to the validity of an arbitrary message (e.g., transfer, contract data, etc.) that can be verified by any other Subnet.
* [bsc](https://github.com/bnb-chain/bsc/tree/master/consensus) (go)
  * [beacon](https://github.com/bnb-chain/bsc/blob/master/consensus/beacon/consensus.go): Beacon is a consensus engine that combines the eth1 consensus and proof-of-stake algorithm. There is a special flag inside to decide whether to use legacy consensus rules or new rules. The transition rule is described in the eth1/2 merge spec [eip-3675](https://eips.ethereum.org/EIPS/eip-3675). The beacon here is a half-functional consensus engine with partial functions which is only used for necessary consensus checks. The legacy consensus engine can be any engine implements the consensus interface (except the beacon itself).
  * [clique](https://github.com/bnb-chain/bsc/blob/master/consensus/clique/clique.go): Clique is the proof-of-authority consensus engine proposed to support the Ethereum testnet following the Ropsten attacks.
  * [ethash](https://github.com/bnb-chain/bsc/blob/master/consensus/ethash/consensus.go): Ethash proof-of-work protocol (obsolete).
  * [misc](https://github.com/bnb-chain/bsc/tree/master/consensus/misc): includes code for [eip-1559](https://eips.ethereum.org/EIPS/eip-1559), DAO hard-fork extension to the header validity, VerifyForkHashes verifies that blocks conforming to network hard-forks do have the correct hashes and erifyGaslimit verifies the header gas limit according increase/decrease in relation to the parent gas limit.
  * [parlia](https://github.com/bnb-chain/bsc/blob/master/consensus/parlia/parlia.go): Parlia is the consensus engine of BSC
* [ethereum](https://github.com/ethereum/consensus-specs)
  * [Ethreum 2.0 Fork Choice](https://github.com/ethereum/consensus-specs/blob/v0.12.1/specs/phase0/fork-choice.mdx)
  * [Paths toward single-slot finality](https://notes.ethereum.org/@vbuterin/single_slot_finality): A look at how to improve Ethereum’s LMD GHOST + Casper FFG consensus.
    * [lighthouse](https://github.com/sigp/lighthouse/tree/stable/consensus/fork_choice) (rust): stores the actual block DAG in `ProtoArrayForkChoice`. - `time` is represented using `Slot` instead of UNIX epoch `u64`.
  * \[proto\_array]
    * [lighthouse proto\_array](https://github.com/sigp/lighthouse/tree/stable/consensus/proto_array) (rust): ProtoArray iterates backwards through the array, touching all nodes and their parents and potentially the best-child of each parent. The structure of the `self.nodes` array ensures that the child of each node is always touched before its parent.
  * [SerDes](https://en.wikipedia.org/wiki/SerDes): Serializer/Deserializer
    * [lighthouse serde\_utils](https://github.com/sigp/lighthouse/tree/stable/consensus/serde_utils) (rust)
  * [simple serialize](https://github.com/ethereum/eth2.0-specs/blob/v0.12.1/ssz/simple-serialize.mdx)
    * [lighthouse ssz](https://github.com/sigp/lighthouse/blob/stable/consensus/ssz/src/lib.rs) (rust): Provides encoding (serialization) and decoding(deserialization) in the SimpleSerialize (SSZ) format designed for use in Ethereum 2.0.
    * [lighthouse ssz\_derive](https://github.com/sigp/lighthouse/tree/stable/consensus/ssz_derive) (rust): Provides procedural derive macros for the `Encode` and `Decode` traits of the `eth2_ssz` crate.
    * [lighthouse ssz\_types](https://github.com/sigp/lighthouse/tree/stable/consensus/ssz_types) (rust): Provides types with unique properties required for SSZ serialization and Merklization
    * [prysm ssz.bzl](https://github.com/prysmaticlabs/prysm/blob/a7010d817dc839b0a46742dc286402357482da46/tools/ssz.bzl#L70) (bazel): A rule that uses the generated pb.go files from a go\_proto\_library target to generate SSZ marshal and unmarshal functions as pointer receivers on the specified objects.
  * [state\_processing](https://github.com/ethereum/consensus-specs/blob/dev/specs/bellatrix/beacon-chain.md#beacon-chain-state-transition-function)
    * [lighthouse state\_procesing](https://github.com/sigp/lighthouse/tree/stable/consensus/state_processing) (rust): State processing functions including block, slot and epoch functions.
  * [compute\_shuffled\_index](https://github.com/ethereum/consensus-specs/blob/v0.12.1/specs/phase0/beacon-chain.md#compute_shuffled_index)
    * [lighthouse swap\_or\_not\_shuffle](https://github.com/sigp/lighthouse/tree/stable/consensus/swap_or_not_shuffle) (rust): Provides list-shuffling functions matching the Ethereum 2.0 specification.
  * \[types]
    * [lighthouse types](https://github.com/sigp/lighthouse/tree/stable/consensus/types) (rust): Includes type definitions used in consensus including `beacon_block_header`, `beacon_comittee`, ,`beacon_state`, `sync_comitte` and more.
* [harmony](https://github.com/harmony-one/harmony/blob/main/consensus/README.mdx) (go)
  * [harmony consensus](https://github.com/harmony-one/harmony/tree/main/consensus)
* [near](https://nomicon.io/ChainSpec/Consensus) (rust)
  * [near nearcore](https://github.com/near/nearcore/tree/master/nearcore)
* [polkadot](https://wiki.polkadot.network/docs/learn-consensus) (rust): [code](https://github.com/paritytech/substrate/tree/master/primitives/consensus)
  * [aura](https://github.com/paritytech/substrate/tree/master/primitives/consensus/aura)
  * [babe](https://github.com/paritytech/substrate/tree/master/primitives/consensus/babe)
  * [beefy](https://github.com/paritytech/substrate/tree/master/primitives/consensus/beefy)
  * [grandpa](https://github.com/paritytech/substrate/tree/master/primitives/consensus/grandpa)
  * [pow](https://github.com/paritytech/substrate/tree/master/primitives/consensus/pow)
  * additional primitives
    * [common](https://github.com/paritytech/substrate/tree/master/primitives/consensus/common): Common utilities for building and using consensus engines in substrate.
    * [slots](https://github.com/paritytech/substrate/tree/master/primitives/consensus/slots): Primitives for slots-based consensus engines.
    * [vrf](https://github.com/paritytech/substrate/tree/master/primitives/consensus/vrf): Primitives for VRF-based consensus engines. Schnorrkel-based VRF.
* [polygon heimdall]() (go): Validator node for Matic Network. It uses peppermint, customized Tendermint. Here is where it sends validator updates to [peppermint](https://github.com/maticnetwork/heimdall/blob/develop/app/app.go#L625)
  * [polygon peppermint](https://github.com/maticnetwork/tendermint/tree/peppermint/consensus)(go): Peppermint is a modified Tendermint. It is changed to make it compatible with Ethereum addresses and verifiable on Ethereum chain. (docs are [here](https://wiki.polygon.technology/docs/pos/peppermint/))
* [tendermint tendermint](https://github.com/tendermint/tendermint/tree/main/consensus) (go)


## NEAR

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

Near supports We both secp256k1 and ed25519 for account keys and ed25519 for signing transactions. They currently use the ed25519\_dalek and sha2 libraries for crypto.

### Consensus Mechanism

Please review [NEAR Chainspec for Consensus](https://github.com/near/NEPs/blob/master/specs/ChainSpec/Consensus.md)

### Light Client Support

[NEAR Light Client Documentation](https://nomicon.io/ChainSpec/LightClient) gives an overview of how light clients work. At a high level the light client needs to fetch at least one block per [epoch](https://docs.near.org/concepts/basics/epoch) i.e. every 42,200 blocks or approxmiately 12 hours. Also Having the LightClientBlockView for block $B$ is sufficient to be able to verify any statement about state or outcomes in any block in the ancestry of $B$ (including $B$ itself).

> The RPC returns the LightClientBlock for the block as far into the future from the last known hash as possible for the light client to still accept it. Specifically, it either returns the last final block of the next epoch, or the last final known block. If there's no newer final block than the one the light client knows about, the RPC returns an empty result.
>
> A standalone light client would bootstrap by requesting next blocks until it receives an empty result, and then periodically request the next light client block.
>
> A smart contract-based light client that enables a bridge to NEAR on a different blockchain naturally cannot request blocks itself. Instead external oracles query the next light client block from one of the full nodes, and submit it to the light client smart contract. The smart contract-based light client performs the same checks described above, so the oracle doesn't need to be trusted.

Following is an exerpt from the [Near Light Client Specification](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md)

**Near Light Client**

> The state of the light client is defined by:
>
> 1. `BlockHeaderInnerLiteView` for the current head (which contains `height`, `epoch_id`, `next_epoch_id`, `prev_state_root`, `outcome_root`, `timestamp`, the hash of the block producers set for the next epoch `next_bp_hash`, and the merkle root of all the block hashes `block_merkle_root`);
> 2. The set of block producers for the current and next epochs.
>
> The `epoch_id` refers to the epoch to which the block that is the current known head belongs, and `next_epoch_id` is the epoch that will follow.

> Light clients operate by periodically fetching instances of `LightClientBlockView` via particular RPC end-point described [below](#rpc-end-points).

> Light client doesn't need to receive `LightClientBlockView` for all the blocks. Having the `LightClientBlockView` for block `B` is sufficient to be able to verify any statement about state or outcomes in any block in the ancestry of `B` (including `B` itself). In particular, having the `LightClientBlockView` for the head is sufficient to locally verify any statement about state or outcomes in any block on the canonical chain.
>
> However, to verify the validity of a particular `LightClientBlockView`, the light client must have verified a `LightClientBlockView` for at least one block in the preceding epoch, thus to sync to the head the light client will have to fetch and verify a `LightClientBlockView` per epoch passed.

**Near Rainbow Bridge: NEAR Light Client on Ethereum Sample Implementation**

*The following is an excerpt from a blog by near on [eth-near-rainbow-bridge](https://near.org/blog/eth-near-rainbow-bridge/)*

> NearOnEthClient is an implementation of the NEAR light client in Solidity as an Ethereum contract. Unlike EthOnNearClient it does not need to verify every single NEAR header and can skip most of them as long as it verifies at least one header per NEAR epoch, which is about 43k blocks and lasts about half a day. As a result, NearOnEthClient can memorize hashes of all submitted NEAR headers in history, so if you are making a transfer from NEAR to Ethereum and it gets interrupted you don’t need to worry and you can resume it any time, even months later. Another useful property of the NEAR light client is that every NEAR header contains a root of the merkle tree computed from all headers before it. As a result, if you have one NEAR header you can efficiently verify any event that happened in any header before it.
>
> Another useful property of the NEAR light client is that it only accepts final blocks, and final blocks cannot leave the canonical chain in NEAR. This means that NearOnEthClient does not need to worry about forks.
>
> However, unfortunately, NEAR uses [Ed25519](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-665.md) to sign messages of the validators who approve the blocks, and this signature is not available as an EVM precompile. It makes verification of all signatures of a single NEAR header prohibitively expensive. So technically, we cannot verify one NEAR header within one contract call to NearOnEthClient. Therefore we adopt the [optimistic approach](https://medium.com/@deaneigenmann/optimistic-contracts-fb75efa7ca84) where NearOnEthClient verifies everything in the NEAR header except the signatures. Then anyone can challenge a signature in a submitted header within a 4-hour challenge window. The challenge requires verification of a single Ed25519 signature which would cost about 500k Ethereum gas (expensive, but possible). The user submitting the NEAR header would have to post a bond in Ethereum tokens, and a successful challenge would burn half of the bond and return the other half to the challenger. The bond should be large enough to pay for the gas even if the gas price increases exponentially during the 4 hours. For instance, a 20 ETH bond would cover gas price hikes up to 20000 Gwei. This optimistic approach requires having a watchdog service that monitors submitted NEAR headers and challenges any headers with invalid signatures. For added security, independent users can run several watchdog services.

### References

**Consensus**

* [Consensus, NEAR Nomicon](https://nomicon.io/ChainSpec/Consensus)
* [NEAR blockchain core, (near)](https://github.com/near/nearcore)

**Signing**

* [Near Signing](https://docs.near.org/integrator/faq#how-are-cryptographic-functions-used): Near documentation on cryptographic functions.
* [nearcore signature.rs (codebase)](https://github.com/near/nearcore/blob/master/core/crypto/src/signature.rs): Near signature code (rust).

**Staking**

**Light Client**

* [Near Light Client](https://nomicon.io/ChainSpec/LightClient): Near Lithg Client Specification document.


## Polkadot

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

*Note: The majority of this research was done in early 2019 and has been updated recently with some notes on consenus and signing. In 2021 John built and deployed a Parachain called [Eave Network](https://eave.network/) codebase is [here](https://github.com/EaveNetwork). The parachain was deployed to the Rococo Testnet. John self funded this initiative, but failed to raise seed funding, due to this and other priorities this project was never fully developed and deployed on Kusama or Polkadot. Polkadot is one of John's favourite development frameworks and he is extremely grateful for Gavin Wood and Tomasz Drwięga who he was fortunate enough to collaborate with briefly on the Parity Ethereum Client in early 2016 as he began his blockchain journey.*

Polkadot substrate is a chain layer which allows pluggable consensus, definition of storage through the seperation of "extrinsics" and abstracts the runtime design allowing for blockchain providers to decide which runtime best suits there application needs. It also has been built with light client protocol in mind with a number of storage and pruning options giving the ability to clearly seperated different actors requirements for infrastructure (e.g. participants can run a light client on a mobile device and validators can run full nodes with gauranteed performance and uptime). On top of this Polkadot sits as a relay chain (built on Substrate) which allows private chains to share infrastucture such as validators.

### Consensus Mechanism

Following is an excerpt from [Polkadot learn consensus](https://github.com/w3f/polkadot-wiki/blob/master/docs/learn/learn-consensus.mdx)

> **Nominated Proof of Stake**

> In traditional PoS systems, block production participation is dependent on token holdings as opposed to computational power. While PoS developers usually have a proponent for equitable participation in a decentralized manner, most projects end up proposing some level of centralized operation, where the number of validators with full participation rights is limited. These validators are often seen to be the most wealthy, and, as a result, influence the PoS network as they are the most staked. Usually, the number of candidates to maintain the network with the necessary knowledge (and equipment) is limited; this can directly increase operational costs as well. Systems with a large number of validators tend to form pools to decrease the variance of their revenue and profit from economies of scale. These pools are often off-chain.

> A way to alleviate this is to implement pool formation on-chain and allow token holders to vote with their stake for validators to represent them.

> Polkadot uses NPoS (Nominated Proof-of-Stake) as its mechanism for selecting the validator set. It is designed with the roles of **validators** and **nominators**, to maximize chain security. Actors who are interested in maintaining the network can run a validator node.

> Validators assume the role of producing new blocks in [BABE](#block-production-babe), validating parachain blocks, and guaranteeing finality. Nominators can choose to back select validators with their stake. Nominators can approve candidates that they trust and back them with their tokens.

### References

**Consensus**

* [NPoS](https://wiki.polkadot.network/docs/learn-consensus): Polkadot Nominated Proof of Stake Documentation

* [Polkadot Consensus](https://wiki.polkadot.network/docs/learn-consensus): Polkadot's documentation on consenus.

* [Hybrid Consensus Slide](http://slides.com/paritytech/paritysubstrate#/17)

* [Generalized Consensus Pull Request](https://github.com/paritytech/substrate/pull/883)

* [Consensus Code](https://github.com/paritytech/substrate/tree/master/core/consensus)

* [Rhododendron - Asynchronously safe BFT consensus, implementation in Rust](https://github.com/paritytech/rhododendron)

* [Random Number Generation CSPRNG](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator)
  * [Rust-Random](https://github.com/rust-random/rand)

* Block Finality
  * [GRANDPA (GHOST-based Recursive Ancestor Deriving Prefix Agreement)](https://medium.com/polkadot-network/grandpa-block-finality-in-polkadot-an-introduction-part-1-d08a24a021b5)
    * [Finality GANDPA Code](https://github.com/paritytech/finality-grandpa)
    * [Substrate using GRANDPA](https://github.com/paritytech/substrate/blob/master/core/finality-grandpa/src/lib.rs)
    * [Full nodes should store a GRANDPA commit message](https://github.com/paritytech/substrate/issues/1026)
    * [Dynamic Authority sets in GRANDPA](https://github.com/paritytech/substrate/pull/1014)

**Signing**

* [Sr25519 Documentation](https://wiki.polkadot.network/docs/learn-cryptography#what-is-sr25519-and-where-did-it-come-from): Polkadots sr25519 Documentation. *The implementation of Schnorr signatures that is used in Polkadot and implements the Schnorrkel protocols over the Ristretto compression of the Curve25519 is known as sr25519.*
* [Substrate sr25519 codebase](https://github.com/paritytech/substrate/blob/master/primitives/application-crypto/src/sr25519.rs): Polkadot's sr25519 code (rust).
* [ED25519](https://ed25519.cr.yp.to/)

**Staking**

* [Polkadot Staking Documentation](https://wiki.polkadot.network/docs/learn-staking): Documentation on Polkadot including staking validators and Nominiated Pools
* [Staking Polkadot Application](https://staking.polkadot.network/?utm_source=polkadot.network#/validators): Polkadot Staking Application validator view.

**Parachains**

* [Subscan Explorer](https://polkadot.subscan.io/parachain): Block Explorer built for Polkadot and supporting all Parachains
* [parachains](https://wiki.polkadot.network/docs/learn-parachains): Polkadot documentation on Parachains

**Additional**

* Blockchain Explorers
  * [polkadash.io](http://polkadash.io/)
  * [polkascan.io](https://polkascan.io/)
    * [BBQ Birch - Testnet](https://polkascan.io/n-pre/bbqbirch/)
  * [poc-2.plokadot.io](https://poc-2.polkadot.io/#/explorer)
  * [Substrate Explorer](https://polkadot.js.org/apps/next/#/explorer)
  * [Telemetry.polkadot.io](https://telemetry.polkadot.io/#/Krumme%20Lanke)
* Substrate Overview
  * [What is Substrate](https://www.parity.io/what-is-substrate/)
    * Substrate [Video](https://www.youtube.com/watch?v=iUMZyL5kTwc) - [Slides](http://slides.com/paritytech/paritysubstrate#/)
      * [Potential Runtime Designs](http://slides.com/paritytech/paritysubstrate#/29)
    * [Parity Substrate Wiki](https://wiki.parity.io/Parity-Substrate)
  * [What is PolKadot](https://polkadot.network/#whatisit)
    * Polkadot Governance [Video](https://www.youtube.com/watch?v=VsZuDJMmVPY\&t=24735s\&list=PL6-IF807eaBG5sH-SQXlosqKRM2BZkrqw\&index=4) - [Slides](https://slides.com/paritytech/polkadot-governance#/)
    * [Polkadot Whitepaper](https://polkadot.network/PolkaDotPaper.pdf)
    * Polkadot [Video](https://youtu.be/lIghiCmHz0U?list=PLaZFi8ZkzUvKGyWTQ999rbHUXfDQv2LRF) [Slides](https://www.slideshare.net/gavofyork/polkadot-presentation)
    * Substrate : A Rustic Vision of Polkadot by Gavin Wood [Video](https://www.youtube.com/watch?v=0IoUZdDi5Is\&feature=youtu.be) - [Slides](https://slides.com/paritytech/substrate_web3summit#/1)
    * [Gavin Wood Podcast on Polkadot, Sharding and Substrate](https://www.zeroknowledge.fm/46)
    * [Polkadot runtime Environment : Alternative Implementation Grant](https://docs.google.com/document/d/1iaIWmfV-uA7Uv1O4yt9G2t_86q18h_r7i5T1t-_EZ-s/edit) - [Github](https://github.com/w3f/Web3-collaboration/issues/12)
  * [Token Economics - DOTS](https://polkadot.network/memorandum)
  * [Secret Store](https://wiki.parity.io/Secret-Store.html) shard key generation
  * [Parity Ethereum IPFS](https://wiki.parity.io/IPFS)
  * [Cosmos vs Polkadot](https://medium.com/@davekaj/blockchain-interoperability-cosmos-vs-polkadot-48097d54d2e2)
  * [Polkadot POC Tutorials](https://medium.com/coinmonks/polkadot-hello-world-3-poc-3-on-substrate-is-here-c45d100f72e3)
  * [Polkadot on Reddit](https://www.reddit.com/r/dot/)
  * [substrate.readme.io](https://substrate.readme.io/) - Substrate Developers Hub
  * [Substrate Workshop - Video](https://www.youtube.com/watch?time_continue=278\&v=26ucTSSaqog)
  * [Substrate Web 3 Summit - Slides](http://slides.com/paritytech/substrate_web3summit#/)
  * [Building on Substrate](https://hackmd.io/p_v1M8WGRyy9PggYiKA_Xw#)
  * [Polkadot 2018 Recap](https://medium.com/@gavofyork/polkadot-2018-recap-677dab3e995b)
* Relevant Code Links
  * Key Repositories
    * [ParityTech](https://github.com/paritytech)
      * [Substrate](https://github.com/paritytech/substrate)
        * [Generalize the Consensus Infrastructure](https://github.com/paritytech/substrate/pull/883)
          * [Pluggable Consensus Import Queue](https://github.com/paritytech/substrate/issues/784)
      * [Polkadot](https://github.com/paritytech/polkadot)
      * [WASMI](https://github.com/paritytech/wasmi)
  * [Web Assembly (WASM)](https://webassembly.org/)
    * [GO - support for WASM](https://github.com/golang/go/issues/18892)
    * [GO WAGON](https://github.com/go-interpreter/wagon)
    * [GO Perlin](https://github.com/perlin-network/life)
    * [Rust Parity Tech WASMI](https://github.com/paritytech/wasmi)
* Functional Breakdown
  * Persistence
    * Storage
      * [RocksDB](https://rocksdb.org/)
      * [DB Code](https://github.com/paritytech/substrate/tree/master/core/client/db)
      * Data Overview - Light Client
        * Block Structure [Slide 17](http://slides.com/paritytech/paritysubstrate#/17) to [28](http://slides.com/paritytech/paritysubstrate#/28)
      * [decl\_storage - macro](https://wiki.parity.io/decl_storage)
      * [Get and Set Storage](http://slides.com/paritytech/paritysubstrate#/14)
    * Light Client
      * [DB Code](https://github.com/paritytech/substrate/blob/master/core/client/db/src/light.rs)
      * [Light Client Code](https://github.com/paritytech/substrate/tree/master/core/client/src/light)
      * [Protocol Light Client Storage](https://github.com/paritytech/substrate/issues/131)
    * Node
      * [Client Code](https://github.com/paritytech/substrate/tree/master/core/client/src)
  * Gossip
    * [libp2p](https://github.com/ethereum/wiki/wiki/libp2p-Whitepaper)
    * [Substrate Code - network libp2p](https://github.com/paritytech/substrate/tree/master/core/network-libp2p)
    * [Get and Set Storage](http://slides.com/paritytech/paritysubstrate#/14)
    * Message Format
      * [Substrate Primitives](https://github.com/paritytech/substrate/tree/master/core/primitives)
      * [Polkadot Parachain Primitives](https://github.com/paritytech/polkadot/blob/master/primitives/src/parachain.rs)
      * [Polkadot Collator - Logic](https://github.com/paritytech/polkadot/blob/master/collator/src/lib.rs#L17)
  * [Execution](http://slides.com/paritytech/paritysubstrate#/15)
    * [Runtime](https://wiki.parity.io/impl_stubs)
    * [impl-stubs](https://wiki.parity.io/impl_stubs)
    * [SRML](https://github.com/paritytech/substrate/tree/master/srml)
    * [SRML Node Template](https://github.com/paritytech/substrate-node-template)
  * Polkadot - Relay Chain
    * [Whitepaper Overview - Participation in Polkadot](https://polkadot.network/PolkaDotPaper.pdf) - Page 4 gives an overview of the actors
    * [Collator](https://github.com/paritytech/substrate/blob/v0.2/polkadot/collator/src/lib.rs)
      * A collator node lives on a distinct parachain and submits a proposal fora state transition, along with a proof for its validity (what we might call a witness or block data).
    * [Pokadot Parachain](https://github.com/paritytech/substrate/blob/v0.2/polkadot/parachain/src/lib.rs) - Defines primitive types for creating or validating a parachain.
    * [Statement Table](https://github.com/paritytech/substrate/blob/v0.2/polkadot/statement-table/src/lib.rs) - This stores messages other authorities issue about candidates.
    * [Network](https://github.com/paritytech/substrate/tree/v0.2/polkadot/network) - Does the heavy lifting of routing the statements and gaining consensus across the relay chain (and associated parachains)
      * [Consensus](https://github.com/paritytech/substrate/blob/v0.2/polkadot/network/src/consensus.rs) - The "consensus" networking code built on top of the base network service. This fulfills the `polkadot_consensus::Network` trait, providing a hook to be called each time consensus begins on a new chain head.
      * [Consensus Pool](https://github.com/paritytech/substrate/blob/v0.2/polkadot/network/src/collator_pool.rs) - Bridge between the network and consensus service for getting collations to it.
      * [Router](https://github.com/paritytech/substrate/blob/v0.2/polkadot/network/src/router.rs) - Statement routing and consensus table router implementation.
    * [Fisherman (Misbehaviour check)](https://github.com/paritytech/substrate/blob/v0.2/substrate/misbehavior-check/src/lib.rs) - Utility for substrate-based runtimes that want to check misbehavior reports.
  * Hashing
    * [Substrate Code - hashing.rs](https://github.com/paritytech/substrate/blob/master/core/primitives/src/hashing.rs)
    * [Blake2](https://blake2.net/) [use in substrate](https://github.com/paritytech/substrate/search?q=blake2\&unscoped_q=blake2)
    * [XXHASH](https://cyan4973.github.io/xxHash/) [use in substrate](https://github.com/paritytech/substrate/search?q=TWOX\&unscoped_q=TWOX)
  * Chaincode (See WASM above)
    * [Rust Parity Tech WASMI](https://github.com/paritytech/wasmi)
    * [Use in Substrate Code](https://github.com/paritytech/substrate/search?q=wasmi\&unscoped_q=wasmi)
  * Deployment
    * Substrate
      * [Locally on Mac](https://github.com/paritytech/substrate#on-mac)
      * [From Code Base](https://github.com/paritytech/substrate#on-mac)
  * Polkadot Developer Tools
    * API
      * [Polkadot Javascript API](https://polkadot.js.org/api/)
    * RPC
      * [Substrate Code](https://github.com/paritytech/substrate/tree/master/core/rpc)
    * CLI
      * [CLI](https://github.com/paritytech/substrate/tree/master/core/cli)
    * SDK
  * Polkadot Chain Tools
    * Governance
      * [Democracy - Github](https://github.com/paritytech/substrate/blob/master/srml/democracy/src/lib.rs)
  * Substrate Prototyping
    * [Background Material](https://medium.com/coinmonks/polkadot-hello-world-3-poc-3-on-substrate-is-here-c45d100f72e3)
    * Deploying a Substrate Chain
      * [Overview](https://hackmd.io/y-E9Q9jTRreni6z9EU0kkA#)
      * [Locally](https://github.com/paritytech/substrate#on-mac)
      * [From Code Base](https://github.com/paritytech/substrate#on-mac)
      * [Current Issue with BBQ Birch](https://github.com/paritytech/substrate/issues/949) - [cause](https://github.com/paritytech/substrate/pull/900)
  * Deploying Polkadot
    * [Overview](https://github.com/paritytech/polkadot#4-hacking-on-polkadot)
  * Deploying a simple contract
    * [Preparing to build on Polkadot](https://medium.com/polkadot-network/preparing-to-build-on-polkadot-349ff5002885)
    * [Writing a WASM Contract](https://wiki.parity.io/WebAssembly-Home)
  * Running a Transaction
    * [Balance Transfer via API](https://polkadot.js.org/api/examples/promise/07_transfer_dots/)


## Polygon

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

Polygon is representative because it uses ECDSA on secp256k1 and a relatively fixed validator set.

The consensus protocol is based on Peppermint<sup>[8](#f8)</sup>, a modified version of Tendermint. Validators sign produced blocks using the ECDSA signature scheme on secp256k1 curves<sup>[9](#f9)</sup>. Currently, the validator set size is fixed at 100 and only changes when a current validator resigns. This restriction will change when a new auction mechanism is implemented.<sup>[10](#f10)</sup>

### Consensus Mechanism

Polygon uses Peppermint (a modified version of tendermint) Consensus.

Following is an excerpt from [Polygon Architecture](https://github.com/maticnetwork/matic-docs/blob/master/docs/pos/polygon-architecture.mdx).

**Polygon Architecture**

> Heimdall is the proof of stake validation layer that handles the aggregation of blocks produced by Bor into a Merkle tree and publishes the Merkle root periodically to the root chain. The periodic publishing of snapshots of the Bor sidechain is called checkpoints.
>
> 1. Validates all the blocks since the last checkpoint.
> 2. Creates a Merkle tree of the block hashes.
> 3. Publishes the Merkle root hash to the Ethereum mainnet.
>
> Checkpoints are important for two reasons:
>
> 1. Providing finality on the root chain.
> 2. Providing proof of burn in withdrawal of assets.
>
> An overview of the process:
>
> * A subset of active validators from the pool is selected to act as block producers for a span. These block producers are responsible for creating blocks and broadcasting the created blocks on the network.
> * A checkpoint includes the Merkle root hash of all blocks created during any given interval. All nodes validate the Merkle root hash and attach their signature to it.
> * A selected proposer from the validator set is responsible for collecting all signatures for a particular checkpoint and committing the checkpoint on the Ethereum mainnet.
> * The responsibility of creating blocks and proposing checkpoints is variably dependent on a validator’s stake ratio in the overall pool.
>
> More details on Heimdall are available on the Heimdall architecture guide.

This image from [Bor Architecture](https://wiki.polygon.technology/docs/pos/bor/) helps give a better understanding of how Ethereum, Heimdall and Bor work together.

![Matic Structure](/assets/research/matic_structure.png "Matic Structure")

### Signing Mechanism

Following is an excerpt from and [Peppermint.md](https://github.com/maticnetwork/matic-docs/blob/master/docs/pos/peppermint.mdx).

> Peppermint is a modified Tendermint. It is changed to make it compatible with Ethereum addresses and verifiable on Ethereum chain.
>
> Overview
>
> 1. Changes to signature scheme
> 2. Changes to `vote` to make it verifiable on Ethereum smart contract
> 3. Changes to `vote` encoding scheme
>
> Peppermint uses `secp256k1` signature scheme to verify Tendermint votes on solidity smart contract.
>
> Source: [https://github.com/maticnetwork/tendermint/blob/peppermint/crypto/secp256k1/secp256k1\_nocgo.go](https://github.com/maticnetwork/tendermint/blob/peppermint/crypto/secp256k1/secp256k1_nocgo.go)
>
> It adds `Data` field into `Vote` and `Proposal` struct to get `hash` for transactions in the block. On smart contract, it checks if `Data` matches with checkpoint data hash and majority (⅔+1) of validator signatures. The idea is to verify if majority of the validator set agrees on transaction in the contract.
>
> Peppermint uses RLP to get `Vote` bytes instead of Amino encoding. Here `Data` is `Txs.Hash()` for the block.
>
> Source: [https://github.com/maticnetwork/tendermint/blob/peppermint/types/canonical.go](https://github.com/maticnetwork/tendermint/blob/peppermint/types/canonical.go)

> ```go
> // [peppermint] create RLP vote to decode in contract
> type CanonicalRLPVote struct {
>  ChainID string
>  Type    byte
>  Height  uint
>  Round   uint
>  Data    []byte
> }
> ```
>
> And using RLP encoding lib to get byte data for signature on Vote.
>
> Source: [https://github.com/maticnetwork/tendermint/blob/peppermint/types/vote.go#L75-L82](https://github.com/maticnetwork/tendermint/blob/peppermint/types/vote.go#L75-L82)

> ```go
> func (vote *Vote) SignBytes(chainID string) []byte {
>  // [peppermint] converted from amino to rlp
>  bz, err := rlp.EncodeToBytes(CanonicalizeVote(chainID, vote))
>  if err != nil {
>   panic(err)
>  }
>  return bz
> }
> ```
>
> Complete Source: [https://github.com/maticnetwork/tendermint](https://github.com/maticnetwork/tendermint)

**Note: As of March 12th, 2023 the pepperming votes function now uses amino**

[tendermint/types/vote.go](https://github.com/maticnetwork/tendermint/blob/peppermint/types/vote.go)

```go
func (vote *Vote) SignBytes(chainID string) []byte {
 // [peppermint] converted from amino to rlp
 bz, err := cdc.MarshalBinaryLengthPrefixed(CanonicalizeVote(chainID, vote))
 if err != nil {
  panic(err)
 }
 return bz
}
```

[tendermint/consensus/codec.go](https://github.com/maticnetwork/tendermint/blob/peppermint/consensus/codec.go)

```go
package consensus

import (
 amino "github.com/tendermint/go-amino"
 "github.com/tendermint/tendermint/types"
)

var cdc = amino.NewCodec()

func init() {
 RegisterConsensusMessages(cdc)
 RegisterWALMessages(cdc)
 types.RegisterBlockAmino(cdc)
}

```

[tendermint/p2p/codec.go](https://github.com/maticnetwork/tendermint/blob/peppermint/p2p/codec.go)

```go
package p2p

import (
 amino "github.com/tendermint/go-amino"
 cryptoAmino "github.com/tendermint/tendermint/crypto/encoding/amino"
)

var cdc = amino.NewCodec()

func init() {
 cryptoAmino.RegisterAmino(cdc)
}
```

### Code Review

Polygon's [peppermint fork of tendermint](https://github.com/maticnetwork/tendermint) was forked from [tendermint](https://github.com/tendermint/tendermint) and as such the codebase has similar functions to those documented in [cosmos code review](./cosmos#code-review).

The major changes are to the consensus and signing (see above)

Polygon's [bor](https://github.com/maticnetwork/bor) is cloned from [geth](https://github.com/ethereum/go-ethereum) and as such the codebase has similar functions to those documented in [ethereum 1-0 code review](./ethereum-1-0#code-review).

#### Signing

* [Peppermint secp256k1 Codebase](https://github.com/maticnetwork/tendermint/tree/peppermint/crypto/secp256k1): Peppermint ECDSA Secp256k1 curve codebase (go).
  * [Peppermint secp256k1 signing code](https://github.com/maticnetwork/tendermint/blob/peppermint/crypto/secp256k1/secp256k1_nocgo.go#L21): Peppermint sign function (go). *Sign creates an ECDSA signature on curve Secp256k1, using SHA256 on the msg. The returned signature will be of the form R `||` S (in lower-S form).*

#### Consensus

* [Peppermint](https://github.com/maticnetwork/tendermint)
  * [state.go](https://github.com/maticnetwork/tendermint/blob/peppermint/consensus/state.go#L886): Modified to support [heimdall](https://wiki.polygon.technology/docs/pos/heimdall/overview).

### References

**Consensus**

* [The latest gossip on BFT consensus](https://arxiv.org/pdf/1807.04938.pdf): The paper presents Tendermint, a new protocol for ordering events in a distributed network under adversarial conditions.
* [Heimdall Documentation](https://wiki.polygon.technology/docs/pos/heimdall/overview/): Heimdall consensus engine uses the Cosmos-SDK and a forked version of Tendermint, called Peppermint.
* [Peppermint Documentation](https://wiki.polygon.technology/docs/pos/peppermint/): Peppermint is a modified Tendermint. It is changed to make it compatible with Ethereum addresses and verifiable on Ethereum chain.
* [Peppermint Codebase](https://github.com/maticnetwork/tendermint/tree/peppermint): Polygon fork of tendermint codebase (go).
  * [Peppermint Consensus Code](https://github.com/maticnetwork/tendermint/blob/peppermint/consensus/state.go#L70): Peppermint Consensus (go). *ConsensusState handles execution of the consensus algorithm. It processes votes and proposals, and upon reaching agreement, commits blocks to the chain and executes them against the application. The internal state machine receives input from peers, the internal validator, and from a timer.*
  * [Peppermint Consenus Configuration Code](https://github.com/maticnetwork/tendermint/blob/master/config/config.go#L443): Peppermint Consensus Configuration(go). *defines the configuration for the Tendermint consensus service, including timeouts and details about the Write Ahead Logs (WAL) and the block structure.*
  * [Peppermint Validator Set Code](https://github.com/maticnetwork/tendermint/blob/peppermint/types/validator_set.go): Peppermint Validators (go). *ValidatorSet represent a set of*Validator at a given height.\*
* [Bor Consensus Documentation](https://wiki.polygon.technology/docs/pos/bor/consensus/): Bor consensus is inspired by Clique consensus: [https://eips.ethereum.org/EIPS/eip-225](https://eips.ethereum.org/EIPS/eip-225).
* [EIP-225: Clique proof-of-authority consensus protocol](https://eips.ethereum.org/EIPS/eip-225): Clique is a proof-of-authority consensus protocol. It shadows the design of Ethereum mainnet, so it can be added to any client with minimal effort.
* [Heimdall and Bor Article](https://polygon.technology/blog/heimdall-and-bor): Article explaining Polygon(Matic) hybrid Plasma + Proof-of-Stake (PoS) platform.

**Staking**

* [Hemidall Staking Documentation](https://wiki.polygon.technology/docs/pos/heimdall/modules/staking/)
* [Polygon Staking App](https://staking.polygon.technology/): Polygon Staking Application listing 100 validators

**Additional**

<a name="f8">\[8]</a>
<a name="f9">\[9]</a> See notes and links to code in [Peppermint
summary](https://wiki.polygon.technology/docs/pos/peppermint/)

<a name="f10">\[10]</a> See Polygon validator
[documentations](https://wiki.polygon.technology/docs/maintain/validate/validator-responsibilities/)


## Celestia

* date: 2023-06-19
* last updated: 2023-06-19

### Overview

Celestia[^ov-1] is a modular consensus and data network, built to enable anyone to easily deploy their own blockchain with minimal overhead.

### Cryptographic Primitives

* [whitepaper](https://arxiv.org/pdf/1809.09044.pdf)
  * 2.2 Merkle Trees and Sparse Merkle Trees
  * 2.3 Erasure Codes and Reed-Solomon Codes
  * 5 Data Availability Proofs
    * 5.1 Strawman 1D Reed-Solomon Availability Scheme
    * 5.2 2D Reed-Solomon Encoded Merkle Tree Construction
    * 5.3 Random Sampling and Network Block Recovery
    * 5.4 Selective Share Disclosure
    * 5.5 Fraud Proofs of Incorrectly Generated Extended Data
* [Celestia App Architecture](https://github.com/celestiaorg/celestia-app/tree/main/docs/architecture)
* [Implementation celestia-app pkg](https://github.com/celestiaorg/celestia-app/tree/main/pkg)

#### Namespaced Merkle Tree Wrapper

* [code](https://github.com/celestiaorg/celestia-app/tree/main/pkg/wrapper)

### Appendices

### References

* [Learn Modular](https://celestia.org/learn/)
* [Fraud and Data Availability Proofs](https://arxiv.org/pdf/1809.09044.pdf): Maximising Light Client Security and Scaling Blockchains with Dishonest Majorities
* [Celestia App Specifications](https://celestiaorg.github.io/celestia-app/index.html)
* [Celestia App Architecture](https://github.com/celestiaorg/celestia-app/tree/main/docs/architecture)
* [Rollkit Docs](https://rollkit.dev/docs/intro/)
* [Rollkit Architecture Design Records](https://github.com/rollkit/rollkit/tree/main/docs/lazy-adr)
* [Rollkit Dependency Graph](https://github.com/rollkit/rollkit/blob/main/docs/specification/rollkit-dependency-graph.mdx)
* [Quantum Gravity Bridge](https://github.com/celestiaorg/quantum-gravity-bridge/tree/master)

### Footnotes

[^ov-1]: [Celestia](https://celestia.org/): the first modular blockchan network.


## Fast Fourier Transforms

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

### References

* [Fast Fourier Transforms](https://vitalik.ca/general/2019/05/12/fft.html)


## Fraud Proofs

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

Following is an excerpt from Fraud and Data Availability Proofs:Detecting Invalid Blocks in Light Clients [^1].

> Light clients, also known as Simple Payment Verification (SPV) clients, are nodes which only download a small portion of the data in a blockchain, and use indirect means to verify that a given chain is valid. Instead of validating blocks, they assume that the chain favoured by the blockchain’s consensus algorithm only contains valid blocks, and that the majority of block producers are honest. By allowing such clients to receive fraud proofs generated by fully validating nodes that show that a block violates the protocol rules, and combining this with probabilistic sampling techniques to verify that all of the data in a block actually is available to be downloaded so that fraud can be detected, we can eliminate the honest-majority assumption for block validity, and instead make much weaker assumptions about a minimum number of honest nodes that rebroadcast data. Fraud and data availability proofs are key to enabling on-chain scaling of blockchains while maintaining a strong assurance that on-chain data is available and valid. We present, implement, and evaluate a fraud and data availability proof system.

Here is an overview of how NEAR bridge uses this in an optimistic approach

The leading NEAR Ethereum Bridge today Near Rainbow Bridge uses an optimistic approach. Following is an excerpt from NearOnEthClient [^near-1].

> we adopt the optimistic [^near-2] approach where NearOnEthClient verifies everything in the NEAR header except the signatures. Then anyone can challenge a signature in a submitted header within a 4-hour challenge window. The challenge requires verification of a single Ed25519 signature which would cost about 500k Ethereum gas (expensive, but possible).

### Footnotes

[^1]: [Fraud and Data Availability Proofs:Detecting Invalid Blocks in Light Clients](http://www0.cs.ucl.ac.uk/staff/M.AlBassam/publications/fraudproofs.pdf): Fraud and data availability proofs are key to enabling on-chain scaling of blockchains while maintaining a strong assurance that on-chain data is available and valid.

[^near-1]: [NEAR: ETH-NEAR Rainbow Bridge](https://near.org/blog/eth-near-rainbow-bridge/): a bridge, called Rainbow Bridge, to connect the Ethereum and NEAR blockchains.

[^near-2]: [Optimistic Contracts](https://medium.com/@deaneigenmann/optimistic-contracts-fb75efa7ca84): contracts that accept all information as fact until proven to be non-factual. This allows for a reduction in the cost of verifying data, as on-chain verification would only be necessary when one is sure that the data is false.


## Cryptographic and Mathematic Primitives

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

Here we review cryptographic and mathematic primitives

For each primitive we review

* Cryptographic Primitive
* Applications
* Implementations (codebases)
* Zero Knowledge relationships/improvements


## Light Clients

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

### References

* [Building Helios: Fully trustless access to Ethereum](https://a16zcrypto.com/building-helios-ethereum-light-client/): a Rust-based Ethereum light client we developed that provides fully trustless access to Ethereum.
* [Annotated Ethereum Roadmap](https://notes.ethereum.org/@domothy/roadmap#Annotated-Ethereum-Roadmap)
*


## Cryptographic Primitives

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

Cryptographic and Mathematic Primitives

### Reference Implementations

**general primitives**

* [bloom filter](https://en.wikipedia.org/wiki/Bloom_filter)
  * [geth bloombits](https://github.com/ethereum/go-ethereum/tree/master/core/bloombits) (go): Package bloombits implements bloom filtering on batches of data.

* [int\_to\_bytes](https://ethereum.github.io/execution-specs/autoapi/ethereum/base_types/index.html)
  * [lighthouse int\_to\_bytes](https://github.com/sigp/lighthouse/tree/stable/consensus/int_to_bytes) (rust): The Eth 2.0 specification uses `int.to_bytes(2, 'little')`, which throws an error if `int` doesn't fit within 3 bytes. The specification relies upon implicit asserts for some validity conditions, so we ensure the calling function is aware of the error condition as opposed to hiding it with a modulo.

* [leaky bucket](https://en.wikipedia.org/wiki/Leaky_bucket#As_a_meter)
  * [prysm](https://github.com/prysmaticlabs/prysm/blob/develop/container/leaky-bucket/leakybucket.go): leaky bucket as a meter

* linked list
  * [prysm](https://github.com/prysmaticlabs/prysm/tree/develop/container/doubly-linked-list) (go): doubly linked list

* [merkle patrica tries](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/)
  * [geth trie](https://github.com/ethereum/go-ethereum/blob/master/trie/trie.go#L17) (go): Package trie implements Merkle Patricia Tries.
  * [geth database](https://github.com/ethereum/go-ethereum/blob/master/core/state/database.go#L63) (go): Trie is a Ethereum Merkle Patricia trie.

* [merkle trees](https://en.wikipedia.org/wiki/Merkle_tree)
  * [prysm sparse\_merkle](https://github.com/prysmaticlabs/prysm/blob/develop/container/trie/sparse_merkle.go) (go): defines utilities for sparse merkle tries for Ethereum consensus.
  * [lighthouse cached\_tree\_hash](https://github.com/sigp/lighthouse/tree/stable/consensus/cached_tree_hash) (rust): Sparse Merkle tree suitable for tree hashing vectors and lists.
  * [lighthouse tree\_hash](https://github.com/sigp/lighthouse/tree/stable/consensus/tree_hash) (rust): Convenience method for `MerkleHasher` which also provides some fast-paths for small trees.`minimum_leaf_count` will only be used if it is greater than or equal to the minimum number of leaves that can be created from `bytes`.
  * [lighthouse tree\_hash\_derive](https://github.com/sigp/lighthouse/tree/stable/consensus/tree_hash_derive) (rust):
  * [tendermint go](https://github.com/tendermint/tendermint/tree/main/crypto/merkle) (go): Merkle Tree For smaller static data structures that don't require immutable snapshots or mutability; for instance the transactions and validation signatures of a block can be hashed using this simple merkle tree logic.
  * [paritytech binary-merkle-trie](https://github.com/paritytech/substrate/tree/master/utils/binary-merkle-tree) (rust): implements a simple binary Merkle Tree utilities required for inter-op with Ethereum bridge & Solidity contract.
  * [snowbridge merkle.go](https://github.com/Snowfork/snowbridge/blob/main/relayer/crypto/merkle/merkle.go)
  * [snowbridge merkleization.rs](https://github.com/Snowfork/snowbridge/blob/main/parachain/pallets/ethereum-beacon-client/src/merkleization.rs)

* [merkle\_proof](https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.mdx) [explainer](https://soliditydeveloper.com/merkle-tree)
  * [lighthouse merkle\_proof](https://github.com/sigp/lighthouse/tree/stable/consensus/merkle_proof) (rust): efficiently represents a Merkle tree of fixed depth where only the first N indices are populated by non-zero leaves (perfect for the deposit contract tree).
  * [snowbridge simplified\_mmr\_proof.go](https://github.com/Snowfork/snowbridge/blob/main/relayer/crypto/merkle/simplified_mmr_proof.go)
  * [snowbridge merkle-proof rust](https://github.com/Snowfork/snowbridge/tree/main/parachain/pallets/basic-channel/merkle-proof)
  * [snowbridge MerkleProof.sol](https://github.com/Snowfork/snowbridge/blob/main/core/packages/contracts/contracts/utils/MerkleProof.sol)
  * [npm package eth-proof](https://www.npmjs.com/package/eth-proof)

* [Merkle Mountain Range](https://docs.grin.mw/wiki/chain-state/merkle-mountain-range/)
  * [paritytech merkle-mountain-range](https://github.com/paritytech/substrate/tree/master/primitives/merkle-mountain-range) (rust)
  * [harmony mmr (go)](https://github.com/peekpi/harmony/tree/mmrHardfork/internal/mmr): Adds a merkle mountain range to harmony's core protocol to support light clients (WIP) [PR4198](https://github.com/harmony-one/harmony/pull/4198/files)

* queues
  * [prysm](https://github.com/prysmaticlabs/prysm/tree/develop/container/queue) (go): priority queue
  * [snowbridge MMRProof.sol](https://github.com/Snowfork/snowbridge/blob/main/core/packages/contracts/contracts/utils/MMRProof.sol)
  * [snowfork merkle-mountain-range](https://github.com/Snowfork/merkle-mountain-range)

* safe-arithmetic
  * [lighthouse safe\_arith](https://github.com/sigp/lighthouse/tree/stable/consensus/safe_arith) (rust): Library for safe arithmetic on integers, avoiding overflow and division by zero.

* slice
  * [prysm](https://github.com/prysmaticlabs/prysm/tree/develop/container/slice) (go)

* [tries](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/)
  * [paritytech trie](https://github.com/paritytech/substrate/tree/master/primitives/trie): Utility functions to interact with Substrate's Base-16 Modified Merkle Patricia tree ("trie").

* [Verifiable Delay Function](https://eprint.iacr.org/2018/623.pdf)
  * [harmony vdf](https://github.com/harmony-one/harmony/tree/main/crypto/vdf) (go): Package vdf is a proof-of-concept implementation of a delay function and the security properties are not guaranteed.

* [Verfiable Random Function](https://en.wikipedia.org/wiki/Verifiable_random_function)
  * [harmony vrf](https://github.com/harmony-one/harmony/tree/main/crypto/vrf) (go): A VRF is a pseudorandom function f\_k from a secret key k, such that that knowledge of k not only enables one to evaluate f\_k at for any message m, but also to provide an NP-proof that the value f\_k(m) is indeed correct without compromising the unpredictability of f\_k for any m' != m. [https://ieeexplore.ieee.org/document/814584](https://ieeexplore.ieee.org/document/814584)
  * [paritytech vrf](https://github.com/paritytech/substrate/tree/master/primitives/consensus/vrf): Primitives for VRF-based consensus engines. Schnorrkel-based VRF.

* tree
  * [paritytech fork-tree](https://github.com/paritytech/substrate/tree/master/utils/fork-tree) (rust): Utility library for managing tree-like ordered data with logic for pruning the tree while finalizing nodes.

**Hash functions**

[SHA-2](https://en.wikipedia.org/wiki/SHA-2)

[difference between sha256 and kecakk256](https://www.geeksforgeeks.org/difference-between-sha-256-and-keccak-256/)

* [Argon 2](https://en.wikipedia.org/wiki/Argon2)
  * [Argon2](https://github.com/P-H-C/phc-winner-argon2): eference C implementation of Argon2.
  * [x/crypto Argon2](https://cs.opensource.google/go/x/crypto/+/master\:argon2/argon2.go) (go): Package argon2 implements the key derivation function Argon2.
  * [rust-argon2](https://github.com/sru-systems/rust-argon2) (rust): Rust library for hashing passwords using Argon2.
  * [node-argon2](https://www.npmjs.com/package/argon2) (typescript): Bindings to the reference Argon2 implementation.
* [blake](https://en.wikipedia.org/wiki/BLAKE_\(hash_function\))
  * [blake2](https://www.blake2.net/) hash function
    * [ethereum-go-ethereum](https://github.com/ethereum/go-ethereum/tree/master/crypto/blake2b) (go): Package blake2b implements the BLAKE2b hash algorithm defined by RFC 7693 and the extendable output function (XOF) BLAKE2Xb.
    * [bsc blake2b](https://github.com/bnb-chain/bsc/tree/master/crypto/blake2b) (go): Package blake2b implements the BLAKE2b hash algorithm defined by RFC 7693 and the extendable output function (XOF) BLAKE2Xb.
  * [blake3](https://github.com/BLAKE3-team/BLAKE3)
    * [blake3 rust crate](https://crates.io/crates/blake3) (rust): BLAKE3 is based on an optimized instance of the established hash function BLAKE2 and on the original Bao tree mode.
    * [zeebo blake3](https://github.com/zeebo/blake3) (go) : Pure Go implementation of BLAKE3 with AVX2 and SSE4.1 acceleration.
* [keccak256](https://keccak.team/keccak.html) hash function
  * [prysm](https://github.com/prysmaticlabs/prysm/blob/develop/crypto/hash/hash.go) (go)
  * [lighthouse](https://github.com/sigp/lighthouse/blob/stable/crypto/eth2_hashing/src/lib.rs) (rust): wrapper over two SHA256 crates: `sha2` and `ring`
  * [bsc crypto](https://github.com/bnb-chain/bsc/blob/master/crypto/crypto.go#L91) (go)
  * [harmony hash](https://github.com/harmony-one/harmony/blob/main/crypto/hash/hash.go) (go)
  * [snowbridge keccak](https://github.com/Snowfork/snowbridge/blob/main/relayer/crypto/keccak/keccak.go)
* [sha256](https://pkg.go.dev/crypto/sha256)
  * [tendermint tmhash](https://github.com/tendermint/tendermint/tree/main/crypto/tmhash)

**encryption**

* [ECIES](https://cryptobook.nakov.com/asymmetric-key-ciphers/ecies-public-key-encryption) (go): a hybrid encryption scheme
  * [ethereum-go-ethereum](https://github.com/ethereum/go-ethereum/tree/master/crypto/ecies) (go)
  * [bsc ecies](https://github.com/bnb-chain/bsc/tree/master/crypto/ecies) (go)
* [ascii armored encryption uses ed25519](https://www.rfc-editor.org/rfc/pdfrfc/rfc4880.txt.pdf)
  * [ethereum-go-ethereum](https://github.com/ethereum/go-ethereum/tree/master/crypto/signify) (go)
  * [bsc signify](https://github.com/bnb-chain/bsc/tree/master/crypto/signify) (go)
  * [tenderming armor](https://github.com/tendermint/tendermint/blob/main/crypto/armor/armor.go) (go)
* [ChaCha20-Poly1305](https://en.wikipedia.org/wiki/ChaCha20-Poly1305): an authenticated encryption with additional data (AEAD) algorithm
  * [tendermint xchacha20poly1305](https://github.com/tendermint/tendermint/tree/main/crypto/xchacha20poly1305) (go)
* [XSalsa20](https://libsodium.gitbook.io/doc/advanced/stream_ciphers/xsalsa20) (go): XSalsa20 is a stream cipher based upon Salsa20 but with a much longer nonce: 192 bits instead of 64 bits.
  * [tendermint xsalsa20symmetric](https://github.com/tendermint/tendermint/tree/main/crypto/xsalsa20symmetric) (go): secret must be 32 bytes long. Use something like Sha256(Bcrypt(passphrase)). The ciphertext is (secretbox.Overhead + 24) bytes longer than the plaintext.

**Random number generators**

* [prysm](https://github.com/prysmaticlabs/prysm/blob/develop/crypto/rand/rand.go) (go)

**Serialization/DeSerialization**

* [RECURSIVE-LENGTH PREFIX (RLP) SERIALIZATION](https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/)
  * [ethereum rlp](https://github.com/ethereum/go-ethereum/tree/master/rlp)
  * [harmony rlp](https://github.com/harmony-one/harmony/blob/main/crypto/hash/rlp.go)

* [Simple Serialize](https://ethereum.org/en/developers/docs/data-structures-and-encoding/ssz/)
  * [snowbridge ssz.rs](https://github.com/Snowfork/snowbridge/blob/main/parachain/pallets/ethereum-beacon-client/src/ssz.rs)

* [Merkle Patricia Trie](https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/)

**Threading**

* [prysm](https://github.com/prysmaticlabs/prysm/blob/develop/container/thread-safe/map.go): contains generic containers that are protected either by Mutexes or atomics underneath the hood.

**zero knowledge**

* hash functions
  * [Poseidon](https://www.usenix.org/system/files/sec21-grassi.pdf): A New Hash Function for
    Zero-Knowledge Proof Systems ([video](https://youtu.be/hUx3WpDV_l0))

### References

* [Bloom Filter Wikipedia](https://en.wikipedia.org/wiki/Bloom_filter): A Bloom filter is a space-efficient probabilistic data structure, conceived by Burton Howard Bloom in 1970, that is used to test whether an element is a member of a set.
* [Bloom Filters Explainer](https://www.jasondavies.com/bloomfilter/): The bloom filter essentially consists of a bit vector of length m, represented by the central column.
* [Bloomfilter Lesson 11 - Blockchain Academy](https://blockchain-academy.hs-mittweida.de/coursesblockchain-introduction-technical-beginner-to-intermediate/lessons/lesson-11-bloomfilter/): Blockchain Introduction Technical – Beginner to Intermediate Lesson 11 – Bloomfilter.
* [Cuckoo Hashing](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.25.4189\&rep=rep1\&type=pdf): a simple dictionary with worst case constant lookup time, equaling the theoretical performance of the classic dynamic perfect hashing scheme
  of Dietzfelbinger et al.
* [Cukoo Hashing Visualization](http://www.lkozma.net/cuckoo_hashing_visualization/): Visualization of Cukoo Hashing an elegant method for resolving collisions in hash tables.
* [Fast Fourier Transforms](https://vitalik.ca/general/2019/05/12/fft.html): Vitaliks explaniner on Fast Fourier Transforms. Trigger warning: specialized mathematical topic, with
  special thanks to Karl Floersch for feedback.
* [Merkle Trees/Merkle Proofs Lesson 10 - Blockchain Academy](https://blockchain-academy.hs-mittweida.de/courses/blockchain-introduction-technical-beginner-to-intermediate/lessons/lesson-10-merkle-trees-merkle-proofs/): Blockchain Introduction Technical – Beginner to Intermediate Lesson 10 – Merkle Trees/Merkle Proofs.


## Signature Schemes in Consensus Protocols

* date: 2023-02-05
* last updated: 2023-02-04

### Overview

Both sides of the bridge need to verify what happened on the other side. To do that, the verification logic is often encapsulated inside a light client, manifested as a smart contract on the chain which the verification needs to be executed. The light client needs to follow consensus and signature verification mechanisms based on the signing algorithm and the elliptical curve used on the other side. For example, if chain A has 21 validators signing each block using ECDSA algorithm on secp256k1 curves, then chain A's light client, executed on chain B, must extract the signatures from the block headers presented to the light client, and follow the ECDSA signature verification algorithm to verify the content of the block header indeeds produces the 21 signatures contained in the block header, given the public keys of the 21 validators.

Here, we present a reference table for these signature schemes and how they are used in the consensus protocols of different blockchains. We limit our initial scope to Ethereum, Polygon, Avalanche, BSC, Harmony, Cosmos, and Polkadot only (and their undelying technologies). Note that we are only looking at how signatures are used in consensus, not elsewhere in the blockchain stack, as all these protocols use ECDSA on secp256k1 for accounts in EVM interactions.

| Algorithm | Curve      | Protocol  | Code                                                                                                                                                                                                                                                             | Note                                                                                                                                                                                                                                                            |
| --------- | ---------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ECDSA     | secp256k1  | Polygon   | [lib](https://github.com/maticnetwork/tendermint/tree/peppermint/crypto/secp256k1)                                                                                                                                                                               | [Modified](https://wiki.polygon.technology/docs/pos/peppermint) Tendermint validator signature scheme                                                                                                                                                           |
|           |            | BSC       | [lib](https://github.com/bnb-chain/bsc/tree/master/crypto/secp256k1) [usage](https://github.com/bnb-chain/bsc/blob/cb9e50bdf62c6b46a71724066d39f9851181a5af/consensus/parlia/parlia.go#L546)                                                                     | Derived from [Clique](https://eips.ethereum.org/EIPS/eip-225), then [improved](https://github.com/bnb-chain/BEPs/pull/131)                                                                                                                                      |
| BLS       | BN254      | Ethereum  | [EVM](https://github.com/ethereum/go-ethereum/blob/b946b7a13b749c99979e312c83dce34cac8dd7b1/core/vm/contracts.go#L420)                                                                                                                                           | Added by [EIP-196](https://eips.ethereum.org/EIPS/eip-196),[197](https://eips.ethereum.org/EIPS/eip-197); Mainly for use in smart contracts, such as zk-snark verification. See [explainer](https://hackmd.io/@liangcc/bls-solidity#BLS-Signatures-in-Solidity) |
|           | BLS12-381  | Ethereum  | [prysm](https://github.com/prysmaticlabs/prysm/tree/develop/crypto/bls) [lighthouse](https://github.com/sigp/lighthouse/tree/stable/crypto/bls)                                                                                                                  | See [PoS design](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/keys/) and [explainer](https://hackmd.io/@benjaminion/bls12-381)                                                                                                              |
|           |            | Harmony   | [lib](https://github.com/harmony-one/bls/tree/master/ffi/go/bls) [usage](https://github.com/harmony-one/harmony/tree/main/crypto/bls)                                                                                                                            | See [design](https://docs.harmony.one/home/developers/harmony-specifics/harmony-stack#signatures-and-cryptography) and [protocol review](https://medium.com/harmony-one/2022-harmony-technical-review-88462efba368)                                             |
| RSA       | N/A        | Avalanche | [verification](https://github.com/ava-labs/avalanchego/blob/51c5edd85ccc7927443b945b427e64d91ff99f67/vms/proposervm/block/block.go#L119) [generation](https://github.com/ava-labs/avalanchego/blob/51c5edd85ccc7927443b945b427e64d91ff99f67/staking/tls.go#L121) | Uses X.509 certificate which potentially allows many algorithms; Moving towards BLS12-381 and added implementations recently                                                                                                                                    |
| EdDSA     | Curve25519 | IBC       | [lib](https://github.com/tendermint/tendermint/tree/main/crypto/ed25519) [usage](https://github.com/tendermint/tendermint/blob/main/spec/core/encoding.md#public-key-cryptography)                                                                               | Used by all chains in Cosmos network, including [Cosmos Hub](https://hub.cosmos.network/main/validators/overview.html)                                                                                                                                          |
| Schnorr   | Curve25519 | Substrate | [lib](https://github.com/paritytech/substrate/blob/master/primitives/application-crypto/src/sr25519.rs)                                                                                                                                                          | See also brief [intro](https://wiki.polkadot.network/docs/learn-cryptography#what-is-sr25519-and-where-did-it-come-from) from Polkadot                                                                                                                          |

### Resources

#### Algorithms

##### ECDSA

* [Wikipedia](https://www.wikiwand.com/en/Elliptic_Curve_Digital_Signature_Algorithm)
* Standard: [SEC 2: Recommended Elliptic Curve Domain Parameters](https://www.secg.org/sec2-v2.pdf)

##### BLS

* [Wikipedia](https://en.wikipedia.org/wiki/BLS_digital_signature)
* Paper: [Short Signatures from the Weil Pairing](https://www.iacr.org/archive/asiacrypt2001/22480516.pdf)
* Tutorial: [BLS signatures: better than Schnorr](https://medium.com/cryptoadvance/bls-signatures-better-than-schnorr-5a7fe30ea716)
* Analysis: [Secret Sharing and Threshold Signatures with BLS](https://www.dash.org/blog/secret-sharing-and-threshold-signatures-with-bls/)
* Deep dive: [BLS Signatures in Solidity](https://hackmd.io/@liangcc/bls-solidity)

##### EdDSA

* [Wikipedia](https://en.wikipedia.org/wiki/EdDSA)
* [GoLang](https://pkg.go.dev/golang.org/x/crypto/ed25519)

#### Curves

* [Curve database](https://neuromancer.sk/std/)

##### secp256k1

* [Bitcoin Wiki](https://en.bitcoin.it/wiki/Secp256k1)
* Tutorial: [A Bluffer’s Guide to secp256k1](https://medium.com/asecuritysite-when-bob-met-alice/a-bluffers-guide-to-secp256k1-404e423e612)

##### BLS12-381

* Deep dive: [BLS12-381 For The Rest Of Us](https://hackmd.io/@benjaminion/bls12-381)
* Intro: [BLS12-381: New zk-SNARK Elliptic Curve Construction](https://electriccoin.co/blog/new-snark-curve/)
* Paper: [Fast and simple constant-time hashing to the BLS12-381 elliptic curve](https://tches.iacr.org/index.php/TCHES/article/view/8348/7697)
* Benchmark: [BLS: Is it really that slow](https://www.dash.org/blog/bls-is-it-really-that-slow/)
* EIP: [EIP-2537: Precompile for BLS12-381 curve operations](https://eips.ethereum.org/EIPS/eip-2537)
* EVM launch: [Targeting Shanghai upgrade May 2023](https://ethereum-magicians.org/t/eip-2537-bls12-precompile-discussion-thread/4187/16)

##### BN254

* [Definition](https://neuromancer.sk/std/bn/bn254)
* Paper: [Pairing-Friendly Elliptic Curves of Prime Order](https://eprint.iacr.org/2005/133.pdf)
* Deep Dive: [BLS Signatures in Solidity](https://hackmd.io/@liangcc/bls-solidity)
* Speed Optimization: [New software speed records for cryptographic pairings](https://cryptojedi.org/papers/dclxvi-20100714.pdf)

#### Usage in ZKP

* [A survey of elliptic curves for proof systems](https://eprint.iacr.org/2022/586.pdf)

#### Signing Implementations

The [Standard Curve Database](https://neuromancer.sk/std/) is a good starting point for existing signing algorithms. Base implementations such as [golang crypto](https://pkg.go.dev/golang.org/x/crypto) and [rust crypto](https://docs.rs/rust-crypto/latest/crypto/) provide good reference codebases.

* [bcrypt](https://www.usenix.org/legacy/event/usenix99/provos/provos.pdf)
  * [cosmos-sdk bcrypt](https://github.com/cosmos/cosmos-sdk/tree/main/crypto/keys/bcrypt)
* [bip-0039](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
  * [lighthouse](https://github.com/sigp/lighthouse/tree/stable/crypto/eth2_wallet) (rust)
* [bls](https://en.wikipedia.org/wiki/BLS_digital_signature)
  * [ethereum-prysm](https://github.com/prysmaticlabs/prysm/tree/develop/crypto/bls)
* [bls-12-381](https://hackmd.io/@benjaminion/bls12-381)
  * [ethereum EIP-2537: Precompile for BLS12-381 curve operations](https://eips.ethereum.org/EIPS/eip-2537)
  * [ethereum-go-ethereum](https://github.com/ethereum/go-ethereum/tree/master/crypto/bls12381) (go)
  * [harmony bls](https://github.com/harmony-one/harmony/blob/main/crypto/bls/bls.go) (go): uses [harmony bls repository](https://github.com/harmony-one/bls/blob/master/readme.mdx)
    * [bls Harmony](https://github.com/harmony-one/bls) forked from [herumi/bls\_](https://github.com/herumi/bls_): written in C++, supports Go, Rust, WebAssembly (Node.js)
  * [prysm](https://github.com/prysmaticlabs/prysm/tree/develop/crypto/bls) (go)
  * [lighthouse](https://github.com/sigp/lighthouse/tree/stable/crypto/bls) (rust): provides a wrapper around several BLS implementations to provide Lighthouse-specific functionality.
  * [lighthouse](https://github.com/sigp/lighthouse/tree/stable/crypto/eth2_key_derivation) (rust): Provides path-based hierarchical BLS key derivation, as specified by [EIP-2333](https://eips.ethereum.org/EIPS/eip-2333).
    * [Aurora Rainbow Bridge Implementation](https://github.com/aurora-is-near/lighthouse/tree/stable/crypto/bls/src/impls): Implementations
      * [blst](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/impls/blst.rs)
      * [fake\_crypto](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/impls/fake_crypto.rs)
      * [milagro](https://github.com/aurora-is-near/lighthouse/blob/stable/crypto/bls/src/impls/milagro.rs): support for [Apache Milagro](https://milagro.apache.org/docs/milagro-intro/)
  * [lighthouse](https://github.com/sigp/lighthouse/tree/stable/crypto/eth2_keystore) (rust): Provides a JSON keystore for a BLS keypair, as specified by [EIP-2335](https://eips.ethereum.org/EIPS/eip-2335).
  * [bsc bls12381](https://github.com/bnb-chain/bsc/tree/master/crypto/bls12381) (go)
  * [blst](https://github.com/supranational/blst): blst (pronounced 'blast') is a BLS12-381 signature library focused on performance and security. It is written in C and assembly.
* [bn256](https://cryptojedi.org/papers/dclxvi-20100714.pdf)
  * [ethereum-go-ethereum](https://github.com/ethereum/go-ethereum/tree/master/crypto/bn256) (go)
  * [bsc bn256](https://github.com/bnb-chain/bsc/tree/master/crypto/bn256) (go)
* [ecdsa](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)
  * [bsc crypto](https://github.com/bnb-chain/bsc/blob/master/crypto/crypto.go#L169) (go): toECDSA creates a private key with the given D value. The strict parameter controls whether the key's length should be enforced at the curve size or it can also accept legacy encodings (0 prefixes).
  * [paritytech ecdsa](https://github.com/paritytech/substrate/blob/master/primitives/application-crypto/src/ecdsa.rs) (rust)
  * [cosmos-sdk ecdsa](https://github.com/cosmos/cosmos-sdk/tree/main/crypto/keys/internal/ecdsa)
* [ed25519](https://ed25519.cr.yp.to/ed25519-20110926.pdf) [golang](https://pkg.go.dev/golang.org/x/crypto/ed25519)
  * [tendermint ed25519](https://github.com/tendermint/tendermint/tree/main/crypto/ed25519) (go): GenPrivKey generates a new ed25519 private key. It uses OS randomness in conjunction with the current global random seed in tendermint/libs/common to generate the private key.
  * [paritytech ed25519](https://github.com/paritytech/substrate/blob/master/primitives/application-crypto/src/ed25519.rs) (rust)
  * [Ed25519](https://en.wikipedia.org/wiki/EdDSA): [Ed25519.sol](https://github.com/aurora-is-near/rainbow-bridge/blob/master/contracts/eth/nearbridge/contracts/Ed25519.sol)
  * [cosmos-sdk ed25519](https://github.com/cosmos/cosmos-sdk/tree/main/crypto/keys/ed25519)
* [secp256k1](https://www.secg.org/sec2-v2.pdf)
  * [ethereum-go-ethereum](https://github.com/ethereum/go-ethereum/tree/master/crypto/secp256k1) (go)
  * [prysm](https://github.com/prysmaticlabs/prysm/tree/develop/crypto/ecdsa) (go)
  * [bsc secp256k1](https://github.com/bnb-chain/bsc/tree/master/crypto/secp256k1)
  * [tendermint secp256k1](https://github.com/tendermint/tendermint/tree/main/crypto/secp256k1) (go): GenPrivKeySecp256k1 hashes the secret with SHA2, and uses that 32 byte output to create the private key.
  * [cosmos-sdk secp256k1](https://github.com/cosmos/cosmos-sdk/tree/main/crypto/keys/secp256k1)
  * [snowbridge secp256k1](https://github.com/Snowfork/snowbridge/tree/main/relayer/crypto/secp256k1)
* [secp256r1](https://www.secg.org/sec2-v2.pdf)
  * [cosmos-sdk secp256r1](https://github.com/cosmos/cosmos-sdk/tree/main/crypto/keys/secp256r1)
* [sr25519](https://wiki.polkadot.network/docs/learn-cryptography#what-is-sr25519-and-where-did-it-come-from): schnorr over ristretto25519
  * [chainsafe go-schnorrkel](https://github.com/ChainSafe/go-schnorrkel) (go): This repo contains the Go implementation of the sr25519 signature algorithm (schnorr over ristretto25519). The existing Rust implementation is here.
  * [paritytech substrate-bip39](https://github.com/paritytech/substrate-bip39) (rust): his is a crate for deriving secret keys for Ristretto compressed Ed25519 (should be compatible with Ed25519 at this time) from BIP39 phrases.
  * [paritytech sr25519](https://github.com/paritytech/substrate/blob/master/primitives/application-crypto/src/sr25519.rs) rust
  * [tendermint sr25519](https://github.com/tendermint/tendermint/tree/main/crypto/sr25519) (go): GenPrivKeyFromSecret hashes the secret with SHA2, and uses that 32 byte output to create the private key.
  * [snowbridge sr25519](https://github.com/Snowfork/snowbridge/tree/main/relayer/crypto/secp256k1)


## Weak Subjectivity

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

Following is an excerpt from *Analysis on Weak Subjectivity in Ethereum 2.0* [^1] .

> Weak subjectivity [^2] is a social-consensus-driven approach for solving the fun- damental “nothing-at-stake” problem of proof-of-stake protocols. In particular, it addresses the problem in the presence of long-range forks, while the slash- ing mechanism handles the case of short-range forks. Specifically, the current weak subjectivity mechanism deals with the following two types of long-range attacks [^3]
>
> – *Exploiting retired validators:* Adversaries can create and reveal a new chain branching from a certain block on the canonical chain, after 2/3 of validators who were active for the block have exited. Note that such validators can still justify and finalize conflicting blocks at earlier slots without being slashed after they have exited.
>
> – *Exploiting diverging validator sets:* Adversaries can build a new chain until the validator set for the new chain is sufficiently different from that of the canonical chain. The larger the difference between the two validator sets, the lower the accountable safety tolerance. For example, if the intersection of the two sets is smaller than 2/3 of each set, then it is possible to have conflicting blocks to be finalized without any validators violating the slashing conditions.
>
> *It is unknown whether this mechanism can deal with other types of long-range attacks, if any, in general.*
>
> The current weak subjectivity mechanism employs a social consensus layer in parallel to maintain sufficiently many checkpoints (called weak subjectivity check- points) so that there exist no conflicting finalized blocks that are descendants of the latest weak subjectivity checkpoint. In other words, the purpose of the latest weak subjectivity checkpoints is to deterministically identify the unique canonical chain even in the presence of conflicting finalized blocks caused by the long-range attacks.

### References

Articles and guides

* [Weak Subjectivity in Eth2.0](https://notes.ethereum.org/@adiasg/weak-subjectvity-eth2): This document is aimed for Eth2.0 client teams to understand weak subjectivity periods and their implication.

* [Phase 0 -- Weak Subjectivity Guide](https://github.com/ethereum/consensus-specs/blob/master/specs/phase0/weak-subjectivity.mdx): This document is a guide for implementing the Weak Subjectivity protections in Phase 0.

Documentation

* [Ethereum Docs: WEAK SUBJECTIVITY](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/weak-subjectivity/): This refers to a chain that can progress objectively after some initial seed of information is retrieved socially.

* [Teku Docs: Weak Subjectivity](https://docs.teku.consensys.net/Concepts/Weak-Subjectivity/): The weak subjectivity period refers to how far behind the chain head a node can be before 1/3 of validators may have exited since the node was last in sync.

Implementations

* [Prysm: weak\_subjectivity\_checks.go](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/blockchain/weak_subjectivity_checks.go)
  * [NewWeakSubjectivityVerifier](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/blockchain/weak_subjectivity_checks.go#L31) validates a checkpoint, and if valid, uses it to initialize a weak subjectivity verifier.
  * [VerifyWeakSubjectivity](https://github.com/prysmaticlabs/prysm/blob/develop/beacon-chain/blockchain/weak_subjectivity_checks.go#L52) verifies the weak subjectivity root in the service struct.

Footnotes

[^1]: [Analysis on Weak Subjectivity in Ethereum 2.0](https://github.com/runtimeverification/beacon-chain-verification/blob/master/weak-subjectivity/weak-subjectivity-analysis.pdf):

[^2]: [Proof of Stake: How I Learned to Love Weak Subjectivity](https://blog.ethereum.org/2014/11/25/proof-stake-learned-love-weak-subjectivity):

[^3]: It is unknown whether this mechanism can deal with other types of long-range attacks, if any, in general


## Overview

This is an opinionated architecture for an intent based solving protocol which facilitates single and mult-chain solving of intents. Intents can be solved on a single chain without provisioning up front capital as we arbiters can confirm mandates have been met by solvers at execution time, thus solvers may used the swappers locked funds for execution.

### Opinionated Sample Architecture from [jincubator](https://github.com/jincubator)

I'm currently designing and building solutions around Solving, Arbitrage and Indexing. This work is being done in a combination of public and private repositories on [jincubator](https://github.com/jincubator). The project is drawing inspiration from and leveraging the following codebases for key components

* Solving built in RUST leveraging [Tycho](https://docs.propellerheads.xyz/tycho/overview) from [Propellor Heads](https://www.propellerheads.xyz/) including
  * [tycho-sdk](https://github.com/propeller-heads/tycho-protocol-sdk): For integrate DEXs and other onchain liquidity protocols
  * [tycho-indexer](https://github.com/propeller-heads/tycho-indexer): a low-latency, reorg-aware stream of all attributes you need to simulate swaps over DEX and other on-chain liquidity built on [substreams](https://github.com/streamingfast/substreams)
  * [tycho-simulation](https://github.com/propeller-heads/tycho-simulation): a Rust crate which allows simulating a set of supported protocols off-chain
  * [tycho-execution](https://github.com/propeller-heads/tycho-execution): a simple, ready-to-use tool that generates the necessary data to execute trades on multiple chains and DEX's
* Intent Management platform allowing optimized trading routes optimized by solvers who do not need to provide liquidity up front
  * [the-compact](https://github.com/Uniswap/the-compact): an ownerless ERC6909 contract that facilitates the voluntary formation (and, if necessary, eventual dissolution) of reusable resource locks.
  * [arbiters](https://github.com/Uniswap/arbiters): selects a claim method based on the type of Compact message signed by the sponsor and allocator and on the desired settlement behavior. To finalize a claim, some actor must call into the arbiter, which will act on the input and translate it into their preferred claim method. The arbiter then must call the derived claim method on The Compact to finalize the claim process.
  * [Tribunal](https://github.com/uniswap/tribunal): a framework for processing cross-chain swap settlements against PGA (priority gas auction) blockchains. It ensures that tokens are transferred according to the mandate specified by the originating sponsor and enforces that a single party is able to perform the settlement in the event of a dispute. *Note: currently working on enhancing the [EIP712 Signing](https://eips.ethereum.org/EIPS/eip-712) of the [mandates](https://github.com/uniswap/tribunal?tab=readme-ov-file#mandate-structure) so that the protocol can be used for solving on a single chain and multichain settlement.*
  * Services that enable Solving and Arbitrage are drawn primarily from uniswap prototypes for [compactX](https://github.com/uniswap/compactx). *Note: it would be good to develop the majority of these in Rust and leverage Tycho's indexing and execution services*
    * [callibrator](https://github.com/Uniswap/Calibrator): An intent parameterization service, demo is [here](https://calibrat0r.com/). *Note: This will need to incorprate/integrate [mandates](https://github.com/uniswap/tribunal?tab=readme-ov-file#mandate-structure) as we build a solution for solving.*
    * [v4-router](https://github.com/jincubator/v4-router): a simple and optimized router for swapping on Uniswap V4. *Note: Currently working on integrating intents into this management into this codebase and integrating this with an optimized smart order router.*
    * [autocator](https://github.com/uniswap/autocator): A server-based allocator for The Compact that leverages protocol signatures and transactions for authentication, API reference is [here](https://autocator.org/).
    * [smallocator](https://github.com/Uniswap/Smallocator): Similar to autocator with smart contract support via EIP-4361 session authentication and signing EIP-712 Compact messages.
    * [Fillanthropist](https://github.com/Uniswap/Fillanthropist): receiving and filling broadcasted cross-chain swap intents, demo is [here](https://fillanthropist.org/). *Note: This infrastructure can be replaced by solver technology built on tycho as well as an update dissemination approach (see repo below) which can leverage tycho indexing.*
    * [disseminator](https://github.com/Uniswap/disseminator): A TypeScript WebSocket server implementation that broadcasts messages to both HTTP endpoints and WebSocket clients. The server validates incoming messages using Zod schemas and ensures proper message delivery to all connected clients. *Note: Design work still needs to be done as to the most efficient way to store and transmit detailed intent and mandate information*
  * Frontend would include swapping and also liquidity provisioning and optimized Yield strategies for Liquidity Providers two inspirational repositories are
    * [compactX](https://github.com/uniswap/compactx): a proof-of-concept, React-based web interface for performing cross-chain swaps.
    * [YOLO Protocol](https://yolo-demo-ui-hackathon-chainlink-ch.vercel.app/): A Demo app developed for a hackathon by [YOLO Protocol](https://linktr.ee/yolo.protocol) which includes a dashboard for Liquidity Providers to manage their positions.


## Uniswap V4 Hook Development - WIP

* date: 2025-06-22
* last updated: 2024-06-22

### Overview

This section documents design work to be done for enhancing Uniswap V4 through the use of hooks for better price discovery, swapping and solver execution.

It leverages [Tycho](https://docs.propellerheads.xyz/tycho/overview), Intents using [ERC-7683](https://www.erc7683.org/spec), [EIP-712](https://eips.ethereum.org/EIPS/eip-712), [Compactx](https://github.com/uniswap/compactx) and [Uniswap V4 Hooks](https://docs.uniswap.org/contracts/v4/overview). As of July 2025 I use [jincubator](https://github.com/jincubator) for research and development of prototypes.

#### Hook Mods

1. Booster Pools
2. BackRunning
3. ReHypothecation
4. Paymaster
5. Settlement Pools - CrossChain
6. Router change to Slippage Failure to create an Intent.
7. HOOK

#### Deliverables

1. No Liquidity Pool
   1. Swap via preferred LP at fixed price from Oracle
2. IntentSwap
   1. CreateIntentSwap (includes output amount in each call)
   2. ExecuteIntentSwap (uses funds from compact)
   3. SweepIntentSwap (passed a compact)
3. BoosterPool
   1. Adds IntentManagement to Any Pool
   2. Adds Dynamic fees to Any Pool
   3. Adds BackRunning via Solver
   4. Adds ReHypothecation to any pool USDCY
   5. Adds Oracle Pricing to any pool EULER-ORACLES
   6. Adds Gas Sponsorship


## Solving and Arbitrage Research

* date: 2025-06-22
* last updated: 2024-06-22

### Overview

Here you'll find my work in 2025 on Solving, Arbitrage and Indexing using [Tycho](https://docs.propellerheads.xyz/tycho/overview), Intents using [ERC-7683](https://www.erc7683.org/spec), [EIP-712](https://eips.ethereum.org/EIPS/eip-712), [Compactx](https://github.com/uniswap/compactx) and [Uniswap V4 Hooks](https://docs.uniswap.org/contracts/v4/overview). As of July 2025 I use [jincubator](https://github.com/jincubator) for research and development of prototypes.

### Abstract

Liquidity Fragmentation and Capital Efficiency are areas that can be optimized in Blockchain protocols, with the emergence of Multiple L2 Chains and a shift towards intent-based architectures. There is a greater need than ever for a settlement layer to balance provided liquidity.

Project Description: Jincubator (Working Name) provides infrastructure and services for multi-chain, intent-based protocols, leveraging hooks built on Uniswap V4.

It aims to provide the following

**Features of the Solution**

* Pool Functionality
  * JIT Liquidity Provisioning,
  * Dynamic Fees to reduce arbitrage,
  * Gas Manager allows users to pay for gas using their swap token instead of the native token,
  * Incentivization Tools for Pools to incentivize Liquidity Providers,
* Order Flow
  * Intent Solving infrastructure providing traders with the best value for their swap,
  * SlowTrack and Fastrak - Settlement Options,
* Capital Efficiency
  * Settlement Layer with Dynamic Rebalancing of Capital Across Chains,
  * JIT provisioning of liquidity to pools as needed which integrates with Yield Earning Protocols.,
  * Arbitraging Liquidity across Pools, Protocols, and Chains

**Solution we are implementing**

* Intent Based - Cross Chain Solving
* Dynamic Cross-Chain Capital Allocation for Liquidity Providers
* JIT Liquidity Provisioning for Pools
* Yield Earning Capabilities for unitilized liquidity
* Centralized Liquidity Pool which is dynamically allocated
* Settlement Layer used by Solvers and Liquidity Providers used to rebalance funds across chains.
* Advanced Indexing and Simulation capabilities to enable a global view of liquidity, swap prices and arbitrage opportunities


## Axiom

* date: 2023-06-28
* last updated: 2023-02-04

### Overview

Axiom[^ov-1] is a ZK coprocessor for Ethereum which provides smart contracts trustless access to all on-chain data and arbitrary expressive compute over it.

### References

* [Website](https://www.axiom.xyz/)
* [Documentation](https://docs.axiom.xyz/)
* [Company Profile LinkedIn](https://www.linkedin.com/company/axiom-xyz/about/)
* [Uniswap Grant](https://hackmd.io/@yisun/H1e6U42Ps) [tweet](https://twitter.com/UniswapFND/status/1617895640415207424?lang=en)
* [Intrinsic technologies builder](https://gen.xyz/blog/axiomxyz)
* [Github Repos](https://github.com/axiom-crypto)
  * [https://github.com/axiom-crypto/axiom-v1-contracts](https://github.com/axiom-crypto/axiom-v1-contracts) (uses [foundry](https://book.getfoundry.sh/), solidity and [yul](https://medium.com/@jtriley15/yul-vs-solidity-contract-comparison-2b6d9e9dc833))
  * [https://github.com/axiom-crypto/axiom-eth](https://github.com/axiom-crypto/axiom-eth) (written in rust)
  * [https://github.com/axiom-crypto/axiom-apps](https://github.com/axiom-crypto/axiom-apps) (uniswap)
  * [https://github.com/axiom-crypto/halo2-lib](https://github.com/axiom-crypto/halo2-lib) (rust zk)
* [@axiomhq npm packages](https://www.npmjs.com/search?q=%40axiomhq)
* Yi is part of the Delendum Telegram Group @yisun and Presented at [Eth Denver](https://twitter.com/axiom_xyz/status/1630960864479027200)
* [Yi Sun, Reflection and Introspection in Blockchains](https://www.youtube.com/watch?v=05uv3hsH6oA)
* [Delendum Research Workshop Slides](https://drive.google.com/drive/folders/15Ih1B4Pjr-oorAa33qlAgVH5klCHwSG3)

### Footnotes

Overview

[^ov-1]: [Axiom](https://www.axiom.xyz/): The ZK Coprocessor for Ethereum


## Zero Knowledge Research

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

Here we do a deep dive on Zero Knowledge

* Approach
* Emerging Use Cases
* Proof Systems
* Efficient Signatures
* Proof Aggregation
* Tokenomics

### Learning Material

#### Foundational

* [An Introduction to Mathematical Cryptography](https://www.amazon.com/Introduction-Mathematical-Cryptography-Undergraduate-Mathematics/dp/1493917102)
* [Introduction to Applied Linear Algebra](https://www.amazon.com/Introduction-Applied-Linear-Algebra-Matrices/dp/1316518965)
* [Calculus I - Differentiation and Integration](https://www.amazon.com/Calculus-Differentiation-Integration-Hamilton-Education-ebook/dp/B07BPHW4VL)
* [An Introduction to Mathematical Cryptography](https://www.amazon.com/Introduction-Mathematical-Cryptography-Undergraduate-Mathematics-ebook/dp/B00PULZOCI/): the mathematics behind the theory of public key cryptosystems and digital signature schemes.
* [Cryptography Algorithms](https://www.amazon.com/Next-generation-Cryptography-Algorithms-Explained-implementation/dp/1789617138)
* [Number Theory](https://crypto.stanford.edu/pbc/notes/numbertheory/)
* [zkSNARKs in a nutshell](https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell)
* [Quadratic Arithmetic Programs: from Zero to Hero](https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649)
* [Exploring Elliptic Curve Pairings](https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627)
* [Zk-SNARKs: Under the Hood](https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6)
* [The MoonMath Manual to zk-SNARKs](https://leastauthority.com/static/publications/MoonMath080822.pdf)
* [Elliptic Curve Cryptography: a gentle introduction](https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/)
* [Exploring Elliptic Curve Pairings](https://vitalik.ca/general/2017/01/14/exploring_ecp.html)
* [KZG polynomial commitments](https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html)
* [plookup](https://eprint.iacr.org/2020/315.pdf): A simplified polynomial protocol for
  lookup tables.
* [Casting out Primes](https://blog.polygon.technology/wp-content/uploads/2022/10/casting-3.pdf): a nondeterministic method for bignum arithmetic. It is inspired by the “casting out nines” technique, where some identity is checked modulo 9, providing a probabilistic result.

#### Zero Knowledge

Research Articles

* [Fraud and Data Availability Proofs](https://arxiv.org/pdf/1809.09044.pdf): Maximising Light Client Security and Scaling Blockchains with Dishonest Majorities. *Light clients, also known as Simple Payment Verification (SPV) clients, are nodes which only download a small portion of the data in a blockchain, and use indirect means to verify that a given chain is valid.* \* Research Papers (Zero Knowledge Related)
* [zkBridge: Trustless Cross-chain Bridges Made Practical](https://rdi.berkeley.edu/zkp/zkBridge/uploads/paper.pdf)
* [Caulk: Lookup Arguments in Sublinear Time](https://eprint.iacr.org/2022/621.pdf): position-hiding linkability for vector commitment schemes: one can prove in zero knowledge that one or m values that comprise commitment cm all belong to the vector of size N committed to in C.
* [HyperPlonk: Plonk with Linear-Time Prover and High-Degree Custom Gates](https://eprint.iacr.org/2022/1355.pdf)
* [SLONK—a simple universal SNARK](https://ethresear.ch/t/slonk-a-simple-universal-snark/6420): a simplification to PLONK called SLONK. We replace the permutation argument (the “P” in PLONK) in favour of a shift argument (the “S” in SLONK). We get a universal SNARK with the smallest known proof size and verification time.
* [Kate commitments from the Lagrange basis without FFTs](https://notes.ethereum.org/T0ZVaaywQAqP4jegqO3asg?view): how to commit, evaluate and open polynomials in the Lagrange basis without FFTs. This is the first part in a series (see part 1, part 2, part 3) showing how to do PLONK-style universal SNARKs without FFTs
* [Hadamard checks from the Lagrange basis without FFTs](https://notes.ethereum.org/Il4z42lmQtaUYFigsjsk2Q?view): how to prove Hadamard relations between polynomials in the Lagrange basis without FFTs. This is the second part (see part 1, part 2, part 3) in a series showing how to do PLONK-style universal SNARKs without FFTs.
* [PLONK-style SNARKs without FFTs](https://notes.ethereum.org/DLRqK9V7RIOsTZkab8Hm_Q?view): how to do PLONK-style universal SNARKs without FFTs. This is part 3 in a series (part 1, part 2, part 3).
* [An efficient verifiable state for zk-EVM and beyondfrom the Anemoi hash function](https://eprint.iacr.org/2022/1487.pdf)
* [Plonky2: Fast Recursive Arguments with PLONK and FRI](https://github.com/mir-protocol/plonky2/blob/main/plonky2/plonky2.pdf)

articles and learning resources

* [Bridging the Multichain Universe with Zero Knowledge Proofs](https://medium.com/@ingonyama/bridging-the-multichain-universe-with-zero-knowledge-proofs-6157464fbc86)
* [awesome-zkml](https://github.com/worldcoin/awesome-zkml)
* [https://learn.0xparc.org/](https://learn.0xparc.org/): ZK Learning Resources
* [Delendum ZKP Knowledge base](https://kb.delendum.xyz/)
* [https://appliedzkp.org](https://appliedzkp.org/): Privacy and Scaling Exploration
* [https://zkp.science/](https://zkp.science/): Zero-Knowledge Proofs
* [https://starkware.co/stark-101/](https://starkware.co/stark-101/): Stark 101: write a STARK prover from scratch
* [https://docs.starkware.co/starkex/index.html](https://docs.starkware.co/starkex/index.html): - Starkware StarkeEx
* [Noir](https://docs.aztec.network/developers/noir) Noir is a Domain Specific Language for developing ZK-provable programs. (Rust based)
  * [article](https://medium.com/aztec-protocol/introducing-noir-the-universal-language-of-zero-knowledge-ff43f38d86d9)
  * [tweet](https://twitter.com/aztecnetwork/status/1578082456212643840)
  * [Grants](https://aztec.network/grants/)
* [Arkworks](https://github.com/arkworks-rs)
* [zkrepl.dev](https://zkrepl.dev/)
* [succinct](https://blog.succinct.xyz/)
* [ZK BATCH ECDSA](https://blog.succinct.xyz/post/2022/10/03/batch-ecdsa/)
* [Batch ECDSA Verification](https://github.com/puma314/batch-ecdsa)
* [Bringing IBC to Ethereum using ZK-Snarks](https://ethresear.ch/t/bringing-ibc-to-ethereum-using-zk-snarks/13634)
* [MINA docs](https://docs.minaprotocol.com/)

implementation articles

* [zkPoS: End-to-End Trustless](https://hyperoracle.medium.com/zkpos-end-to-end-trustless-65edccd87c5a): HyperOracle article on how zkPoS provides the ability of proving the consensus with ZK.
* [Succinct Towards the endgame of blockchain interoperability with proof of consensus](https://blog.succinct.xyz/post/2022/09/20/proof-of-consensus)

#### Codebases

* [Circom](https://github.com/iden3/circom) a novel domain-specific language for defining arithmetic circuits that can be used to generate zero-knowledge proofs

* [DarkForest](https://github.com/darkforest-eth) zkSNARK space warfare
  * [Awesome List](https://github.com/snowtigersoft/awesome-darkforest)
  * [Our front end code (the game is open source!)](https://github.com/darkforest-eth/client/tree/master/src/Frontend)
  * [Twitter](https://twitter.com/darkforest_eth)

* [Discord](https://discord.gg/2u2TN6v8r6)
  * [Team Blog](http://blog.zkga.me/)
    * [Dark Forest v0.6](https://blog.zkga.me/announcing-v6)
    * [Exploiting DF v0.5 Artifact Minting](https://blog.zkga.me/artifact-minting-exploit)
    * [v0.5 Plugins Contest Winners](https://blog.zkga.me/v5-plugins-contest-winners)
    * [Zero-Knowledge Proofs for Engineers](https://blog.zkga.me/intro-to-zksnarks)
    * [Announcing Dark Forest](https://blog.zkga.me/announcing-darkforest)
    * [The Strongest Crypto Gaming Thesis: Why we're building Dark Forest](https://gubsheep.mirror.xyz/nsteOfjATPSKH0J8lRD0j2iynmvv_C8i8eb483UzcTM)
  * [Community plugins](http://plugins.zkga.me/)
  * [Community-run wiki](http://dfwiki.net/)
  * Player-made content
    * [Dark Forest GPU universe explorer](https://www.longrocklabs.com/articles/the-exploration-era-begins/)
    * [Getting started with Dark Forest](https://www.youtube.com/watch?v=keY4a9cKmgg)
    * [Setting up a remote miner](https://www.youtube.com/watch?v=Kus4fWNg3zo)
    * [Dark Forest battle timelapse](https://www.youtube.com/watch?v=o9A-cfDanTY)

* [halo2ecc-s](https://github.com/DelphinusLab/halo2ecc-s): Re-implement an ecc circuits with halo2

* [plonky2](https://github.com/mir-protocol/plonky2): a SNARK implementation based on techniques from PLONK and FRI. It has since expanded to include tools such as Starky, a highly performant STARK implementation.
  * [plonky2-solidity-verifier](https://github.com/polymerdao/plonky2-solidity-verifier)
  * [plonky2-circom](https://github.com/polymerdao/plonky2-circom): Plonky2 verifier in Circom
  * [plonky2-ed25519](https://github.com/polymerdao/plonky2-ed25519): SNARK verification circuits of a digital signature scheme Ed25519 implemented with Plonky2.
  * [plonky2-sha256](https://github.com/polymerdao/plonky2-sha256): SNARK circuits of a cryptographic hash function SHA-256 implemented with Plonky2.
  * [plonky2-sha512](https://github.com/polymerdao/plonky2-sha512): SNARK circuits of a cryptographic hash function SHA-512 implemented with Plonky2.
  * [plonky2-pairing](https://github.com/polymerdao/plonky2-pairing)

#### Presentations

* [Devcon VI](https://archive.devcon.org/archive/playlists/devcon-6/)
* [Light Client After the Merge](https://archive.devcon.org/archive/watch/6/light-clients-after-the-merge/?playlist=Devcon%206\&tab=YouTube) [video](https://www.youtube.com/watch?v=ZHNrAXf3RDE)
* [What to Know about Zero Knowledge](https://archive.devcon.org/archive/watch/6/what-to-know-about-zero-knowledge/?playlist=Devcon%206\&tab=YouTube)
* [ZK Application ShowCase](https://archive.devcon.org/archive/watch/6/zk-application-showcase/?playlist=Devcon%206\&tab=YouTube)
* [ZK Badges: How to prove that you donated to Gitcoin grants](https://archive.devcon.org/archive/watch/6/zk-badges/?playlist=Devcon%206\&tab=YouTube)
* [ZK Security Self Led Session](https://archive.devcon.org/archive/watch/6/zk-security-self-led-session/?playlist=Devcon%206\&tab=YouTube)
* [zkEVM Vs EVM: Full Equivalence?](https://archive.devcon.org/archive/watch/6/zkevm-vs-evm-full-equivalence/?playlist=Devcon%206\&tab=YouTube)
* [ZK Application Design Patterns](https://archive.devcon.org/archive/watch/6/zk-application-design-patterns/?playlist=Devcon%206\&tab=YouTube) [video](https://www.youtube.com/watch?v=-PUKinjbLR8)
* [Applied ZK SLS presentations](https://www.notion.so/360fcd3f2a824759b1373ddeef5bf564)

#### Additional Information

* Review [ENS Bridging Strategy](https://medium.com/the-ethereum-name-service/mvp-of-ens-on-l2-with-optimism-demo-video-how-to-try-it-yourself-b44c390cbd67) and [repo](https://github.com/ensdomains/l2gateway-demo/)

* [Succinct](https://blog.succinct.xyz/post/2022/09/20/proof-of-consensus) [$600K](https://forum.gnosis.io/t/gip-57-should-gnosis-dao-support-research-of-a-zksnark-enabled-light-client-and-bridge/5421) [tweet](https://twitter.com/succinctlabs/status/1572299292177481729) [Demo](https://www.zkbridge.wtf/) [github](https://github.com/succinctlabs) [video](https://youtu.be/Ct6H5GcnA0A?t=15554) built using [circom](https://docs.circom.io/)

* [circom](https://docs.circom.io/)

* [Arkworks](https://github.com/arkworks-rs/), [tutorial](https://github.com/arkworks-rs/r1cs-tutorial/), [twitter](https://twitter.com/arkworks_rs), [video](https://youtu.be/Ct6H5GcnA0A?t=7429)

* [Aztec.network](http://Aztec.network) [Noir](https://aztec.network/noir) [intro](https://medium.com/aztec-protocol/introducing-noir-the-universal-language-of-zero-knowledge-ff43f38d86d9), [github](https://github.com/noir-lang/noir), [twitter](https://twitter.com/aztecnetwork), [docs](https://noir-lang.github.io/book/index.html)

* [GNark](https://github.com/ConsenSys/gnark)

* [ElectronLabs](https://electronlabs.org/)

* [ZKU](https://zku.one/) [Learning](https://www.notion.so/Learning-50b5a6ecc45b46248323f0e552b6885f)

* Review [matter-labs knowledge base](https://github.com/matter-labs/awesome-zero-knowledge-proofs#learn)

* [zkSNARKS explained like you're someone who knows some math and some coding](https://www.reddit.com/r/zkTech/comments/tfjvrj/zksnarks_explained_like_youre_someone_who_knows/)

* [The Halo2 Book](https://zcash.github.io/halo2/concepts/proofs.html)

* [A survey of elliptic curves for proof systems](https://eprint.iacr.org/2022/586.pdf)

* zkEVM
  * [zkSync Era](https://era.zksync.io/docs/dev/)
  * [Polygon zkEVM](https://wiki.polygon.technology/docs/zkEVM/develop/)
  * [zkSync zkEVM](https://docs.zksync.io/zkevm/)
  * [ConsenSys zkEVM](https://docs.zkevm.consensys.net/overview)


## ZK Proof of Stake

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

Here we review how zero knowledge primitives can be applied to confirm Proof of Stake Consensus.

### References

* [Paths toward single-slot finality](https://notes.ethereum.org/@vbuterin/single_slot_finality): A look at how to improve Ethereum’s LMD GHOST + Casper FFG consensus.
* [zkPoS: End-to-End Trustless](https://hyperoracle.medium.com/zkpos-end-to-end-trustless-65edccd87c5a): HyperOracle article on how zkPoS provides the ability of proving the consensus with ZK.
* [halo2ecc-s](https://github.com/DelphinusLab/halo2ecc-s/tree/pairing): Re-implement an ecc circuits with halo2
* [An efficient verifiable state for zk-EVM and beyondfrom the Anemoi hash function](https://eprint.iacr.org/2022/1487.pdf)


## zk-SNARKs

* date: 2023-02-04
* last updated: 2023-02-04

### Overview

Zero-Knowledge Succinct Non-Interactive Argument of Knowledge

A proof construction where one can prove possession of certain information, e.g. a secret key, without revealing that information, and without any interaction between the prover and verifier.

### References

* [Zk-SNARKs: Under the Hood](https://medium.com/@VitalikButerin/zk-snarks-under-the-hood-b33151a013f6)
* [What are zk-SNARKs](https://z.cash/technology/zksnarks/)
* [Introduction to zk-SNARKs](https://consensys.net/blog/developers/introduction-to-zk-snarks/)
* [zk-STARKs vs. zk-SNARKs explained](https://cointelegraph.com/explained/zk-starks-vs-zk-snarks-explained)

